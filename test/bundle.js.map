{"version":3,"sources":["webpack:///webpack/bootstrap 8c077cb0067b57daaa83","webpack:///./~/ol/index.js","webpack:///./~/ol/extent.js","webpack:///./~/ol/geom/geometrytype.js","webpack:///./~/ol/math.js","webpack:///./~/ol/geom/geometrylayout.js","webpack:///./~/ol/array.js","webpack:///./~/ol/geom/flat/deflate.js","webpack:///./~/ol/geom/simplegeometry.js","webpack:///./~/ol/obj.js","webpack:///./~/@turf/helpers/index.js","webpack:///./~/ol/asserts.js","webpack:///./~/ol/geom/flat/inflate.js","webpack:///./~/ol/geom/flat/closest.js","webpack:///./~/ol/geom/flat/simplify.js","webpack:///./~/@turf/meta/index.js","webpack:///./~/ol/events.js","webpack:///./~/ol/geom/flat/contains.js","webpack:///./~/ol/geom/flat/intersectsextent.js","webpack:///./~/ol/geom/geometry.js","webpack:///./~/ol/proj/units.js","webpack:///./~/should-type/cjs/should-type.js","webpack:///./~/ol/geom/linestring.js","webpack:///./~/@turf/invariant/index.js","webpack:///./~/ol/events/eventtype.js","webpack:///./~/ol/geom/flat/area.js","webpack:///./~/ol/geom/point.js","webpack:///./~/ol/proj.js","webpack:///./~/ol/proj/projection.js","webpack:///./~/ol/feature.js","webpack:///./~/@turf/distance/index.js","webpack:///./~/ol/color.js","webpack:///./~/ol/events/event.js","webpack:///./~/ol/format/feature.js","webpack:///./~/ol/functions.js","webpack:///./~/ol/geom/flat/interiorpoint.js","webpack:///./~/ol/geom/flat/interpolate.js","webpack:///./~/ol/geom/flat/orient.js","webpack:///./~/ol/geom/flat/segments.js","webpack:///./~/ol/geom/multipoint.js","webpack:///./~/ol/geom/polygon.js","webpack:///./~/ol/object.js","webpack:///./~/ol/proj/proj4.js","webpack:///./~/ol/sphere.js","webpack:///./~/ol/sphere/normal.js","webpack:///./~/should-type-adaptors/cjs/should-type-adaptors.js","webpack:///./~/should-util/cjs/should-util.js","webpack:///./~/should/cjs/should.js","webpack:///(webpack)/buildin/global.js","webpack:///./~/should-approximately-deep/index.js","webpack:///./~/should/as-function.js","webpack:///./pointsalongline.js","webpack:///./~/@turf/along/index.js","webpack:///./~/@turf/bearing/index.js","webpack:///./~/@turf/destination/index.js","webpack:///./~/@turf/flatten/index.js","webpack:///./~/@turf/line-distance/index.js","webpack:///./~/base64-js/index.js","webpack:///./~/buffer/index.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///./~/ol/assertionerror.js","webpack:///./~/ol/colorlike.js","webpack:///./~/ol/disposable.js","webpack:///./~/ol/dom.js","webpack:///./~/ol/events/eventtarget.js","webpack:///./~/ol/extent/corner.js","webpack:///./~/ol/extent/relationship.js","webpack:///./~/ol/format/formattype.js","webpack:///./~/ol/format/geojson.js","webpack:///./~/ol/format/jsonfeature.js","webpack:///./~/ol/geom/flat/center.js","webpack:///./~/ol/geom/flat/length.js","webpack:///./~/ol/geom/flat/reverse.js","webpack:///./~/ol/geom/flat/transform.js","webpack:///./~/ol/geom/geometrycollection.js","webpack:///./~/ol/geom/linearring.js","webpack:///./~/ol/geom/multilinestring.js","webpack:///./~/ol/geom/multipolygon.js","webpack:///./~/ol/has.js","webpack:///./~/ol/imagestate.js","webpack:///./~/ol/objecteventtype.js","webpack:///./~/ol/observable.js","webpack:///./~/ol/proj/epsg3857.js","webpack:///./~/ol/proj/epsg4326.js","webpack:///./~/ol/proj/projections.js","webpack:///./~/ol/proj/transforms.js","webpack:///./~/ol/render/canvas.js","webpack:///./~/ol/sphere/wgs84.js","webpack:///./~/ol/style/circle.js","webpack:///./~/ol/style/fill.js","webpack:///./~/ol/style/image.js","webpack:///./~/ol/style/regularshape.js","webpack:///./~/ol/style/stroke.js","webpack:///./~/ol/style/style.js","webpack:///./~/ol/webgl.js","webpack:///./~/process/browser.js","webpack:///./~/should-equal/cjs/should-equal.js","webpack:///./~/should-format/cjs/should-format.js","webpack:///./~/should/index.js","webpack:///./~/util/~/inherits/inherits_browser.js","webpack:///./~/util/support/isBufferBrowser.js","webpack:///./~/util/util.js","webpack:///./test/test.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,4BAA4B;;;AAG5B;AACA;AACA;AACA,UAAU;AACV;AACA,sBAAsB;;;AAGtB;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;ACxPA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,WAAW;AACtB;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,cAAc;AACzB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,sBAAsB;AACjC,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,8BAA8B;AACzC,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,sBAAsB;AACjC,YAAY,UAAU;AACtB;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,UAAU;AACtB;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,8BAA8B;AACzC,YAAY,UAAU;AACtB;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,mCAAmC;AAC9C,WAAW,GAAG;AACd,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH,gFAAmC;AACnC;AACA,oBAAoB,eAAe;AACnC;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC;AACA,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrxBA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AClBA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA,8EAAiC;AACjC;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA,YAAY,eAAe;AAC3B;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;;;;;;ACrMA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,EAAE;AACb,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;;AAEA,KAAK,OAAO;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,OAAO;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,cAAc;AACzB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;;;AAGA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,cAAc;AACzB,WAAW,qCAAqC;AAChD;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,wBAAwB;AACnC,WAAW,wBAAwB;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,cAAc;AACd;AACA;AACA;AACA,GAAG;AACH,aAAa,gBAAgB;AAC7B;AACA;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;ACtPA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;;AAGA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,oBAAoB,uBAAuB;AAC3C;;;AAGA;AACA,WAAW,uBAAuB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,oBAAoB,OAAO;AAC3B;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,MAAM;AAClB;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA,eAAe,oCAAoC;AACnD,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,wBAAwB;AACnC;AACA;;;AAGA;AACA,WAAW,iCAAiC;AAC5C,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,OAAO;AACP,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9UA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtEA;AACA,oBAAoB,eAAe,eAAe,cAAc;AAChE;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA,WAAW,cAAc;AACzB,WAAW,QAAQ,2CAA2C,cAAc;AAC5E;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,oDAAoD,aAAa,gCAAgC,cAAc;AAC/G;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gCAAgC;AACxC;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB,aAAa,oBAAoB;AACjC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,sBAAsB,uBAAuB,gBAAgB,wBAAwB;AACrF;AACA;AACA,WAAW,UAAU;AACrB,aAAa,kBAAkB;AAC/B;AACA;AACA,mCAAmC,mBAAmB;AACtD,mCAAmC,mBAAmB;AACtD,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,QAAQ;AACnB,aAAa,yBAAyB;AACtC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB,aAAa,oBAAoB;AACjC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,QAAQ;AACnB,aAAa,sBAAsB;AACnC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc,kCAAkC;AAChD;AACA;AACA;AACA,WAAW,OAAO,SAAS,EAAE;AAC7B,WAAW,QAAQ;AACnB,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACraA;AACA;;;AAGA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,+BAA+B;AAC1C,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,uCAAuC;AAClD;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5PA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kF;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;;AAEzB;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA,aAAa;AACb,2BAA2B,mBAAmB;AAC9C,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA,aAAa;AACb,2BAA2B,mBAAmB;AAC9C,+BAA+B,sBAAsB;AACrD,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA,aAAa;AACb,2BAA2B,gCAAgC;AAC3D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;;AAEzB;AACA;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACp0BA;AACA;;;AAGA;AACA,WAAW,aAAa;AACxB,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,sBAAsB,8BAA8B;AACpD,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI,8BAA8B;AAClC;AACA;AACA,SAAS,uBAAuB;AAChC;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,QAAQ;AACnB;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI,uBAAuB,KAAK,2BAA2B;AAC3D;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/OA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnHA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,iBAAiB,cAAc;AAC/B,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA,IAAI,+BAA+B;AACnC,WAAW,cAAc;AACzB,WAAW,eAAe;AAC1B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB;AACA,YAAY,UAAU;AACtB;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA,mBAAmB;AACnB;AACA;AACA,WAAW,OAAO;AAClB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,iBAAiB;AAC7B;AACA;;;AAGA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,+BAA+B,yBAAyB;AACxD,WAAW,kBAAkB;AAC7B,+BAA+B,yBAAyB;AACxD,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvPA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;8CC7BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA,2CAA2C,OAAO;AAClD;AACA;AACA,gBAAgB;AAChB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iEAAiE;AACjE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,+B;;;;;;;;;;;;;;;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,sBAAsB;AACjC,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,mDAAmD;AAC9D;AACA,WAAW,GAAG;AACd;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5QA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C,aAAa,WAAW;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,cAAc;AACtD,yBAAyB,kBAAkB;AAC3C;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,wBAAwB;AAChE,yBAAyB,kBAAkB;AAC3C;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa,cAAc;AAC3B,YAAY,MAAM;AAClB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa,OAAO;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClMA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,cAAc;AACzB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,qBAAqB;AAChC;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,sBAAsB,mBAAmB;AACzC;AACA;;;AAGA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,uCAAuC;AAClD;AACA,iCAAiC,oBAAoB;AACrD,wBAAwB,oBAAoB;AAC5C,WAAW,uCAAuC;AAClD;AACA,iCAAiC,oBAAoB;AACrD,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,cAAc,2BAA2B;AACzC;AACA,WAAW,uCAAuC;AAClD;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,iBAAiB,gBAAgB;AACjC,iBAAiB,QAAQ;AACzB,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,mBAAmB;AAC9B;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,mBAAmB;AAC9B;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,4FAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,8BAA8B;AACtC,gCAAgC,uBAAuB;AACvD;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;AC3eA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,2BAA2B,cAAc;;AAEzC;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;;;AAGA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iDAAiD;AAC7D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,qCAAqC;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;;;AAGA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,IAAI,0BAA0B;AAC9B,YAAY;AACZ,gDAAgD;AAChD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,8BAA8B,iCAAiC;AAC/D,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW;AACX,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,gEAAgE;AAC3E;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5TA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,sCAAsC;AACjD,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtDA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,0CAA0C,EAAE,EAAE,IAAI;;;AAGlD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,4CAA4C,OAAO;AACnD;AACA;;;AAGA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,qBAAqB,OAAO;AAC5B,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,KAAK;;;AAGL;AACA,WAAW,OAAO;AAClB;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;AACzC,yBAAyB;AACzB,2FAA8C;AAC9C,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,oCAAoC;AACvC;AACA;AACA,GAAG,mCAAmC;AACtC;AACA;AACA;AACA,GAAG;AACH,gFAAmC;AACnC;AACA,oBAAoB,SAAS;AAC7B;;;AAGA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxMA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI,4BAA4B;AAChC;AACA;AACA,gBAAgB;AAChB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;;;AAGA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,IAAI,kBAAkB;AACtB,IAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;;AAGA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,wBAAwB;AACnC,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,yDAAyD;AACpE;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,wBAAwB;AACnC,YAAY,WAAW;AACvB;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,wBAAwB;AACnC,YAAY,mBAAmB;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,wBAAwB;AACnC,YAAY,iBAAiB;AAC7B;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,YAAY,mBAAmB;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,kDAAkD;AAC7D;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,gBAAgB,eAAe;AAC/B;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClNA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;;;;;;;;;ACjBA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACzFA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClLA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7IA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,mDAAmD;AAC9D;AACA,WAAW,GAAG;AACd;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,sBAAsB;AACjC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,8BAA8B;AACzC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjdA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,yDAAyD;AACzD,IAAI,aAAa;AACjB;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,yDAAyD,IAAI,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAqD;AACzE;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,wEAA2B;AAC3B;;;AAGA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa;AACb,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/NA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kDAAkD;AAClD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sE;;;;;;;;AC1GA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;;;;;;;ACTA;;AAEA,8CAA8C,cAAc;;AAE5D,+BAA+B,iFAAiF;;AAEhH;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4B;;;;;;;AC3RA;;AAEA,8CAA8C,cAAc;;AAE5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kD;;;;;;;ACjDA;;AAEA,+BAA+B,iFAAiF;;AAEhH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG,0BAA0B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO,iBAAiB,QAAQ;AACvC,gCAAgC,WAAW;AAC3C;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB;AACnB;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,OAAO,MAAM,kCAAkC,MAAM;AACrD,OAAO,MAAM,mCAAmC,MAAM;AACtD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE,MAAM;AACN;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA,OAAO,OAAO,8BAA8B,OAAO;AACnD;AACA;AACA;AACA;AACA,OAAO,YAAY,SAAS,qBAAqB,QAAQ;AACzD,OAAO,YAAY,SAAS,qBAAqB,KAAK,SAAS;AAC/D,OAAO,YAAY,SAAS,qBAAqB,QAAQ;AACzD,yCAAyC,YAAY,QAAQ,EAAE,aAAa;AAC5E,6BAA6B,YAAY,QAAQ,EAAE;AACnD;AACA;AACA,mBAAmB;;AAEnB;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY,uBAAuB,6BAA6B,MAAM;AAC7E,OAAO,YAAY,uBAAuB,6BAA6B,IAAI,OAAO;AAClF,OAAO,YAAY,uBAAuB,6BAA6B,IAAI,WAAW;AACtF;AACA;AACA,mBAAmB;;AAEnB;AACA,iCAAiC;AACjC;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,+FAA+F;AACpG;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,iCAAiC;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK,+FAA+F;AACpG;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,OAAO,QAAQ,2CAA2C,mBAAmB;AAC7E;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA,OAAO,QAAQ;AACf,OAAO,eAAe;AACtB,OAAO,eAAe,0BAA0B,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,mBAAmB;AACnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,OAAO,QAAQ;AACf,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA,mBAAmB;AACnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA,OAAO,KAAK,OAAO;AACnB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAgE;AAC7E,aAAa,OAAO;AACpB;AACA;AACA,iBAAiB,0BAA0B;AAC3C,iBAAiB,0BAA0B;AAC3C,iBAAiB,0BAA0B;AAC3C;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA,iBAAiB,aAAa,EAAE,uBAAuB,QAAQ;AAC/D,iBAAiB,aAAa,EAAE,gBAAgB,QAAQ;AACxD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,OAAO,wBAAwB;AAC/B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,OAAO,sBAAsB,QAAQ,QAAQ;AAC7C,aAAa;AACb;AACA,OAAO;AACP;AACA,kBAAkB,QAAQ;AAC1B,aAAa;AACb;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,qEAAqE;AACrE;AACA,6CAA6C;AAC7C,2CAA2C,iBAAiB,EAAE;AAC9D;AACA;AACA,mBAAmB;;AAEnB;AACA,oCAAoC;;AAEpC;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA,OAAO,yGAAyG;AAChH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,wDAAwD,2BAA2B;AACnF;AACA,MAAM,yBAAyB,mCAAmC,2BAA2B;AAC7F;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,sDAAsD,2BAA2B;AACjF;AACA,KAAK,yBAAyB,kCAAkC,2BAA2B;AAC3F;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ,WAAW,QAAQ;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,cAAc,mDAAmD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH,UAAU;AACV;;AAEA;AACA;AACA;AACA,YAAY,mDAAmD;AAC/D;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3uFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;ACxBA;;;;;;;;;;;;;ACAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA;AACA;AACA;AACA;;AAEA;AACA,YAAY,sBAAsB,gBAAgB,kBAAkB;AACpE;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,eAAe;AAC5B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;AClDA;AACA;AACA;;AAEA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,sCAAsC;AACjD,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY,+GAA+G;AACvI;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,eAAe;AAC5B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACrDA;AACA;;AAEA;AACA,iBAAiB,cAAc,OAAO,wBAAwB;AAC9D;AACA;AACA,WAAW,wCAAwC;AACnD,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,iBAAiB,KAAK,cAAc;AAChD;AACA;AACA,WAAW,sEAAsE;AACjF,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC5GA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;ACJA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa;AACb,gBAAgB;AAChB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,MAAM,mDAAmD;AACzD;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;;;;;;;ACpCA;AACA;;;AAGA;AACA,WAAW,sBAAsB;AACjC,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D,GAAG;AACH,uFAA0C,SAAS;AACnD;AACA;;;AAGA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7BA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;;AAGA;AACA,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY;AACZ,6DAA6D;AAC7D,cAAc;AACd,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5JA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACXA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACVA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,2BAA2B;AACtC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA,WAAW,0CAA0C;AACrD,WAAW,wBAAwB;AACnC;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;;;AAGA;AACA,WAAW,0BAA0B;AACrC,WAAW,wBAAwB;AACnC;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;;AAGA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;;;AAGA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;;;AAGA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;;;AAGA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;;;AAGA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;;;AAGA;AACA,WAAW,iBAAiB;AAC5B,WAAW,yBAAyB;AACpC;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;;;AAGA;AACA,WAAW,iBAAiB;AAC5B;AACA,YAAY,0BAA0B;AACtC;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,2BAA2B;AACtC,WAAW,yBAAyB;AACpC;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA,kFAAoC;AACpC;AACA;AACA,GAAG;AACH,oBAAoB,0BAA0B;AAC9C;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,mBAAmB;AAC9B,WAAW,yBAAyB;AACpC;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,wBAAwB;AACnC,WAAW,yBAAyB;AACpC;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,mBAAmB;AAC9B,WAAW,yBAAyB;AACpC;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,qBAAqB;AAChC,WAAW,yBAAyB;AACpC;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,cAAc;AACzB,WAAW,yBAAyB;AACpC;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,GAAG;AACH;;;AAGA;AACA,WAAW,gBAAgB;AAC3B,WAAW,yBAAyB;AACpC;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,wBAAwB;AACnC,YAAY,WAAW;AACvB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,wBAAwB;AACnC,YAAY,mBAAmB;AAC/B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C,GAAG;AACH,gCAAgC,eAAe;AAC/C;AACA,2BAA2B,0CAA0C;AACrE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C,aAAa,mBAAmB;AAChC;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,wBAAwB;AACnC,YAAY,iBAAiB;AAC7B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;;AAGA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,YAAY,mBAAmB;AAC/B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kFAAqC;AACrC;AACA,GAAG;AACH;AACA;AACA,oBAAoB,mBAAmB;AACvC;;;AAGA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,yBAAyB;AACpC,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,eAAe;AACzC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,yBAAyB;AACpC,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,yBAAyB;AACpC,YAAY,0CAA0C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8E;;;;;;;;;;ACvkBA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,WAAW,4BAA4B;AACvC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC;AACA,YAAY,WAAW;AACvB;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC;AACA,YAAY,mBAAmB;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC;AACA,YAAY,iBAAiB;AAC7B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,mBAAmB;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,yBAAyB;AACpC,YAAY,OAAO;AACnB;AACA;AACA;;;;;;;;;ACzKA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA,aAAa;AACb,WAAW,0BAA0B;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA,WAAW,yBAAyB;AACpC;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,aAAa;AACb,WAAW,sBAAsB;AACjC,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,8BAA8B;AACzC,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,8BAA8B;AACzC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,sCAAsC;AACjD,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,kCAAkC,oCAAoC;AACtE,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClaA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA,2DAA2D,QAAQ;AACnE,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;;AAElC;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;ACjKA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACVA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,IAAI,4BAA4B;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,GAAG;AACH,sFAAyC,aAAa;AACtD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,6DAA6D;AAC7D,cAAc;AACd;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA,yBAAyB,OAAO;AAChC;AACA;;;AAGA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA,yBAAyB,OAAO;AAChC;AACA;;;AAGA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,GAAG;AACH,uFAA0C,OAAO;AACjD;AACA;AACA;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtCA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7FA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;;;;;;;;;ACTA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;;AAGA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5DA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA,0DAA0D,mBAAmB;AAC7E,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AClFA;AACA;AACA;AACA,yBAAyB,oBAAoB,GAAG,sBAAsB;AACtE,IAAI,4BAA4B;AAChC;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,yCAAyC;AACrD;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,yCAAyC;AACrD;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;;;AAGA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,EAAE;AACb,YAAY,uBAAuB;AACnC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,EAAE;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,4BAA4B,OAAO;AACnC;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;ACpjBA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtRA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;;AAGA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,iBAAiB;AACzC;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,uDAAuD;AAClE;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA,WAAW,6BAA6B;AACxC,WAAW,OAAO;AAClB,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,sDAAsD;AAClE;AACA;AACA,aAAa,sDAAsD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;;;;;;;;;AC5YA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,aAAa,kBAAkB;AAC/B,aAAa,QAAQ;AACrB,cAAc,sBAAsB;AACpC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACrSA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLtC;;AAEA,+BAA+B,iFAAiF;;AAEhH;;AAEA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,sCAAsC,aAAa;;AAEnD;AACA;AACA,wCAAwC,aAAa;AACrD;AACA,oDAAoD,4CAA4C;;AAEhG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH,CAAC;;;AAGD;AACA;AACA;;AAEA;;AAEA,oB;;;;;;;AC5TA;;AAEA,+BAA+B,iFAAiF;;AAEhH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,aAAa;;AAE7D;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,iBAAiB;AACjB,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD,GAAG;AACH,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,4CAA4C;AAC1F;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qBAAqB;AACrB,CAAC;;AAED;AACA,4BAA4B;AAC5B,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED,+B;;;;;;ACnhBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,C;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;ACzkBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC","file":"test/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 102);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8c077cb0067b57daaa83","var _ol_ = {};\n\n\n/**\n * Constants defined with the define tag cannot be changed in application\n * code, but can be set at compile time.\n * Some reduce the size of the build in advanced compile mode.\n */\n\n\n/**\n * @define {boolean} Assume touch.  Default is `false`.\n */\n_ol_.ASSUME_TOUCH = false;\n\n\n/**\n * TODO: rename this to something having to do with tile grids\n * see https://github.com/openlayers/openlayers/issues/2076\n * @define {number} Default maximum zoom for default tile grids.\n */\n_ol_.DEFAULT_MAX_ZOOM = 42;\n\n\n/**\n * @define {number} Default min zoom level for the map view.  Default is `0`.\n */\n_ol_.DEFAULT_MIN_ZOOM = 0;\n\n\n/**\n * @define {number} Default maximum allowed threshold  (in pixels) for\n *     reprojection triangulation. Default is `0.5`.\n */\n_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;\n\n\n/**\n * @define {number} Default tile size.\n */\n_ol_.DEFAULT_TILE_SIZE = 256;\n\n\n/**\n * @define {string} Default WMS version.\n */\n_ol_.DEFAULT_WMS_VERSION = '1.3.0';\n\n\n/**\n * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting\n *     this to false at compile time in advanced mode removes all code\n *     supporting the Canvas renderer from the build.\n */\n_ol_.ENABLE_CANVAS = true;\n\n\n/**\n * @define {boolean} Enable integration with the Proj4js library.  Default is\n *     `true`.\n */\n_ol_.ENABLE_PROJ4JS = true;\n\n\n/**\n * @define {boolean} Enable automatic reprojection of raster sources. Default is\n *     `true`.\n */\n_ol_.ENABLE_RASTER_REPROJECTION = true;\n\n\n/**\n * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting\n *     this to false at compile time in advanced mode removes all code\n *     supporting the WebGL renderer from the build.\n */\n_ol_.ENABLE_WEBGL = true;\n\n\n/**\n * @define {boolean} Include debuggable shader sources.  Default is `true`.\n *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`\n *     is `true`).\n */\n_ol_.DEBUG_WEBGL = true;\n\n\n/**\n * @define {number} The size in pixels of the first atlas image. Default is\n * `256`.\n */\n_ol_.INITIAL_ATLAS_SIZE = 256;\n\n\n/**\n * @define {number} The maximum size in pixels of atlas images. Default is\n * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is\n * used instead).\n */\n_ol_.MAX_ATLAS_SIZE = -1;\n\n\n/**\n * @define {number} Maximum mouse wheel delta.\n */\n_ol_.MOUSEWHEELZOOM_MAXDELTA = 1;\n\n\n/**\n * @define {number} Maximum width and/or height extent ratio that determines\n * when the overview map should be zoomed out.\n */\n_ol_.OVERVIEWMAP_MAX_RATIO = 0.75;\n\n\n/**\n * @define {number} Minimum width and/or height extent ratio that determines\n * when the overview map should be zoomed in.\n */\n_ol_.OVERVIEWMAP_MIN_RATIO = 0.1;\n\n\n/**\n * @define {number} Maximum number of source tiles for raster reprojection of\n *     a single tile.\n *     If too many source tiles are determined to be loaded to create a single\n *     reprojected tile the browser can become unresponsive or even crash.\n *     This can happen if the developer defines projections improperly and/or\n *     with unlimited extents.\n *     If too many tiles are required, no tiles are loaded and\n *     `ol.TileState.ERROR` state is set. Default is `100`.\n */\n_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;\n\n\n/**\n * @define {number} Maximum number of subdivision steps during raster\n *     reprojection triangulation. Prevents high memory usage and large\n *     number of proj4 calls (for certain transformations and areas).\n *     At most `2*(2^this)` triangles are created for each triangulated\n *     extent (tile/image). Default is `10`.\n */\n_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;\n\n\n/**\n * @define {number} Maximum allowed size of triangle relative to world width.\n *     When transforming corners of world extent between certain projections,\n *     the resulting triangulation seems to have zero error and no subdivision\n *     is performed.\n *     If the triangle width is more than this (relative to world width; 0-1),\n *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).\n *     Default is `0.25`.\n */\n_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;\n\n\n/**\n * @define {number} Tolerance for geometry simplification in device pixels.\n */\n_ol_.SIMPLIFY_TOLERANCE = 0.5;\n\n\n/**\n * @define {number} Texture cache high water mark.\n */\n_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;\n\n\n/**\n * @define {string} OpenLayers version.\n */\n_ol_.VERSION = '4.1.1';\n\n\n/**\n * The maximum supported WebGL texture size in pixels. If WebGL is not\n * supported, the value is set to `undefined`.\n * @const\n * @type {number|undefined}\n */\n_ol_.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`\n\n\n/**\n * List of supported WebGL extensions.\n * @const\n * @type {Array.<string>}\n */\n_ol_.WEBGL_EXTENSIONS; // value is set in `ol.has`\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n *\n *     function ParentClass(a, b) { }\n *     ParentClass.prototype.foo = function(a) { }\n *\n *     function ChildClass(a, b, c) {\n *       // Call parent constructor\n *       ParentClass.call(this, a, b);\n *     }\n *     ol.inherits(ChildClass, ParentClass);\n *\n *     var child = new ChildClass('a', 'b', 'see');\n *     child.foo(); // This works.\n *\n * @param {!Function} childCtor Child constructor.\n * @param {!Function} parentCtor Parent constructor.\n * @function\n * @api\n */\n_ol_.inherits = function(childCtor, parentCtor) {\n  childCtor.prototype = Object.create(parentCtor.prototype);\n  childCtor.prototype.constructor = childCtor;\n};\n\n\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {undefined} Nothing.\n */\n_ol_.nullFunction = function() {};\n\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {number} The unique ID for the object.\n */\n_ol_.getUid = function(obj) {\n  return obj.ol_uid ||\n      (obj.ol_uid = ++_ol_.uidCounter_);\n};\n\n\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\n_ol_.uidCounter_ = 0;\nexport default _ol_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/index.js\n// module id = 0\n// module chunks = 0","import _ol_asserts_ from './asserts';\nimport _ol_extent_Corner_ from './extent/corner';\nimport _ol_extent_Relationship_ from './extent/relationship';\nvar _ol_extent_ = {};\n\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @return {ol.Extent} Bounding extent.\n * @api\n */\n_ol_extent_.boundingExtent = function(coordinates) {\n  var extent = _ol_extent_.createEmpty();\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    _ol_extent_.extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n};\n\n\n/**\n * @param {Array.<number>} xs Xs.\n * @param {Array.<number>} ys Ys.\n * @param {ol.Extent=} opt_extent Destination extent.\n * @private\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.boundingExtentXYs_ = function(xs, ys, opt_extent) {\n  var minX = Math.min.apply(null, xs);\n  var minY = Math.min.apply(null, ys);\n  var maxX = Math.max.apply(null, xs);\n  var maxY = Math.max.apply(null, ys);\n  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n\n/**\n * Return extent increased by the provided value.\n * @param {ol.Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n * @api\n */\n_ol_extent_.buffer = function(extent, value, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0] - value;\n    opt_extent[1] = extent[1] - value;\n    opt_extent[2] = extent[2] + value;\n    opt_extent[3] = extent[3] + value;\n    return opt_extent;\n  } else {\n    return [\n      extent[0] - value,\n      extent[1] - value,\n      extent[2] + value,\n      extent[3] + value\n    ];\n  }\n};\n\n\n/**\n * Creates a clone of an extent.\n *\n * @param {ol.Extent} extent Extent to clone.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} The clone.\n */\n_ol_extent_.clone = function(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent.slice();\n  }\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\n_ol_extent_.closestSquaredDistanceXY = function(extent, x, y) {\n  var dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n};\n\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {ol.Extent} extent Extent.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\n_ol_extent_.containsCoordinate = function(extent, coordinate) {\n  return _ol_extent_.containsXY(extent, coordinate[0], coordinate[1]);\n};\n\n\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {ol.Extent} extent1 Extent 1.\n * @param {ol.Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\n_ol_extent_.containsExtent = function(extent1, extent2) {\n  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&\n      extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n};\n\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {ol.Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\n_ol_extent_.containsXY = function(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n};\n\n\n/**\n * Get the relationship between a coordinate and extent.\n * @param {ol.Extent} extent The extent.\n * @param {ol.Coordinate} coordinate The coordinate.\n * @return {number} The relationship (bitwise compare with\n *     ol.extent.Relationship).\n */\n_ol_extent_.coordinateRelationship = function(extent, coordinate) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var x = coordinate[0];\n  var y = coordinate[1];\n  var relationship = _ol_extent_Relationship_.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | _ol_extent_Relationship_.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | _ol_extent_Relationship_.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | _ol_extent_Relationship_.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | _ol_extent_Relationship_.ABOVE;\n  }\n  if (relationship === _ol_extent_Relationship_.UNKNOWN) {\n    relationship = _ol_extent_Relationship_.INTERSECTING;\n  }\n  return relationship;\n};\n\n\n/**\n * Create an empty extent.\n * @return {ol.Extent} Empty extent.\n * @api\n */\n_ol_extent_.createEmpty = function() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n};\n\n\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {ol.Extent=} opt_extent Destination extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.createOrUpdate = function(minX, minY, maxX, maxY, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = minX;\n    opt_extent[1] = minY;\n    opt_extent[2] = maxX;\n    opt_extent[3] = maxY;\n    return opt_extent;\n  } else {\n    return [minX, minY, maxX, maxY];\n  }\n};\n\n\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.createOrUpdateEmpty = function(opt_extent) {\n  return _ol_extent_.createOrUpdate(\n      Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n};\n\n\n/**\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.createOrUpdateFromCoordinate = function(coordinate, opt_extent) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  return _ol_extent_.createOrUpdate(x, y, x, y, opt_extent);\n};\n\n\n/**\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.createOrUpdateFromCoordinates = function(coordinates, opt_extent) {\n  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);\n  return _ol_extent_.extendCoordinates(extent, coordinates);\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.createOrUpdateFromFlatCoordinates = function(flatCoordinates, offset, end, stride, opt_extent) {\n  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);\n  return _ol_extent_.extendFlatCoordinates(\n      extent, flatCoordinates, offset, end, stride);\n};\n\n\n/**\n * @param {Array.<Array.<ol.Coordinate>>} rings Rings.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.createOrUpdateFromRings = function(rings, opt_extent) {\n  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);\n  return _ol_extent_.extendRings(extent, rings);\n};\n\n\n/**\n * Determine if two extents are equivalent.\n * @param {ol.Extent} extent1 Extent 1.\n * @param {ol.Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\n_ol_extent_.equals = function(extent1, extent2) {\n  return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&\n      extent1[1] == extent2[1] && extent1[3] == extent2[3];\n};\n\n\n/**\n * Modify an extent to include another extent.\n * @param {ol.Extent} extent1 The extent to be modified.\n * @param {ol.Extent} extent2 The extent that will be included in the first.\n * @return {ol.Extent} A reference to the first (extended) extent.\n * @api\n */\n_ol_extent_.extend = function(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {ol.Coordinate} coordinate Coordinate.\n */\n_ol_extent_.extendCoordinate = function(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.extendCoordinates = function(extent, coordinates) {\n  var i, ii;\n  for (i = 0, ii = coordinates.length; i < ii; ++i) {\n    _ol_extent_.extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.extendFlatCoordinates = function(extent, flatCoordinates, offset, end, stride) {\n  for (; offset < end; offset += stride) {\n    _ol_extent_.extendXY(\n        extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {Array.<Array.<ol.Coordinate>>} rings Rings.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.extendRings = function(extent, rings) {\n  var i, ii;\n  for (i = 0, ii = rings.length; i < ii; ++i) {\n    _ol_extent_.extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\n_ol_extent_.extendXY = function(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n};\n\n\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {ol.Extent} extent Extent.\n * @param {function(this:T, ol.Coordinate): S} callback Callback.\n * @param {T=} opt_this Value to use as `this` when executing `callback`.\n * @return {S|boolean} Value.\n * @template S, T\n */\n_ol_extent_.forEachCorner = function(extent, callback, opt_this) {\n  var val;\n  val = callback.call(opt_this, _ol_extent_.getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback.call(opt_this, _ol_extent_.getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback.call(opt_this, _ol_extent_.getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback.call(opt_this, _ol_extent_.getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @return {number} Area.\n */\n_ol_extent_.getArea = function(extent) {\n  var area = 0;\n  if (!_ol_extent_.isEmpty(extent)) {\n    area = _ol_extent_.getWidth(extent) * _ol_extent_.getHeight(extent);\n  }\n  return area;\n};\n\n\n/**\n * Get the bottom left coordinate of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {ol.Coordinate} Bottom left coordinate.\n * @api\n */\n_ol_extent_.getBottomLeft = function(extent) {\n  return [extent[0], extent[1]];\n};\n\n\n/**\n * Get the bottom right coordinate of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {ol.Coordinate} Bottom right coordinate.\n * @api\n */\n_ol_extent_.getBottomRight = function(extent) {\n  return [extent[2], extent[1]];\n};\n\n\n/**\n * Get the center coordinate of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {ol.Coordinate} Center.\n * @api\n */\n_ol_extent_.getCenter = function(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n};\n\n\n/**\n * Get a corner coordinate of an extent.\n * @param {ol.Extent} extent Extent.\n * @param {ol.extent.Corner} corner Corner.\n * @return {ol.Coordinate} Corner coordinate.\n */\n_ol_extent_.getCorner = function(extent, corner) {\n  var coordinate;\n  if (corner === _ol_extent_Corner_.BOTTOM_LEFT) {\n    coordinate = _ol_extent_.getBottomLeft(extent);\n  } else if (corner === _ol_extent_Corner_.BOTTOM_RIGHT) {\n    coordinate = _ol_extent_.getBottomRight(extent);\n  } else if (corner === _ol_extent_Corner_.TOP_LEFT) {\n    coordinate = _ol_extent_.getTopLeft(extent);\n  } else if (corner === _ol_extent_Corner_.TOP_RIGHT) {\n    coordinate = _ol_extent_.getTopRight(extent);\n  } else {\n    _ol_asserts_.assert(false, 13); // Invalid corner\n  }\n  return /** @type {!ol.Coordinate} */ (coordinate);\n};\n\n\n/**\n * @param {ol.Extent} extent1 Extent 1.\n * @param {ol.Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\n_ol_extent_.getEnlargedArea = function(extent1, extent2) {\n  var minX = Math.min(extent1[0], extent2[0]);\n  var minY = Math.min(extent1[1], extent2[1]);\n  var maxX = Math.max(extent1[2], extent2[2]);\n  var maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n};\n\n\n/**\n * @param {ol.Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {ol.Size} size Size.\n * @param {ol.Extent=} opt_extent Destination extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.getForViewAndSize = function(center, resolution, rotation, size, opt_extent) {\n  var dx = resolution * size[0] / 2;\n  var dy = resolution * size[1] / 2;\n  var cosRotation = Math.cos(rotation);\n  var sinRotation = Math.sin(rotation);\n  var xCos = dx * cosRotation;\n  var xSin = dx * sinRotation;\n  var yCos = dy * cosRotation;\n  var ySin = dy * sinRotation;\n  var x = center[0];\n  var y = center[1];\n  var x0 = x - xCos + ySin;\n  var x1 = x - xCos - ySin;\n  var x2 = x + xCos - ySin;\n  var x3 = x + xCos + ySin;\n  var y0 = y - xSin - yCos;\n  var y1 = y - xSin + yCos;\n  var y2 = y + xSin + yCos;\n  var y3 = y + xSin - yCos;\n  return _ol_extent_.createOrUpdate(\n      Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),\n      Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),\n      opt_extent);\n};\n\n\n/**\n * Get the height of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\n_ol_extent_.getHeight = function(extent) {\n  return extent[3] - extent[1];\n};\n\n\n/**\n * @param {ol.Extent} extent1 Extent 1.\n * @param {ol.Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\n_ol_extent_.getIntersectionArea = function(extent1, extent2) {\n  var intersection = _ol_extent_.getIntersection(extent1, extent2);\n  return _ol_extent_.getArea(intersection);\n};\n\n\n/**\n * Get the intersection of two extents.\n * @param {ol.Extent} extent1 Extent 1.\n * @param {ol.Extent} extent2 Extent 2.\n * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.\n * @return {ol.Extent} Intersecting extent.\n * @api\n */\n_ol_extent_.getIntersection = function(extent1, extent2, opt_extent) {\n  var intersection = opt_extent ? opt_extent : _ol_extent_.createEmpty();\n  if (_ol_extent_.intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  }\n  return intersection;\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @return {number} Margin.\n */\n_ol_extent_.getMargin = function(extent) {\n  return _ol_extent_.getWidth(extent) + _ol_extent_.getHeight(extent);\n};\n\n\n/**\n * Get the size (width, height) of an extent.\n * @param {ol.Extent} extent The extent.\n * @return {ol.Size} The extent size.\n * @api\n */\n_ol_extent_.getSize = function(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n};\n\n\n/**\n * Get the top left coordinate of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {ol.Coordinate} Top left coordinate.\n * @api\n */\n_ol_extent_.getTopLeft = function(extent) {\n  return [extent[0], extent[3]];\n};\n\n\n/**\n * Get the top right coordinate of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {ol.Coordinate} Top right coordinate.\n * @api\n */\n_ol_extent_.getTopRight = function(extent) {\n  return [extent[2], extent[3]];\n};\n\n\n/**\n * Get the width of an extent.\n * @param {ol.Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\n_ol_extent_.getWidth = function(extent) {\n  return extent[2] - extent[0];\n};\n\n\n/**\n * Determine if one extent intersects another.\n * @param {ol.Extent} extent1 Extent 1.\n * @param {ol.Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\n_ol_extent_.intersects = function(extent1, extent2) {\n  return extent1[0] <= extent2[2] &&\n      extent1[2] >= extent2[0] &&\n      extent1[1] <= extent2[3] &&\n      extent1[3] >= extent2[1];\n};\n\n\n/**\n * Determine if an extent is empty.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\n_ol_extent_.isEmpty = function(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} Extent.\n */\n_ol_extent_.returnOrUpdate = function(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent;\n  }\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {number} value Value.\n */\n_ol_extent_.scaleFromCenter = function(extent, value) {\n  var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n  var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n};\n\n\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {ol.Extent} extent The extent.\n * @param {ol.Coordinate} start Segment start coordinate.\n * @param {ol.Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\n_ol_extent_.intersectsSegment = function(extent, start, end) {\n  var intersects = false;\n  var startRel = _ol_extent_.coordinateRelationship(extent, start);\n  var endRel = _ol_extent_.coordinateRelationship(extent, end);\n  if (startRel === _ol_extent_Relationship_.INTERSECTING ||\n      endRel === _ol_extent_Relationship_.INTERSECTING) {\n    intersects = true;\n  } else {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var startX = start[0];\n    var startY = start[1];\n    var endX = end[0];\n    var endY = end[1];\n    var slope = (endY - startY) / (endX - startX);\n    var x, y;\n    if (!!(endRel & _ol_extent_Relationship_.ABOVE) &&\n        !(startRel & _ol_extent_Relationship_.ABOVE)) {\n      // potentially intersects top\n      x = endX - ((endY - maxY) / slope);\n      intersects = x >= minX && x <= maxX;\n    }\n    if (!intersects && !!(endRel & _ol_extent_Relationship_.RIGHT) &&\n        !(startRel & _ol_extent_Relationship_.RIGHT)) {\n      // potentially intersects right\n      y = endY - ((endX - maxX) * slope);\n      intersects = y >= minY && y <= maxY;\n    }\n    if (!intersects && !!(endRel & _ol_extent_Relationship_.BELOW) &&\n        !(startRel & _ol_extent_Relationship_.BELOW)) {\n      // potentially intersects bottom\n      x = endX - ((endY - minY) / slope);\n      intersects = x >= minX && x <= maxX;\n    }\n    if (!intersects && !!(endRel & _ol_extent_Relationship_.LEFT) &&\n        !(startRel & _ol_extent_Relationship_.LEFT)) {\n      // potentially intersects left\n      y = endY - ((endX - minX) * slope);\n      intersects = y >= minY && y <= maxY;\n    }\n\n  }\n  return intersects;\n};\n\n\n/**\n * Apply a transform function to the extent.\n * @param {ol.Extent} extent Extent.\n * @param {ol.TransformFunction} transformFn Transform function.  Called with\n * [minX, minY, maxX, maxY] extent coordinates.\n * @param {ol.Extent=} opt_extent Destination extent.\n * @return {ol.Extent} Extent.\n * @api\n */\n_ol_extent_.applyTransform = function(extent, transformFn, opt_extent) {\n  var coordinates = [\n    extent[0], extent[1],\n    extent[0], extent[3],\n    extent[2], extent[1],\n    extent[2], extent[3]\n  ];\n  transformFn(coordinates, coordinates, 2);\n  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];\n  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];\n  return _ol_extent_.boundingExtentXYs_(xs, ys, opt_extent);\n};\nexport default _ol_extent_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/extent.js\n// module id = 1\n// module chunks = 0","/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nvar _ol_geom_GeometryType_ = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  LINEAR_RING: 'LinearRing',\n  POLYGON: 'Polygon',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon',\n  GEOMETRY_COLLECTION: 'GeometryCollection',\n  CIRCLE: 'Circle'\n};\n\nexport default _ol_geom_GeometryType_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/geometrytype.js\n// module id = 2\n// module chunks = 0","import _ol_asserts_ from './asserts';\nvar _ol_math_ = {};\n\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\n_ol_math_.clamp = function(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n};\n\n\n/**\n * Return the hyperbolic cosine of a given number. The method will use the\n * native `Math.cosh` function if it is available, otherwise the hyperbolic\n * cosine will be calculated via the reference implementation of the Mozilla\n * developer network.\n *\n * @param {number} x X.\n * @return {number} Hyperbolic cosine of x.\n */\n_ol_math_.cosh = (function() {\n  // Wrapped in a iife, to save the overhead of checking for the native\n  // implementation on every invocation.\n  var cosh;\n  if ('cosh' in Math) {\n    // The environment supports the native Math.cosh function, use it\n    cosh = Math.cosh;\n  } else {\n    //  else, use the reference implementation of MDN:\n    cosh = function(x) {\n      var y = Math.exp(x);\n      return (y + 1 / y) / 2;\n    };\n  }\n  return cosh;\n}());\n\n\n/**\n * @param {number} x X.\n * @return {number} The smallest power of two greater than or equal to x.\n */\n_ol_math_.roundUpToPowerOfTwo = function(x) {\n  _ol_asserts_.assert(0 < x, 29); // `x` must be greater than `0`\n  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));\n};\n\n\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\n_ol_math_.squaredSegmentDistance = function(x, y, x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return _ol_math_.squaredDistance(x, y, x1, y1);\n};\n\n\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\n_ol_math_.squaredDistance = function(x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return dx * dx + dy * dy;\n};\n\n\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array.<number>} The resulting vector.\n */\n_ol_math_.solveLinearSystem = function(mat) {\n  var n = mat.length;\n\n  for (var i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    var maxRow = i;\n    var maxEl = Math.abs(mat[i][i]);\n    for (var r = i + 1; r < n; r++) {\n      var absValue = Math.abs(mat[r][i]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    }\n\n    // Swap max row with i-th (current) row\n    var tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp;\n\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n    for (var j = i + 1; j < n; j++) {\n      var coef = -mat[j][i] / mat[i][i];\n      for (var k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  }\n\n  // Solve Ax=b for upper triangular matrix A (mat)\n  var x = new Array(n);\n  for (var l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n    for (var m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n  return x;\n};\n\n\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\n_ol_math_.toDegrees = function(angleInRadians) {\n  return angleInRadians * 180 / Math.PI;\n};\n\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\n_ol_math_.toRadians = function(angleInDegrees) {\n  return angleInDegrees * Math.PI / 180;\n};\n\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\n_ol_math_.modulo = function(a, b) {\n  var r = a % b;\n  return r * b < 0 ? r + b : r;\n};\n\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\n_ol_math_.lerp = function(a, b, x) {\n  return a + x * (b - a);\n};\nexport default _ol_math_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/math.js\n// module id = 3\n// module chunks = 0","/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nvar _ol_geom_GeometryLayout_ = {\n  XY: 'XY',\n  XYZ: 'XYZ',\n  XYM: 'XYM',\n  XYZM: 'XYZM'\n};\n\nexport default _ol_geom_GeometryLayout_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/geometrylayout.js\n// module id = 4\n// module chunks = 0","var _ol_array_ = {};\n\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array.<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function=} opt_comparator Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\n_ol_array_.binarySearch = function(haystack, needle, opt_comparator) {\n  var mid, cmp;\n  var comparator = opt_comparator || _ol_array_.numberSafeCompareFunction;\n  var low = 0;\n  var high = haystack.length;\n  var found = false;\n\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + (high - low >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) { /* Too low. */\n      low  = mid + 1;\n\n    } else { /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n};\n\n\n/**\n * Compare function for array sort that is safe for numbers.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\n_ol_array_.numberSafeCompareFunction = function(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n};\n\n\n/**\n * Whether the array contains the given object.\n * @param {Array.<*>} arr The array to test for the presence of the element.\n * @param {*} obj The object for which to test.\n * @return {boolean} The object is in the array.\n */\n_ol_array_.includes = function(arr, obj) {\n  return arr.indexOf(obj) >= 0;\n};\n\n\n/**\n * @param {Array.<number>} arr Array.\n * @param {number} target Target.\n * @param {number} direction 0 means return the nearest, > 0\n *    means return the largest nearest, < 0 means return the\n *    smallest nearest.\n * @return {number} Index.\n */\n_ol_array_.linearFindNearest = function(arr, target, direction) {\n  var n = arr.length;\n  if (arr[0] <= target) {\n    return 0;\n  } else if (target <= arr[n - 1]) {\n    return n - 1;\n  } else {\n    var i;\n    if (direction > 0) {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] < target) {\n          return i - 1;\n        }\n      }\n    } else if (direction < 0) {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] <= target) {\n          return i;\n        }\n      }\n    } else {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] == target) {\n          return i;\n        } else if (arr[i] < target) {\n          if (arr[i - 1] - target < target - arr[i]) {\n            return i - 1;\n          } else {\n            return i;\n          }\n        }\n      }\n    }\n    return n - 1;\n  }\n};\n\n\n/**\n * @param {Array.<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\n_ol_array_.reverseSubArray = function(arr, begin, end) {\n  while (begin < end) {\n    var tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n};\n\n\n/**\n * @param {Array.<VALUE>} arr The array to modify.\n * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements\n *     to add to arr.\n * @template VALUE\n */\n_ol_array_.extend = function(arr, data) {\n  var i;\n  var extension = Array.isArray(data) ? data : [data];\n  var length = extension.length;\n  for (i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n};\n\n\n/**\n * @param {Array.<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\n_ol_array_.remove = function(arr, obj) {\n  var i = arr.indexOf(obj);\n  var found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n};\n\n\n/**\n * @param {Array.<VALUE>} arr The array to search in.\n * @param {function(VALUE, number, ?) : boolean} func The function to compare.\n * @template VALUE\n * @return {VALUE} The element found.\n */\n_ol_array_.find = function(arr, func) {\n  var length = arr.length >>> 0;\n  var value;\n\n  for (var i = 0; i < length; i++) {\n    value = arr[i];\n    if (func(value, i, arr)) {\n      return value;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\n_ol_array_.equals = function(arr1, arr2) {\n  var len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (var i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * @param {Array.<*>} arr The array to sort (modifies original).\n * @param {Function} compareFnc Comparison function.\n */\n_ol_array_.stableSort = function(arr, compareFnc) {\n  var length = arr.length;\n  var tmp = Array(arr.length);\n  var i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {index: i, value: arr[i]};\n  }\n  tmp.sort(function(a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n};\n\n\n/**\n * @param {Array.<*>} arr The array to search in.\n * @param {Function} func Comparison function.\n * @return {number} Return index.\n */\n_ol_array_.findIndex = function(arr, func) {\n  var index;\n  var found = !arr.every(function(el, idx) {\n    index = idx;\n    return !func(el, idx, arr);\n  });\n  return found ? index : -1;\n};\n\n\n/**\n * @param {Array.<*>} arr The array to test.\n * @param {Function=} opt_func Comparison function.\n * @param {boolean=} opt_strict Strictly sorted (default false).\n * @return {boolean} Return index.\n */\n_ol_array_.isSorted = function(arr, opt_func, opt_strict) {\n  var compare = opt_func || _ol_array_.numberSafeCompareFunction;\n  return arr.every(function(currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    var res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || opt_strict && res === 0);\n  });\n};\nexport default _ol_array_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/array.js\n// module id = 5\n// module chunks = 0","var _ol_geom_flat_deflate_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\n_ol_geom_flat_deflate_.coordinate = function(flatCoordinates, offset, coordinate, stride) {\n  var i, ii;\n  for (i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\n_ol_geom_flat_deflate_.coordinates = function(flatCoordinates, offset, coordinates, stride) {\n  var i, ii;\n  for (i = 0, ii = coordinates.length; i < ii; ++i) {\n    var coordinate = coordinates[i];\n    var j;\n    for (j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array.<number>=} opt_ends Ends.\n * @return {Array.<number>} Ends.\n */\n_ol_geom_flat_deflate_.coordinatess = function(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n  var ends = opt_ends ? opt_ends : [];\n  var i = 0;\n  var j, jj;\n  for (j = 0, jj = coordinatess.length; j < jj; ++j) {\n    var end = _ol_geom_flat_deflate_.coordinates(\n        flatCoordinates, offset, coordinatess[j], stride);\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array.<Array.<number>>=} opt_endss Endss.\n * @return {Array.<Array.<number>>} Endss.\n */\n_ol_geom_flat_deflate_.coordinatesss = function(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n  var endss = opt_endss ? opt_endss : [];\n  var i = 0;\n  var j, jj;\n  for (j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    var ends = _ol_geom_flat_deflate_.coordinatess(\n        flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n};\nexport default _ol_geom_flat_deflate_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/deflate.js\n// module id = 6\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_functions_ from '../functions';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_Geometry_ from '../geom/geometry';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_flat_transform_ from '../geom/flat/transform';\nimport _ol_obj_ from '../obj';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @constructor\n * @abstract\n * @extends {ol.geom.Geometry}\n * @api\n */\nvar _ol_geom_SimpleGeometry_ = function() {\n\n  _ol_geom_Geometry_.call(this);\n\n  /**\n   * @protected\n   * @type {ol.geom.GeometryLayout}\n   */\n  this.layout = _ol_geom_GeometryLayout_.XY;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.stride = 2;\n\n  /**\n   * @protected\n   * @type {Array.<number>}\n   */\n  this.flatCoordinates = null;\n\n};\n\n_ol_.inherits(_ol_geom_SimpleGeometry_, _ol_geom_Geometry_);\n\n\n/**\n * @param {number} stride Stride.\n * @private\n * @return {ol.geom.GeometryLayout} layout Layout.\n */\n_ol_geom_SimpleGeometry_.getLayoutForStride_ = function(stride) {\n  var layout;\n  if (stride == 2) {\n    layout = _ol_geom_GeometryLayout_.XY;\n  } else if (stride == 3) {\n    layout = _ol_geom_GeometryLayout_.XYZ;\n  } else if (stride == 4) {\n    layout = _ol_geom_GeometryLayout_.XYZM;\n  }\n  return /** @type {ol.geom.GeometryLayout} */ (layout);\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\n_ol_geom_SimpleGeometry_.getStrideForLayout = function(layout) {\n  var stride;\n  if (layout == _ol_geom_GeometryLayout_.XY) {\n    stride = 2;\n  } else if (layout == _ol_geom_GeometryLayout_.XYZ || layout == _ol_geom_GeometryLayout_.XYM) {\n    stride = 3;\n  } else if (layout == _ol_geom_GeometryLayout_.XYZM) {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_SimpleGeometry_.prototype.containsXY = _ol_functions_.FALSE;\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_SimpleGeometry_.prototype.computeExtent = function(extent) {\n  return _ol_extent_.createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n};\n\n\n/**\n * @abstract\n * @return {Array} Coordinates.\n */\n_ol_geom_SimpleGeometry_.prototype.getCoordinates = function() {};\n\n\n/**\n * Return the first coordinate of the geometry.\n * @return {ol.Coordinate} First coordinate.\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.getFirstCoordinate = function() {\n  return this.flatCoordinates.slice(0, this.stride);\n};\n\n\n/**\n * @return {Array.<number>} Flat coordinates.\n */\n_ol_geom_SimpleGeometry_.prototype.getFlatCoordinates = function() {\n  return this.flatCoordinates;\n};\n\n\n/**\n * Return the last coordinate of the geometry.\n * @return {ol.Coordinate} Last point.\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.getLastCoordinate = function() {\n  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n};\n\n\n/**\n * Return the {@link ol.geom.GeometryLayout layout} of the geometry.\n * @return {ol.geom.GeometryLayout} Layout.\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.getLayout = function() {\n  return this.layout;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n  if (this.simplifiedGeometryRevision != this.getRevision()) {\n    _ol_obj_.clear(this.simplifiedGeometryCache);\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    this.simplifiedGeometryRevision = this.getRevision();\n  }\n  // If squaredTolerance is negative or if we know that simplification will not\n  // have any effect then just return this.\n  if (squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n       squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\n    return this;\n  }\n  var key = squaredTolerance.toString();\n  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n    return this.simplifiedGeometryCache[key];\n  } else {\n    var simplifiedGeometry =\n        this.getSimplifiedGeometryInternal(squaredTolerance);\n    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      this.simplifiedGeometryCache[key] = simplifiedGeometry;\n      return simplifiedGeometry;\n    } else {\n      // Simplification did not actually remove any coordinates.  We now know\n      // that any calls to getSimplifiedGeometry with a squaredTolerance less\n      // than or equal to the current squaredTolerance will also not have any\n      // effect.  This allows us to short circuit simplification (saving CPU\n      // cycles) and prevents the cache of simplified geometries from filling\n      // up with useless identical copies of this geometry (saving memory).\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  }\n};\n\n\n/**\n * @param {number} squaredTolerance Squared tolerance.\n * @return {ol.geom.SimpleGeometry} Simplified geometry.\n * @protected\n */\n_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  return this;\n};\n\n\n/**\n * @return {number} Stride.\n */\n_ol_geom_SimpleGeometry_.prototype.getStride = function() {\n  return this.stride;\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @protected\n */\n_ol_geom_SimpleGeometry_.prototype.setFlatCoordinatesInternal = function(layout, flatCoordinates) {\n  this.stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);\n  this.layout = layout;\n  this.flatCoordinates = flatCoordinates;\n};\n\n\n/**\n * @abstract\n * @param {Array} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n */\n_ol_geom_SimpleGeometry_.prototype.setCoordinates = function(coordinates, opt_layout) {};\n\n\n/**\n * @param {ol.geom.GeometryLayout|undefined} layout Layout.\n * @param {Array} coordinates Coordinates.\n * @param {number} nesting Nesting.\n * @protected\n */\n_ol_geom_SimpleGeometry_.prototype.setLayout = function(layout, coordinates, nesting) {\n  /** @type {number} */\n  var stride;\n  if (layout) {\n    stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);\n  } else {\n    var i;\n    for (i = 0; i < nesting; ++i) {\n      if (coordinates.length === 0) {\n        this.layout = _ol_geom_GeometryLayout_.XY;\n        this.stride = 2;\n        return;\n      } else {\n        coordinates = /** @type {Array} */ (coordinates[0]);\n      }\n    }\n    stride = coordinates.length;\n    layout = _ol_geom_SimpleGeometry_.getLayoutForStride_(stride);\n  }\n  this.layout = layout;\n  this.stride = stride;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.applyTransform = function(transformFn) {\n  if (this.flatCoordinates) {\n    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n    this.changed();\n  }\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.rotate = function(angle, anchor) {\n  var flatCoordinates = this.getFlatCoordinates();\n  if (flatCoordinates) {\n    var stride = this.getStride();\n    _ol_geom_flat_transform_.rotate(\n        flatCoordinates, 0, flatCoordinates.length,\n        stride, angle, anchor, flatCoordinates);\n    this.changed();\n  }\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.scale = function(sx, opt_sy, opt_anchor) {\n  var sy = opt_sy;\n  if (sy === undefined) {\n    sy = sx;\n  }\n  var anchor = opt_anchor;\n  if (!anchor) {\n    anchor = _ol_extent_.getCenter(this.getExtent());\n  }\n  var flatCoordinates = this.getFlatCoordinates();\n  if (flatCoordinates) {\n    var stride = this.getStride();\n    _ol_geom_flat_transform_.scale(\n        flatCoordinates, 0, flatCoordinates.length,\n        stride, sx, sy, anchor, flatCoordinates);\n    this.changed();\n  }\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_SimpleGeometry_.prototype.translate = function(deltaX, deltaY) {\n  var flatCoordinates = this.getFlatCoordinates();\n  if (flatCoordinates) {\n    var stride = this.getStride();\n    _ol_geom_flat_transform_.translate(\n        flatCoordinates, 0, flatCoordinates.length, stride,\n        deltaX, deltaY, flatCoordinates);\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.\n * @param {ol.Transform} transform Transform.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Transformed flat coordinates.\n */\n_ol_geom_SimpleGeometry_.transform2D = function(simpleGeometry, transform, opt_dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  } else {\n    var stride = simpleGeometry.getStride();\n    return _ol_geom_flat_transform_.transform2D(\n        flatCoordinates, 0, flatCoordinates.length, stride,\n        transform, opt_dest);\n  }\n};\nexport default _ol_geom_SimpleGeometry_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/simplegeometry.js\n// module id = 7\n// module chunks = 0","var _ol_obj_ = {};\n\n\n/**\n * Polyfill for Object.assign().  Assigns enumerable and own properties from\n * one or more source objects to a target object.\n *\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n * @param {!Object} target The target object.\n * @param {...Object} var_sources The source object(s).\n * @return {!Object} The modified target object.\n */\n_ol_obj_.assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  var output = Object(target);\n  for (var i = 1, ii = arguments.length; i < ii; ++i) {\n    var source = arguments[i];\n    if (source !== undefined && source !== null) {\n      for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n          output[key] = source[key];\n        }\n      }\n    }\n  }\n  return output;\n};\n\n\n/**\n * Removes all properties from an object.\n * @param {Object} object The object to clear.\n */\n_ol_obj_.clear = function(object) {\n  for (var property in object) {\n    delete object[property];\n  }\n};\n\n\n/**\n * Get an array of property values from an object.\n * @param {Object<K,V>} object The object from which to get the values.\n * @return {!Array<V>} The property values.\n * @template K,V\n */\n_ol_obj_.getValues = function(object) {\n  var values = [];\n  for (var property in object) {\n    values.push(object[property]);\n  }\n  return values;\n};\n\n\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\n_ol_obj_.isEmpty = function(object) {\n  var property;\n  for (property in object) {\n    return false;\n  }\n  return !property;\n};\nexport default _ol_obj_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/obj.js\n// module id = 8\n// module chunks = 0","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} properties properties\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties) {\n    if (!geometry) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object=} properties an Object that is used as the {@link Feature}'s\n * properties\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (typeof coordinates[0] !== 'number' || typeof coordinates[1] !== 'number') throw new Error('Coordinates must numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object=} properties a properties object\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nfunction lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nfunction featureCollection(features) {\n    if (!features) throw new Error('No features passed');\n\n    return {\n        type: 'FeatureCollection',\n        features: features\n    };\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties) {\n    if (!geometries) throw new Error('geometries is required');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * round(120.4321)\n * //=120\n *\n * round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error('units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error('units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nfunction convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n\nmodule.exports = {\n    feature: feature,\n    featureCollection: featureCollection,\n    geometryCollection: geometryCollection,\n    point: point,\n    multiPoint: multiPoint,\n    lineString: lineString,\n    multiLineString: multiLineString,\n    polygon: polygon,\n    multiPolygon: multiPolygon,\n    radiansToDistance: radiansToDistance,\n    distanceToRadians: distanceToRadians,\n    distanceToDegrees: distanceToDegrees,\n    radians2degrees: radians2degrees,\n    degrees2radians: degrees2radians,\n    bearingToAngle: bearingToAngle,\n    convertDistance: convertDistance,\n    round: round\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/helpers/index.js\n// module id = 9\n// module chunks = 0","import _ol_AssertionError_ from './assertionerror';\nvar _ol_asserts_ = {};\n\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {number} errorCode Error code.\n */\n_ol_asserts_.assert = function(assertion, errorCode) {\n  if (!assertion) {\n    throw new _ol_AssertionError_(errorCode);\n  }\n};\nexport default _ol_asserts_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/asserts.js\n// module id = 10\n// module chunks = 0","var _ol_geom_flat_inflate_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.\n * @return {Array.<ol.Coordinate>} Coordinates.\n */\n_ol_geom_flat_inflate_.coordinates = function(flatCoordinates, offset, end, stride, opt_coordinates) {\n  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n  var i = 0;\n  var j;\n  for (j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.\n * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.\n */\n_ol_geom_flat_inflate_.coordinatess = function(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n  var i = 0;\n  var j, jj;\n  for (j = 0, jj = ends.length; j < jj; ++j) {\n    var end = ends[j];\n    coordinatess[i++] = _ol_geom_flat_inflate_.coordinates(\n        flatCoordinates, offset, end, stride, coordinatess[i]);\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss\n *     Coordinatesss.\n * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.\n */\n_ol_geom_flat_inflate_.coordinatesss = function(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n  var i = 0;\n  var j, jj;\n  for (j = 0, jj = endss.length; j < jj; ++j) {\n    var ends = endss[j];\n    coordinatesss[i++] = _ol_geom_flat_inflate_.coordinatess(\n        flatCoordinates, offset, ends, stride, coordinatesss[i]);\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n};\nexport default _ol_geom_flat_inflate_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/inflate.js\n// module id = 11\n// module chunks = 0","import _ol_math_ from '../../math';\nvar _ol_geom_flat_closest_ = {};\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\n_ol_geom_flat_closest_.point = function(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var i, offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = _ol_math_.lerp(flatCoordinates[offset1 + i],\n            flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n};\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getMaxSquaredDelta = function(flatCoordinates, offset, end, stride, maxSquaredDelta) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = _ol_math_.squaredDistance(x1, y1, x2, y2);\n    if (squaredDelta > maxSquaredDelta) {\n      maxSquaredDelta = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getsMaxSquaredDelta = function(flatCoordinates, offset, ends, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(\n        flatCoordinates, offset, end, stride, maxSquaredDelta);\n    offset = end;\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getssMaxSquaredDelta = function(flatCoordinates, offset, endss, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(\n        flatCoordinates, offset, ends, stride, maxSquaredDelta);\n    offset = ends[ends.length - 1];\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getClosestPoint = function(flatCoordinates, offset, end,\n    stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = _ol_math_.squaredDistance(\n        x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    _ol_geom_flat_closest_.point(\n        flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n          ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    _ol_geom_flat_closest_.point(\n        flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getsClosestPoint = function(flatCoordinates, offset, ends,\n    stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(\n        flatCoordinates, offset, end, stride,\n        maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getssClosestPoint = function(flatCoordinates, offset,\n    endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(\n        flatCoordinates, offset, ends, stride,\n        maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n};\nexport default _ol_geom_flat_closest_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/closest.js\n// module id = 12\n// module chunks = 0","// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport _ol_math_ from '../../math';\nvar _ol_geom_flat_simplify_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array.<number>} Simplified line string.\n */\n_ol_geom_flat_simplify_.lineString = function(flatCoordinates, offset, end,\n    stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\n      opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end,\n        stride, squaredTolerance,\n        simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(\n      flatCoordinates, offset, end, stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.douglasPeucker = function(flatCoordinates, offset, end,\n    stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array.<number>} */\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array.<number>} */\n  var stack = [offset, end - stride];\n  var index = 0;\n  var i;\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n    for (i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance = _ol_math_.squaredSegmentDistance(\n          x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.douglasPeuckers = function(flatCoordinates, offset,\n    ends, stride, squaredTolerance, simplifiedFlatCoordinates,\n    simplifiedOffset, simplifiedEnds) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(\n        flatCoordinates, offset, end, stride, squaredTolerance,\n        simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.douglasPeuckerss = function(\n    flatCoordinates, offset, endss, stride, squaredTolerance,\n    simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(\n        flatCoordinates, offset, ends, stride, squaredTolerance,\n        simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.radialDistance = function(flatCoordinates, offset, end,\n    stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (_ol_math_.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n_ol_geom_flat_simplify_.snap = function(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n};\n\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.quantize = function(flatCoordinates, offset, end, stride,\n    tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  var x2, y2;\n  do {\n    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    var x3, y3;\n    // snap the next coordinate (P3)\n    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if ((dx1 * dy2 == dy1 * dx2) &&\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.quantizes = function(\n    flatCoordinates, offset, ends, stride,\n    tolerance,\n    simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = _ol_geom_flat_simplify_.quantize(\n        flatCoordinates, offset, end, stride,\n        tolerance,\n        simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.quantizess = function(\n    flatCoordinates, offset, endss, stride,\n    tolerance,\n    simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(\n        flatCoordinates, offset, ends, stride,\n        tolerance,\n        simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n};\nexport default _ol_geom_flat_simplify_;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/simplify.js\n// module id = 13\n// module chunks = 0","/**\n * Callback for coordEach\n *\n * @private\n * @callback coordEachCallback\n * @param {Array<number>} currentCoords The current coordinates being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Geometry|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoords, currentIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.coordEach(features, function (currentCoords, currentIndex) {\n *   //=currentCoords\n *   //=currentIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    var i, j, k, g, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        currentIndex = 0,\n        isGeometryCollection,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n        (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n            coords = geometry.coordinates;\n\n            wrapShrink = (excludeWrapCoord &&\n                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?\n                1 : 0;\n\n            if (geometry.type === 'Point') {\n                callback(coords, currentIndex);\n                currentIndex++;\n            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], currentIndex);\n                    currentIndex++;\n                }\n            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], currentIndex);\n                        currentIndex++;\n                    }\n            } else if (geometry.type === 'MultiPolygon') {\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], currentIndex);\n                            currentIndex++;\n                        }\n            } else if (geometry.type === 'GeometryCollection') {\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n            } else {\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {[number, number]} currentCoords The current coordinate being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {\n *   //=previousValue\n *   //=currentCoords\n *   //=currentIndex\n *   return currentCoords;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoords, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentCoords;\n        } else {\n            previousValue = callback(previousValue, currentCoords, currentIndex);\n        }\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @private\n * @callback propEachCallback\n * @param {*} currentProperties The current properties being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, currentIndex)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.propEach(features, function (currentProperties, currentIndex) {\n *   //=currentProperties\n *   //=currentIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=currentIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentProperties;\n        } else {\n            previousValue = callback(previousValue, currentProperties, currentIndex);\n        }\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @private\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, currentIndex)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.featureEach(features, function (currentFeature, currentIndex) {\n *   //=currentFeature\n *   //=currentIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=currentIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentFeature;\n        } else {\n            previousValue = callback(previousValue, currentFeature, currentIndex);\n        }\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * var coords = turf.coordAll(features);\n * //=coords\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, currentIndex, currentProperties)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.geomEach(features, function (currentGeometry, currentIndex, currentProperties) {\n *   //=currentGeometry\n *   //=currentIndex\n *   //=currentProperties\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        currentIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n        (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n                              (isFeature ? geojson.properties : {}));\n        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            if (geometry.type === 'Point' ||\n                geometry.type === 'LineString' ||\n                geometry.type === 'MultiPoint' ||\n                geometry.type === 'Polygon' ||\n                geometry.type === 'MultiLineString' ||\n                geometry.type === 'MultiPolygon') {\n                callback(geometry, currentIndex, geometryProperties);\n                currentIndex++;\n            } else if (geometry.type === 'GeometryCollection') {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], currentIndex, geometryProperties);\n                    currentIndex++;\n                }\n            } else {\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=currentIndex\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentGeometry;\n        } else {\n            previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n        }\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @private\n * @callback flattenEachCallback\n * @param {Feature<any>} currentFeature The current flattened feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, currentIndex, currentSubIndex)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"MultiPoint\",\n *         \"coordinates\": [ [36, 53], [46, 69] ]\n *       }\n *     }\n *   ]\n * };\n * turf.flattenEach(features, function (currentFeature, currentIndex, currentSubIndex) {\n *   //=currentFeature\n *   //=currentIndex\n *   //=currentSubIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, index, properties) {\n\n        // Callback for single geometry\n        switch (geometry.type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), index, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (geometry.type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, subindex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), index, subindex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {Geometry|FeatureCollection|Feature<any>} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex, currentSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"MultiPoint\",\n *         \"coordinates\": [ [36, 53], [46, 69] ]\n *       }\n *     }\n *   ]\n * };\n * turf.flattenReduce(features, function (previousValue, currentFeature, currentIndex, currentSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=currentIndex\n *   //=currentSubIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, currentIndex, currentSubIndex) {\n        if (currentIndex === 0 && currentSubIndex === 0 && initialValue === undefined) {\n            previousValue = currentFeature;\n        } else {\n            previousValue = callback(previousValue, currentFeature, currentIndex, currentSubIndex);\n        }\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nfunction feature(geometry, properties) {\n    if (!geometry) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\nmodule.exports = {\n    coordEach: coordEach,\n    coordReduce: coordReduce,\n    propEach: propEach,\n    propReduce: propReduce,\n    featureEach: featureEach,\n    featureReduce: featureReduce,\n    coordAll: coordAll,\n    geomEach: geomEach,\n    geomReduce: geomReduce,\n    flattenEach: flattenEach,\n    flattenReduce: flattenReduce\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/meta/index.js\n// module id = 14\n// module chunks = 0","import _ol_obj_ from './obj';\nvar _ol_events_ = {};\n\n\n/**\n * @param {ol.EventsKey} listenerObj Listener object.\n * @return {ol.EventsListenerFunctionType} Bound listener.\n */\n_ol_events_.bindListener_ = function(listenerObj) {\n  var boundListener = function(evt) {\n    var listener = listenerObj.listener;\n    var bindTo = listenerObj.bindTo || listenerObj.target;\n    if (listenerObj.callOnce) {\n      _ol_events_.unlistenByKey(listenerObj);\n    }\n    return listener.call(bindTo, evt);\n  };\n  listenerObj.boundListener = boundListener;\n  return boundListener;\n};\n\n\n/**\n * Finds the matching {@link ol.EventsKey} in the given listener\n * array.\n *\n * @param {!Array<!ol.EventsKey>} listeners Array of listeners.\n * @param {!Function} listener The listener function.\n * @param {Object=} opt_this The `this` value inside the listener.\n * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching\n *     listener, for {@link ol.events.unlistenByKey}.\n * @return {ol.EventsKey|undefined} The matching listener object.\n * @private\n */\n_ol_events_.findListener_ = function(listeners, listener, opt_this,\n    opt_setDeleteIndex) {\n  var listenerObj;\n  for (var i = 0, ii = listeners.length; i < ii; ++i) {\n    listenerObj = listeners[i];\n    if (listenerObj.listener === listener &&\n        listenerObj.bindTo === opt_this) {\n      if (opt_setDeleteIndex) {\n        listenerObj.deleteIndex = i;\n      }\n      return listenerObj;\n    }\n  }\n  return undefined;\n};\n\n\n/**\n * @param {ol.EventTargetLike} target Target.\n * @param {string} type Type.\n * @return {Array.<ol.EventsKey>|undefined} Listeners.\n */\n_ol_events_.getListeners = function(target, type) {\n  var listenerMap = target.ol_lm;\n  return listenerMap ? listenerMap[type] : undefined;\n};\n\n\n/**\n * Get the lookup of listeners.  If one does not exist on the target, it is\n * created.\n * @param {ol.EventTargetLike} target Target.\n * @return {!Object.<string, Array.<ol.EventsKey>>} Map of\n *     listeners by event type.\n * @private\n */\n_ol_events_.getListenerMap_ = function(target) {\n  var listenerMap = target.ol_lm;\n  if (!listenerMap) {\n    listenerMap = target.ol_lm = {};\n  }\n  return listenerMap;\n};\n\n\n/**\n * Clean up all listener objects of the given type.  All properties on the\n * listener objects will be removed, and if no listeners remain in the listener\n * map, it will be removed from the target.\n * @param {ol.EventTargetLike} target Target.\n * @param {string} type Type.\n * @private\n */\n_ol_events_.removeListeners_ = function(target, type) {\n  var listeners = _ol_events_.getListeners(target, type);\n  if (listeners) {\n    for (var i = 0, ii = listeners.length; i < ii; ++i) {\n      target.removeEventListener(type, listeners[i].boundListener);\n      _ol_obj_.clear(listeners[i]);\n    }\n    listeners.length = 0;\n    var listenerMap = target.ol_lm;\n    if (listenerMap) {\n      delete listenerMap[type];\n      if (Object.keys(listenerMap).length === 0) {\n        delete target.ol_lm;\n      }\n    }\n  }\n};\n\n\n/**\n * Registers an event listener on an event target. Inspired by\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n *\n * This function efficiently binds a `listener` to a `this` object, and returns\n * a key for use with {@link ol.events.unlistenByKey}.\n *\n * @param {ol.EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ol.EventsListenerFunctionType} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @param {boolean=} opt_once If true, add the listener as one-off listener.\n * @return {ol.EventsKey} Unique key for the listener.\n */\n_ol_events_.listen = function(target, type, listener, opt_this, opt_once) {\n  var listenerMap = _ol_events_.getListenerMap_(target);\n  var listeners = listenerMap[type];\n  if (!listeners) {\n    listeners = listenerMap[type] = [];\n  }\n  var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this,\n      false);\n  if (listenerObj) {\n    if (!opt_once) {\n      // Turn one-off listener into a permanent one.\n      listenerObj.callOnce = false;\n    }\n  } else {\n    listenerObj = /** @type {ol.EventsKey} */ ({\n      bindTo: opt_this,\n      callOnce: !!opt_once,\n      listener: listener,\n      target: target,\n      type: type\n    });\n    target.addEventListener(type, _ol_events_.bindListener_(listenerObj));\n    listeners.push(listenerObj);\n  }\n\n  return listenerObj;\n};\n\n\n/**\n * Registers a one-off event listener on an event target. Inspired by\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n *\n * This function efficiently binds a `listener` as self-unregistering listener\n * to a `this` object, and returns a key for use with\n * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered\n * before it is called.\n *\n * When {@link ol.events.listen} is called with the same arguments after this\n * function, the self-unregistering listener will be turned into a permanent\n * listener.\n *\n * @param {ol.EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ol.EventsListenerFunctionType} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @return {ol.EventsKey} Key for unlistenByKey.\n */\n_ol_events_.listenOnce = function(target, type, listener, opt_this) {\n  return _ol_events_.listen(target, type, listener, opt_this, true);\n};\n\n\n/**\n * Unregisters an event listener on an event target. Inspired by\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n *\n * To return a listener, this function needs to be called with the exact same\n * arguments that were used for a previous {@link ol.events.listen} call.\n *\n * @param {ol.EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ol.EventsListenerFunctionType} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n */\n_ol_events_.unlisten = function(target, type, listener, opt_this) {\n  var listeners = _ol_events_.getListeners(target, type);\n  if (listeners) {\n    var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this,\n        true);\n    if (listenerObj) {\n      _ol_events_.unlistenByKey(listenerObj);\n    }\n  }\n};\n\n\n/**\n * Unregisters event listeners on an event target. Inspired by\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n *\n * The argument passed to this function is the key returned from\n * {@link ol.events.listen} or {@link ol.events.listenOnce}.\n *\n * @param {ol.EventsKey} key The key.\n */\n_ol_events_.unlistenByKey = function(key) {\n  if (key && key.target) {\n    key.target.removeEventListener(key.type, key.boundListener);\n    var listeners = _ol_events_.getListeners(key.target, key.type);\n    if (listeners) {\n      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);\n      if (i !== -1) {\n        listeners.splice(i, 1);\n      }\n      if (listeners.length === 0) {\n        _ol_events_.removeListeners_(key.target, key.type);\n      }\n    }\n    _ol_obj_.clear(key);\n  }\n};\n\n\n/**\n * Unregisters all event listeners on an event target. Inspired by\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n *\n * @param {ol.EventTargetLike} target Target.\n */\n_ol_events_.unlistenAll = function(target) {\n  var listenerMap = _ol_events_.getListenerMap_(target);\n  for (var type in listenerMap) {\n    _ol_events_.removeListeners_(target, type);\n  }\n};\nexport default _ol_events_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/events.js\n// module id = 15\n// module chunks = 0","import _ol_extent_ from '../../extent';\nvar _ol_geom_flat_contains_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\n_ol_geom_flat_contains_.linearRingContainsExtent = function(flatCoordinates, offset, end, stride, extent) {\n  var outside = _ol_extent_.forEachCorner(extent,\n      /**\n       * @param {ol.Coordinate} coordinate Coordinate.\n       * @return {boolean} Contains (x, y).\n       */\n      function(coordinate) {\n        return !_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,\n            offset, end, stride, coordinate[0], coordinate[1]);\n      });\n  return !outside;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n_ol_geom_flat_contains_.linearRingContainsXY = function(flatCoordinates, offset, end, stride, x, y) {\n  // http://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  var wn = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n_ol_geom_flat_contains_.linearRingsContainsXY = function(flatCoordinates, offset, ends, stride, x, y) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!_ol_geom_flat_contains_.linearRingContainsXY(\n      flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  var i, ii;\n  for (i = 1, ii = ends.length; i < ii; ++i) {\n    if (_ol_geom_flat_contains_.linearRingContainsXY(\n        flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n_ol_geom_flat_contains_.linearRingssContainsXY = function(flatCoordinates, offset, endss, stride, x, y) {\n  if (endss.length === 0) {\n    return false;\n  }\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    if (_ol_geom_flat_contains_.linearRingsContainsXY(\n        flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n};\nexport default _ol_geom_flat_contains_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/contains.js\n// module id = 16\n// module chunks = 0","import _ol_extent_ from '../../extent';\nimport _ol_geom_flat_contains_ from '../flat/contains';\nimport _ol_geom_flat_segments_ from '../flat/segments';\nvar _ol_geom_flat_intersectsextent_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n_ol_geom_flat_intersectsextent_.lineString = function(flatCoordinates, offset, end, stride, extent) {\n  var coordinatesExtent = _ol_extent_.extendFlatCoordinates(\n      _ol_extent_.createEmpty(), flatCoordinates, offset, end, stride);\n  if (!_ol_extent_.intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (_ol_extent_.containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] &&\n      coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] &&\n      coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return _ol_geom_flat_segments_.forEach(flatCoordinates, offset, end, stride,\n      /**\n       * @param {ol.Coordinate} point1 Start point.\n       * @param {ol.Coordinate} point2 End point.\n       * @return {boolean} `true` if the segment and the extent intersect,\n       *     `false` otherwise.\n       */\n      function(point1, point2) {\n        return _ol_extent_.intersectsSegment(extent, point1, point2);\n      });\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n_ol_geom_flat_intersectsextent_.lineStrings = function(flatCoordinates, offset, ends, stride, extent) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    if (_ol_geom_flat_intersectsextent_.lineString(\n        flatCoordinates, offset, ends[i], stride, extent)) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n_ol_geom_flat_intersectsextent_.linearRing = function(flatCoordinates, offset, end, stride, extent) {\n  if (_ol_geom_flat_intersectsextent_.lineString(\n      flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (_ol_geom_flat_contains_.linearRingContainsXY(\n      flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n    return true;\n  }\n  if (_ol_geom_flat_contains_.linearRingContainsXY(\n      flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n    return true;\n  }\n  if (_ol_geom_flat_contains_.linearRingContainsXY(\n      flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n    return true;\n  }\n  if (_ol_geom_flat_contains_.linearRingContainsXY(\n      flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n_ol_geom_flat_intersectsextent_.linearRings = function(flatCoordinates, offset, ends, stride, extent) {\n  if (!_ol_geom_flat_intersectsextent_.linearRing(\n      flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  var i, ii;\n  for (i = 1, ii = ends.length; i < ii; ++i) {\n    if (_ol_geom_flat_contains_.linearRingContainsExtent(\n        flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {ol.Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n_ol_geom_flat_intersectsextent_.linearRingss = function(flatCoordinates, offset, endss, stride, extent) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    if (_ol_geom_flat_intersectsextent_.linearRings(\n        flatCoordinates, offset, ends, stride, extent)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n};\nexport default _ol_geom_flat_intersectsextent_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/intersectsextent.js\n// module id = 17\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_Object_ from '../object';\nimport _ol_extent_ from '../extent';\nimport _ol_functions_ from '../functions';\nimport _ol_proj_ from '../proj';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @constructor\n * @abstract\n * @extends {ol.Object}\n * @api\n */\nvar _ol_geom_Geometry_ = function() {\n\n  _ol_Object_.call(this);\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n  this.extent_ = _ol_extent_.createEmpty();\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.extentRevision_ = -1;\n\n  /**\n   * @protected\n   * @type {Object.<string, ol.geom.Geometry>}\n   */\n  this.simplifiedGeometryCache = {};\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.simplifiedGeometryRevision = 0;\n\n};\n\n_ol_.inherits(_ol_geom_Geometry_, _ol_Object_);\n\n\n/**\n * Make a complete copy of the geometry.\n * @abstract\n * @return {!ol.geom.Geometry} Clone.\n */\n_ol_geom_Geometry_.prototype.clone = function() {};\n\n\n/**\n * @abstract\n * @param {number} x X.\n * @param {number} y Y.\n * @param {ol.Coordinate} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_Geometry_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {};\n\n\n/**\n * Return the closest point of the geometry to the passed point as\n * {@link ol.Coordinate coordinate}.\n * @param {ol.Coordinate} point Point.\n * @param {ol.Coordinate=} opt_closestPoint Closest point.\n * @return {ol.Coordinate} Closest point.\n * @api\n */\n_ol_geom_Geometry_.prototype.getClosestPoint = function(point, opt_closestPoint) {\n  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n  this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n  return closestPoint;\n};\n\n\n/**\n * Returns true if this geometry includes the specified coordinate. If the\n * coordinate is on the boundary of the geometry, returns false.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @return {boolean} Contains coordinate.\n * @api\n */\n_ol_geom_Geometry_.prototype.intersectsCoordinate = function(coordinate) {\n  return this.containsXY(coordinate[0], coordinate[1]);\n};\n\n\n/**\n * @abstract\n * @param {ol.Extent} extent Extent.\n * @protected\n * @return {ol.Extent} extent Extent.\n */\n_ol_geom_Geometry_.prototype.computeExtent = function(extent) {};\n\n\n/**\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n_ol_geom_Geometry_.prototype.containsXY = _ol_functions_.FALSE;\n\n\n/**\n * Get the extent of the geometry.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} extent Extent.\n * @api\n */\n_ol_geom_Geometry_.prototype.getExtent = function(opt_extent) {\n  if (this.extentRevision_ != this.getRevision()) {\n    this.extent_ = this.computeExtent(this.extent_);\n    this.extentRevision_ = this.getRevision();\n  }\n  return _ol_extent_.returnOrUpdate(this.extent_, opt_extent);\n};\n\n\n/**\n * Rotate the geometry around a given coordinate. This modifies the geometry\n * coordinates in place.\n * @abstract\n * @param {number} angle Rotation angle in radians.\n * @param {ol.Coordinate} anchor The rotation center.\n * @api\n */\n_ol_geom_Geometry_.prototype.rotate = function(angle, anchor) {};\n\n\n/**\n * Scale the geometry (with an optional origin).  This modifies the geometry\n * coordinates in place.\n * @abstract\n * @param {number} sx The scaling factor in the x-direction.\n * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n *     sx).\n * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center\n *     of the geometry extent).\n * @api\n */\n_ol_geom_Geometry_.prototype.scale = function(sx, opt_sy, opt_anchor) {};\n\n\n/**\n * Create a simplified version of this geometry.  For linestrings, this uses\n * the the {@link\n * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n * Douglas Peucker} algorithm.  For polygons, a quantization-based\n * simplification is used to preserve topology.\n * @function\n * @param {number} tolerance The tolerance distance for simplification.\n * @return {ol.geom.Geometry} A new, simplified version of the original\n *     geometry.\n * @api\n */\n_ol_geom_Geometry_.prototype.simplify = function(tolerance) {\n  return this.getSimplifiedGeometry(tolerance * tolerance);\n};\n\n\n/**\n * Create a simplified version of this geometry using the Douglas Peucker\n * algorithm.\n * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n * @abstract\n * @param {number} squaredTolerance Squared tolerance.\n * @return {ol.geom.Geometry} Simplified geometry.\n */\n_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function(squaredTolerance) {};\n\n\n/**\n * Get the type of this geometry.\n * @abstract\n * @return {ol.geom.GeometryType} Geometry type.\n */\n_ol_geom_Geometry_.prototype.getType = function() {};\n\n\n/**\n * Apply a transform function to each coordinate of the geometry.\n * The geometry is modified in place.\n * If you do not want the geometry modified in place, first `clone()` it and\n * then use this function on the clone.\n * @abstract\n * @param {ol.TransformFunction} transformFn Transform.\n */\n_ol_geom_Geometry_.prototype.applyTransform = function(transformFn) {};\n\n\n/**\n * Test if the geometry and the passed extent intersect.\n * @abstract\n * @param {ol.Extent} extent Extent.\n * @return {boolean} `true` if the geometry and the extent intersect.\n */\n_ol_geom_Geometry_.prototype.intersectsExtent = function(extent) {};\n\n\n/**\n * Translate the geometry.  This modifies the geometry coordinates in place.  If\n * instead you want a new geometry, first `clone()` this geometry.\n * @abstract\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n */\n_ol_geom_Geometry_.prototype.translate = function(deltaX, deltaY) {};\n\n\n/**\n * Transform each coordinate of the geometry from one coordinate reference\n * system to another. The geometry is modified in place.\n * For example, a line will be transformed to a line and a circle to a circle.\n * If you do not want the geometry modified in place, first `clone()` it and\n * then use this function on the clone.\n *\n * @param {ol.ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @param {ol.ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @return {ol.geom.Geometry} This geometry.  Note that original geometry is\n *     modified in place.\n * @api\n */\n_ol_geom_Geometry_.prototype.transform = function(source, destination) {\n  this.applyTransform(_ol_proj_.getTransform(source, destination));\n  return this;\n};\nexport default _ol_geom_Geometry_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/geometry.js\n// module id = 18\n// module chunks = 0","import _ol_sphere_NORMAL_ from '../sphere/normal';\n\n/**\n * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\n * `'us-ft'`.\n * @enum {string}\n */\nvar _ol_proj_Units_ = {\n  DEGREES: 'degrees',\n  FEET: 'ft',\n  METERS: 'm',\n  PIXELS: 'pixels',\n  TILE_PIXELS: 'tile-pixels',\n  USFEET: 'us-ft'\n};\n\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object.<ol.proj.Units, number>}\n * @api\n */\n_ol_proj_Units_.METERS_PER_UNIT = {};\n_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES] =\n    2 * Math.PI * _ol_sphere_NORMAL_.radius / 360;\n_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.FEET] = 0.3048;\n_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.METERS] = 1;\n_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.USFEET] = 1200 / 3937;\nexport default _ol_proj_Units_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/units.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nvar types = {\n  NUMBER: 'number',\n  UNDEFINED: 'undefined',\n  STRING: 'string',\n  BOOLEAN: 'boolean',\n  OBJECT: 'object',\n  FUNCTION: 'function',\n  NULL: 'null',\n  ARRAY: 'array',\n  REGEXP: 'regexp',\n  DATE: 'date',\n  ERROR: 'error',\n  ARGUMENTS: 'arguments',\n  SYMBOL: 'symbol',\n  ARRAY_BUFFER: 'array-buffer',\n  TYPED_ARRAY: 'typed-array',\n  DATA_VIEW: 'data-view',\n  MAP: 'map',\n  SET: 'set',\n  WEAK_SET: 'weak-set',\n  WEAK_MAP: 'weak-map',\n  PROMISE: 'promise',\n\n// node buffer\n  BUFFER: 'buffer',\n\n// dom html element\n  HTML_ELEMENT: 'html-element',\n  HTML_ELEMENT_TEXT: 'html-element-text',\n  DOCUMENT: 'document',\n  WINDOW: 'window',\n  FILE: 'file',\n  FILE_LIST: 'file-list',\n  BLOB: 'blob',\n\n  HOST: 'host',\n\n  XHR: 'xhr',\n\n  // simd\n  SIMD: 'simd'\n};\n\n/*\n * Simple data function to store type information\n * @param {string} type Usually what is returned from typeof\n * @param {string} cls  Sanitized @Class via Object.prototype.toString\n * @param {string} sub  If type and cls the same, and need to specify somehow\n * @private\n * @example\n *\n * //for null\n * new Type('null');\n *\n * //for Date\n * new Type('object', 'date');\n *\n * //for Uint8Array\n *\n * new Type('object', 'typed-array', 'uint8');\n */\nfunction Type(type, cls, sub) {\n  if (!type) {\n    throw new Error('Type class must be initialized at least with `type` information');\n  }\n  this.type = type;\n  this.cls = cls;\n  this.sub = sub;\n}\n\nType.prototype = {\n  toString: function(sep) {\n    sep = sep || ';';\n    var str = [this.type];\n    if (this.cls) {\n      str.push(this.cls);\n    }\n    if (this.sub) {\n      str.push(this.sub);\n    }\n    return str.join(sep);\n  },\n\n  toTryTypes: function() {\n    var _types = [];\n    if (this.sub) {\n      _types.push(new Type(this.type, this.cls, this.sub));\n    }\n    if (this.cls) {\n      _types.push(new Type(this.type, this.cls));\n    }\n    _types.push(new Type(this.type));\n\n    return _types;\n  }\n};\n\nvar toString = Object.prototype.toString;\n\n\n\n/**\n * Function to store type checks\n * @private\n */\nfunction TypeChecker() {\n  this.checks = [];\n}\n\nTypeChecker.prototype = {\n  add: function(func) {\n    this.checks.push(func);\n    return this;\n  },\n\n  addBeforeFirstMatch: function(obj, func) {\n    var match = this.getFirstMatch(obj);\n    if (match) {\n      this.checks.splice(match.index, 0, func);\n    } else {\n      this.add(func);\n    }\n  },\n\n  addTypeOf: function(type, res) {\n    return this.add(function(obj, tpeOf) {\n      if (tpeOf === type) {\n        return new Type(res);\n      }\n    });\n  },\n\n  addClass: function(cls, res, sub) {\n    return this.add(function(obj, tpeOf, objCls) {\n      if (objCls === cls) {\n        return new Type(types.OBJECT, res, sub);\n      }\n    });\n  },\n\n  getFirstMatch: function(obj) {\n    var typeOf = typeof obj;\n    var cls = toString.call(obj);\n\n    for (var i = 0, l = this.checks.length; i < l; i++) {\n      var res = this.checks[i].call(this, obj, typeOf, cls);\n      if (typeof res !== 'undefined') {\n        return { result: res, func: this.checks[i], index: i };\n      }\n    }\n  },\n\n  getType: function(obj) {\n    var match = this.getFirstMatch(obj);\n    return match && match.result;\n  }\n};\n\nvar main = new TypeChecker();\n\n//TODO add iterators\n\nmain\n  .addTypeOf(types.NUMBER, types.NUMBER)\n  .addTypeOf(types.UNDEFINED, types.UNDEFINED)\n  .addTypeOf(types.STRING, types.STRING)\n  .addTypeOf(types.BOOLEAN, types.BOOLEAN)\n  .addTypeOf(types.FUNCTION, types.FUNCTION)\n  .addTypeOf(types.SYMBOL, types.SYMBOL)\n  .add(function(obj) {\n    if (obj === null) {\n      return new Type(types.NULL);\n    }\n  })\n  .addClass('[object String]', types.STRING)\n  .addClass('[object Boolean]', types.BOOLEAN)\n  .addClass('[object Number]', types.NUMBER)\n  .addClass('[object Array]', types.ARRAY)\n  .addClass('[object RegExp]', types.REGEXP)\n  .addClass('[object Error]', types.ERROR)\n  .addClass('[object Date]', types.DATE)\n  .addClass('[object Arguments]', types.ARGUMENTS)\n\n  .addClass('[object ArrayBuffer]', types.ARRAY_BUFFER)\n  .addClass('[object Int8Array]', types.TYPED_ARRAY, 'int8')\n  .addClass('[object Uint8Array]', types.TYPED_ARRAY, 'uint8')\n  .addClass('[object Uint8ClampedArray]', types.TYPED_ARRAY, 'uint8clamped')\n  .addClass('[object Int16Array]', types.TYPED_ARRAY, 'int16')\n  .addClass('[object Uint16Array]', types.TYPED_ARRAY, 'uint16')\n  .addClass('[object Int32Array]', types.TYPED_ARRAY, 'int32')\n  .addClass('[object Uint32Array]', types.TYPED_ARRAY, 'uint32')\n  .addClass('[object Float32Array]', types.TYPED_ARRAY, 'float32')\n  .addClass('[object Float64Array]', types.TYPED_ARRAY, 'float64')\n\n  .addClass('[object Bool16x8]', types.SIMD, 'bool16x8')\n  .addClass('[object Bool32x4]', types.SIMD, 'bool32x4')\n  .addClass('[object Bool8x16]', types.SIMD, 'bool8x16')\n  .addClass('[object Float32x4]', types.SIMD, 'float32x4')\n  .addClass('[object Int16x8]', types.SIMD, 'int16x8')\n  .addClass('[object Int32x4]', types.SIMD, 'int32x4')\n  .addClass('[object Int8x16]', types.SIMD, 'int8x16')\n  .addClass('[object Uint16x8]', types.SIMD, 'uint16x8')\n  .addClass('[object Uint32x4]', types.SIMD, 'uint32x4')\n  .addClass('[object Uint8x16]', types.SIMD, 'uint8x16')\n\n  .addClass('[object DataView]', types.DATA_VIEW)\n  .addClass('[object Map]', types.MAP)\n  .addClass('[object WeakMap]', types.WEAK_MAP)\n  .addClass('[object Set]', types.SET)\n  .addClass('[object WeakSet]', types.WEAK_SET)\n  .addClass('[object Promise]', types.PROMISE)\n  .addClass('[object Blob]', types.BLOB)\n  .addClass('[object File]', types.FILE)\n  .addClass('[object FileList]', types.FILE_LIST)\n  .addClass('[object XMLHttpRequest]', types.XHR)\n  .add(function(obj) {\n    if ((typeof Promise === types.FUNCTION && obj instanceof Promise) ||\n        (typeof obj.then === types.FUNCTION)) {\n          return new Type(types.OBJECT, types.PROMISE);\n        }\n  })\n  .add(function(obj) {\n    if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {// eslint-disable-line no-undef\n      return new Type(types.OBJECT, types.BUFFER);\n    }\n  })\n  .add(function(obj) {\n    if (typeof Node !== 'undefined' && obj instanceof Node) {\n      return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);\n    }\n  })\n  .add(function(obj) {\n    // probably at the begginging should be enough these checks\n    if (obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {\n      return new Type(types.OBJECT, types.HOST);\n    }\n  })\n  .add(function() {\n    return new Type(types.OBJECT);\n  });\n\n/**\n * Get type information of anything\n *\n * @param  {any} obj Anything that could require type information\n * @return {Type}    type info\n * @private\n */\nfunction getGlobalType(obj) {\n  return main.getType(obj);\n}\n\ngetGlobalType.checker = main;\ngetGlobalType.TypeChecker = TypeChecker;\ngetGlobalType.Type = Type;\n\nObject.keys(types).forEach(function(typeName) {\n  getGlobalType[typeName] = types[typeName];\n});\n\nmodule.exports = getGlobalType;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should-type/cjs/should-type.js\n// module id = 20\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_array_ from '../array';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate';\nimport _ol_geom_flat_interpolate_ from '../geom/flat/interpolate';\nimport _ol_geom_flat_intersectsextent_ from '../geom/flat/intersectsextent';\nimport _ol_geom_flat_length_ from '../geom/flat/length';\nimport _ol_geom_flat_segments_ from '../geom/flat/segments';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_LineString_ = function(coordinates, opt_layout) {\n\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.flatMidpoint_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.flatMidpointRevision_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  this.setCoordinates(coordinates, opt_layout);\n\n};\n\n_ol_.inherits(_ol_geom_LineString_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Append the passed coordinate to the coordinates of the linestring.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @api\n */\n_ol_geom_LineString_.prototype.appendCoordinate = function(coordinate) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = coordinate.slice();\n  } else {\n    _ol_array_.extend(this.flatCoordinates, coordinate);\n  }\n  this.changed();\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.LineString} Clone.\n * @override\n * @api\n */\n_ol_geom_LineString_.prototype.clone = function() {\n  var lineString = new _ol_geom_LineString_(null);\n  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return lineString;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_LineString_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getMaxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n};\n\n\n/**\n * Iterate over each segment, calling the provided callback.\n * If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n *\n * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function\n *     called for each segment.\n * @param {S=} opt_this The object to be used as the value of 'this'\n *     within callback.\n * @return {T|boolean} Value.\n * @template T,S\n * @api\n */\n_ol_geom_LineString_.prototype.forEachSegment = function(callback, opt_this) {\n  return _ol_geom_flat_segments_.forEach(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, callback, opt_this);\n};\n\n\n/**\n * Returns the coordinate at `m` using linear interpolation, or `null` if no\n * such coordinate exists.\n *\n * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n * M will return the first coordinate and Ms greater than the last M will\n * return the last coordinate.\n *\n * @param {number} m M.\n * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n_ol_geom_LineString_.prototype.getCoordinateAtM = function(m, opt_extrapolate) {\n  if (this.layout != _ol_geom_GeometryLayout_.XYM &&\n      this.layout != _ol_geom_GeometryLayout_.XYZM) {\n    return null;\n  }\n  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n  return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, m, extrapolate);\n};\n\n\n/**\n * Return the coordinates of the linestring.\n * @return {Array.<ol.Coordinate>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_LineString_.prototype.getCoordinates = function() {\n  return _ol_geom_flat_inflate_.coordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n\n\n/**\n * Return the coordinate at the provided fraction along the linestring.\n * The `fraction` is a number between 0 and 1, where 0 is the start of the\n * linestring and 1 is the end.\n * @param {number} fraction Fraction.\n * @param {ol.Coordinate=} opt_dest Optional coordinate whose values will\n *     be modified. If not provided, a new coordinate will be returned.\n * @return {ol.Coordinate} Coordinate of the interpolated point.\n * @api\n */\n_ol_geom_LineString_.prototype.getCoordinateAt = function(fraction, opt_dest) {\n  return _ol_geom_flat_interpolate_.lineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      fraction, opt_dest);\n};\n\n\n/**\n * Return the length of the linestring on projected plane.\n * @return {number} Length (on projected plane).\n * @api\n */\n_ol_geom_LineString_.prototype.getLength = function() {\n  return _ol_geom_flat_length_.lineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n\n\n/**\n * @return {Array.<number>} Flat midpoint.\n */\n_ol_geom_LineString_.prototype.getFlatMidpoint = function() {\n  if (this.flatMidpointRevision_ != this.getRevision()) {\n    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n    this.flatMidpointRevision_ = this.getRevision();\n  }\n  return this.flatMidpoint_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_LineString_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n  var simplifiedLineString = new _ol_geom_LineString_(null);\n  simplifiedLineString.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates);\n  return simplifiedLineString;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_LineString_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.LINE_STRING;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_LineString_.prototype.intersectsExtent = function(extent) {\n  return _ol_geom_flat_intersectsextent_.lineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n};\n\n\n/**\n * Set the coordinates of the linestring.\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_LineString_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null);\n  } else {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = _ol_geom_flat_deflate_.coordinates(\n        this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n_ol_geom_LineString_.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\nexport default _ol_geom_LineString_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/linestring.js\n// module id = 21\n// module chunks = 0","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<any>|Geometry|Feature<Point>} obj any value\n * @returns {Array<number>} coordinates\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('No obj passed');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature<any>} obj any value\n * @returns {Array<any>} coordinates\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('No obj passed');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry<any>} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = invariant.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('<geojson> is required');\n    if (geojson.geometry) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('<geojson> must be a Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = invariant.getGeom(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    return getGeom(geojson).type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/invariant/index.js\n// module id = 22\n// module chunks = 0","/**\n * @enum {string}\n * @const\n */\nvar _ol_events_EventType_ = {\n  /**\n   * Generic change event. Triggered when the revision counter is increased.\n   * @event ol.events.Event#change\n   * @api\n   */\n  CHANGE: 'change',\n\n  CLICK: 'click',\n  DBLCLICK: 'dblclick',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DROP: 'drop',\n  ERROR: 'error',\n  KEYDOWN: 'keydown',\n  KEYPRESS: 'keypress',\n  LOAD: 'load',\n  MOUSEDOWN: 'mousedown',\n  MOUSEMOVE: 'mousemove',\n  MOUSEOUT: 'mouseout',\n  MOUSEUP: 'mouseup',\n  MOUSEWHEEL: 'mousewheel',\n  MSPOINTERDOWN: 'MSPointerDown',\n  RESIZE: 'resize',\n  TOUCHSTART: 'touchstart',\n  TOUCHMOVE: 'touchmove',\n  TOUCHEND: 'touchend',\n  WHEEL: 'wheel'\n};\n\nexport default _ol_events_EventType_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/events/eventtype.js\n// module id = 23\n// module chunks = 0","var _ol_geom_flat_area_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\n_ol_geom_flat_area_.linearRing = function(flatCoordinates, offset, end, stride) {\n  var twiceArea = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\n_ol_geom_flat_area_.linearRings = function(flatCoordinates, offset, ends, stride) {\n  var area = 0;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    area += _ol_geom_flat_area_.linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\n_ol_geom_flat_area_.linearRingss = function(flatCoordinates, offset, endss, stride) {\n  var area = 0;\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    area +=\n        _ol_geom_flat_area_.linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n};\nexport default _ol_geom_flat_area_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/area.js\n// module id = 24\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_math_ from '../math';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {ol.Coordinate} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_Point_ = function(coordinates, opt_layout) {\n  _ol_geom_SimpleGeometry_.call(this);\n  this.setCoordinates(coordinates, opt_layout);\n};\n\n_ol_.inherits(_ol_geom_Point_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.Point} Clone.\n * @override\n * @api\n */\n_ol_geom_Point_.prototype.clone = function() {\n  var point = new _ol_geom_Point_(null);\n  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return point;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Point_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  var flatCoordinates = this.flatCoordinates;\n  var squaredDistance = _ol_math_.squaredDistance(\n      x, y, flatCoordinates[0], flatCoordinates[1]);\n  if (squaredDistance < minSquaredDistance) {\n    var stride = this.stride;\n    var i;\n    for (i = 0; i < stride; ++i) {\n      closestPoint[i] = flatCoordinates[i];\n    }\n    closestPoint.length = stride;\n    return squaredDistance;\n  } else {\n    return minSquaredDistance;\n  }\n};\n\n\n/**\n * Return the coordinate of the point.\n * @return {ol.Coordinate} Coordinates.\n * @override\n * @api\n */\n_ol_geom_Point_.prototype.getCoordinates = function() {\n  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Point_.prototype.computeExtent = function(extent) {\n  return _ol_extent_.createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Point_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.POINT;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Point_.prototype.intersectsExtent = function(extent) {\n  return _ol_extent_.containsXY(extent,\n      this.flatCoordinates[0], this.flatCoordinates[1]);\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Point_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null);\n  } else {\n    this.setLayout(opt_layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = _ol_geom_flat_deflate_.coordinate(\n        this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n_ol_geom_Point_.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\nexport default _ol_geom_Point_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/point.js\n// module id = 25\n// module chunks = 0","import _ol_ from './index';\nimport _ol_extent_ from './extent';\nimport _ol_proj_EPSG3857_ from './proj/epsg3857';\nimport _ol_proj_EPSG4326_ from './proj/epsg4326';\nimport _ol_proj_Projection_ from './proj/projection';\nimport _ol_proj_Units_ from './proj/units';\nimport _ol_proj_proj4_ from './proj/proj4';\nimport _ol_proj_projections_ from './proj/projections';\nimport _ol_proj_transforms_ from './proj/transforms';\nimport _ol_sphere_NORMAL_ from './sphere/normal';\nvar _ol_proj_ = {};\n\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object.<ol.proj.Units, number>}\n * @api\n */\n_ol_proj_.METERS_PER_UNIT = _ol_proj_Units_.METERS_PER_UNIT;\n\n\nif (_ol_.ENABLE_PROJ4JS) {\n  /**\n   * Register proj4. If not explicitly registered, it will be assumed that\n   * proj4js will be loaded in the global namespace. For example in a\n   * browserify ES6 environment you could use:\n   *\n   *     import ol from 'openlayers';\n   *     import proj4 from 'proj4';\n   *     ol.proj.setProj4(proj4);\n   *\n   * @param {Proj4} proj4 Proj4.\n   * @api\n   */\n  _ol_proj_.setProj4 = function(proj4) {\n    _ol_proj_proj4_.set(proj4);\n  };\n}\n\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * estimated by transforming the 'point' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * @param {ol.proj.Projection} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {ol.Coordinate} point Point to find adjusted resolution at.\n * @return {number} Point resolution at point in projection units.\n * @api\n */\n_ol_proj_.getPointResolution = function(projection, resolution, point) {\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n  } else {\n    var units = projection.getUnits();\n    if (units == _ol_proj_Units_.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));\n      var vertices = [\n        point[0] - resolution / 2, point[1],\n        point[0] + resolution / 2, point[1],\n        point[0], point[1] - resolution / 2,\n        point[0], point[1] + resolution / 2\n      ];\n      vertices = toEPSG4326(vertices, vertices, 2);\n      var width = _ol_sphere_NORMAL_.haversineDistance(\n          vertices.slice(0, 2), vertices.slice(2, 4));\n      var height = _ol_sphere_NORMAL_.haversineDistance(\n          vertices.slice(4, 6), vertices.slice(6, 8));\n      pointResolution = (width + height) / 2;\n      var metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n};\n\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array.<ol.proj.Projection>} projections Projections.\n * @api\n */\n_ol_proj_.addEquivalentProjections = function(projections) {\n  _ol_proj_.addProjections(projections);\n  projections.forEach(function(source) {\n    projections.forEach(function(destination) {\n      if (source !== destination) {\n        _ol_proj_transforms_.add(source, destination, _ol_proj_.cloneTransform);\n      }\n    });\n  });\n};\n\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array.<ol.proj.Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array.<ol.proj.Projection>} projections2 Projections with equal\n *     meaning.\n * @param {ol.TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {ol.TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n_ol_proj_.addEquivalentTransforms = function(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function(projection1) {\n    projections2.forEach(function(projection2) {\n      _ol_proj_transforms_.add(projection1, projection2, forwardTransform);\n      _ol_proj_transforms_.add(projection2, projection1, inverseTransform);\n    });\n  });\n};\n\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {ol.proj.Projection} projection Projection instance.\n * @api\n */\n_ol_proj_.addProjection = function(projection) {\n  _ol_proj_projections_.add(projection.getCode(), projection);\n  _ol_proj_transforms_.add(projection, projection, _ol_proj_.cloneTransform);\n};\n\n\n/**\n * @param {Array.<ol.proj.Projection>} projections Projections.\n */\n_ol_proj_.addProjections = function(projections) {\n  var addedProjections = [];\n  projections.forEach(function(projection) {\n    addedProjections.push(_ol_proj_.addProjection(projection));\n  });\n};\n\n\n/**\n * Clear all cached projections and transforms.\n */\n_ol_proj_.clearAllProjections = function() {\n  _ol_proj_projections_.clear();\n  _ol_proj_transforms_.clear();\n};\n\n\n/**\n * @param {ol.proj.Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_proj_.createProjection = function(projection, defaultCode) {\n  if (!projection) {\n    return _ol_proj_.get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return _ol_proj_.get(projection);\n  } else {\n    return /** @type {ol.proj.Projection} */ (projection);\n  }\n};\n\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ol.ProjectionLike} source Source projection.\n * @param {ol.ProjectionLike} destination Destination projection.\n * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @api\n */\n_ol_proj_.addCoordinateTransforms = function(source, destination, forward, inverse) {\n  var sourceProj = _ol_proj_.get(source);\n  var destProj = _ol_proj_.get(destination);\n  _ol_proj_transforms_.add(sourceProj, destProj,\n      _ol_proj_.createTransformFromCoordinateTransform(forward));\n  _ol_proj_transforms_.add(destProj, sourceProj,\n      _ol_proj_.createTransformFromCoordinateTransform(inverse));\n};\n\n\n/**\n * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate\n *     transform.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.createTransformFromCoordinateTransform = function(transform) {\n  return (\n      /**\n       * @param {Array.<number>} input Input.\n       * @param {Array.<number>=} opt_output Output.\n       * @param {number=} opt_dimension Dimension.\n       * @return {Array.<number>} Output.\n       */\n      function(input, opt_output, opt_dimension) {\n        var length = input.length;\n        var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n        var output = opt_output !== undefined ? opt_output : new Array(length);\n        var point, i, j;\n        for (i = 0; i < length; i += dimension) {\n          point = transform([input[i], input[i + 1]]);\n          output[i] = point[0];\n          output[i + 1] = point[1];\n          for (j = dimension - 1; j >= 2; --j) {\n            output[i + j] = input[i + j];\n          }\n        }\n        return output;\n      });\n};\n\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ol.ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate projected to the target projection.\n * @api\n */\n_ol_proj_.fromLonLat = function(coordinate, opt_projection) {\n  return _ol_proj_.transform(coordinate, 'EPSG:4326',\n      opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n};\n\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {ol.Coordinate} coordinate Projected coordinate.\n * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n_ol_proj_.toLonLat = function(coordinate, opt_projection) {\n  return _ol_proj_.transform(coordinate,\n      opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n};\n\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ol.ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {ol.proj.Projection} Projection object, or null if not in list.\n * @api\n */\n_ol_proj_.get = function(projectionLike) {\n  var projection = null;\n  if (projectionLike instanceof _ol_proj_Projection_) {\n    projection = projectionLike;\n  } else if (typeof projectionLike === 'string') {\n    var code = projectionLike;\n    projection = _ol_proj_projections_.get(code);\n    if (_ol_.ENABLE_PROJ4JS) {\n      var proj4js = _ol_proj_proj4_.get();\n      if (!projection && typeof proj4js == 'function' &&\n          proj4js.defs(code) !== undefined) {\n        projection = new _ol_proj_Projection_({code: code});\n        _ol_proj_.addProjection(projection);\n      }\n    }\n  }\n  return projection;\n};\n\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {ol.proj.Projection} projection1 Projection 1.\n * @param {ol.proj.Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n_ol_proj_.equivalent = function(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFn = _ol_proj_.getTransformFromProjections(\n        projection1, projection2);\n    return transformFn === _ol_proj_.cloneTransform && equalUnits;\n  }\n};\n\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ol.ProjectionLike} source Source.\n * @param {ol.ProjectionLike} destination Destination.\n * @return {ol.TransformFunction} Transform function.\n * @api\n */\n_ol_proj_.getTransform = function(source, destination) {\n  var sourceProjection = _ol_proj_.get(source);\n  var destinationProjection = _ol_proj_.get(destination);\n  return _ol_proj_.getTransformFromProjections(\n      sourceProjection, destinationProjection);\n};\n\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {ol.proj.Projection} sourceProjection Source Projection object.\n * @param {ol.proj.Projection} destinationProjection Destination Projection\n *     object.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.getTransformFromProjections = function(sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n  if (_ol_.ENABLE_PROJ4JS && !transform) {\n    var proj4js = _ol_proj_proj4_.get();\n    if (typeof proj4js == 'function') {\n      var sourceDef = proj4js.defs(sourceCode);\n      var destinationDef = proj4js.defs(destinationCode);\n\n      if (sourceDef !== undefined && destinationDef !== undefined) {\n        if (sourceDef === destinationDef) {\n          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);\n        } else {\n          var proj4Transform = proj4js(destinationCode, sourceCode);\n          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection,\n              proj4Transform.forward, proj4Transform.inverse);\n        }\n        transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n      }\n    }\n  }\n  if (!transform) {\n    transform = _ol_proj_.identityTransform;\n  }\n  return transform;\n};\n\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Input coordinate array (same array as input).\n */\n_ol_proj_.identityTransform = function(input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    input = opt_output;\n  }\n  return input;\n};\n\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n_ol_proj_.cloneTransform = function(input, opt_output, opt_dimension) {\n  var output;\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n};\n\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link ol.proj.transformExtent} for extent transformation.\n * See the transform method of {@link ol.geom.Geometry} and its subclasses for\n * geometry transforms.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n_ol_proj_.transform = function(coordinate, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return transformFn(coordinate, undefined, coordinate.length);\n};\n\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {ol.Extent} extent The extent to transform.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Extent} The transformed extent.\n * @api\n */\n_ol_proj_.transformExtent = function(extent, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return _ol_extent_.applyTransform(extent, transformFn);\n};\n\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {ol.Coordinate} point Point.\n * @param {ol.proj.Projection} sourceProjection Source projection.\n * @param {ol.proj.Projection} destinationProjection Destination projection.\n * @return {ol.Coordinate} Point.\n */\n_ol_proj_.transformWithProjections = function(point, sourceProjection, destinationProjection) {\n  var transformFn = _ol_proj_.getTransformFromProjections(\n      sourceProjection, destinationProjection);\n  return transformFn(point);\n};\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `ol.proj.clearAllProjections()` is called (e.g. in tests).\n */\n_ol_proj_.addCommon = function() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG3857_.PROJECTIONS);\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG4326_.PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  _ol_proj_.addEquivalentTransforms(\n      _ol_proj_EPSG4326_.PROJECTIONS,\n      _ol_proj_EPSG3857_.PROJECTIONS,\n      _ol_proj_EPSG3857_.fromEPSG4326,\n      _ol_proj_EPSG3857_.toEPSG4326);\n};\n\n_ol_proj_.addCommon();\nexport default _ol_proj_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj.js\n// module id = 26\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_proj_Units_ from '../proj/units';\nimport _ol_proj_proj4_ from '../proj/proj4';\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link ol.proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link ol.ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link ol.proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use proj4js, aliases can be added using `proj4.defs()`; see\n * [documentation](https://github.com/proj4js/proj4js). To set an alternative\n * namespace for proj4, use {@link ol.proj.setProj4}.\n *\n * @constructor\n * @param {olx.ProjectionOptions} options Projection options.\n * @struct\n * @api\n */\nvar _ol_proj_Projection_ = function(options) {\n /**\n  * @private\n  * @type {string}\n  */\n  this.code_ = options.code;\n\n /**\n  * @private\n  * @type {ol.proj.Units}\n  */\n  this.units_ = /** @type {ol.proj.Units} */ (options.units);\n\n /**\n  * @private\n  * @type {ol.Extent}\n  */\n  this.extent_ = options.extent !== undefined ? options.extent : null;\n\n /**\n  * @private\n  * @type {ol.Extent}\n  */\n  this.worldExtent_ = options.worldExtent !== undefined ?\n     options.worldExtent : null;\n\n /**\n  * @private\n  * @type {string}\n  */\n  this.axisOrientation_ = options.axisOrientation !== undefined ?\n     options.axisOrientation : 'enu';\n\n /**\n  * @private\n  * @type {boolean}\n  */\n  this.global_ = options.global !== undefined ? options.global : false;\n\n /**\n  * @private\n  * @type {boolean}\n  */\n  this.canWrapX_ = !!(this.global_ && this.extent_);\n\n /**\n * @private\n * @type {function(number, ol.Coordinate):number|undefined}\n */\n  this.getPointResolutionFunc_ = options.getPointResolution;\n\n /**\n  * @private\n  * @type {ol.tilegrid.TileGrid}\n  */\n  this.defaultTileGrid_ = null;\n\n /**\n  * @private\n  * @type {number|undefined}\n  */\n  this.metersPerUnit_ = options.metersPerUnit;\n\n  var code = options.code;\n  if (_ol_.ENABLE_PROJ4JS) {\n    var proj4js = _ol_proj_proj4_.get();\n    if (typeof proj4js == 'function') {\n      var def = proj4js.defs(code);\n      if (def !== undefined) {\n        if (def.axis !== undefined && options.axisOrientation === undefined) {\n          this.axisOrientation_ = def.axis;\n        }\n        if (options.metersPerUnit === undefined) {\n          this.metersPerUnit_ = def.to_meter;\n        }\n        if (options.units === undefined) {\n          this.units_ = def.units;\n        }\n      }\n    }\n  }\n};\n\n\n/**\n * @return {boolean} The projection is suitable for wrapping the x-axis\n */\n_ol_proj_Projection_.prototype.canWrapX = function() {\n  return this.canWrapX_;\n};\n\n\n/**\n * Get the code for this projection, e.g. 'EPSG:4326'.\n * @return {string} Code.\n * @api\n */\n_ol_proj_Projection_.prototype.getCode = function() {\n  return this.code_;\n};\n\n\n/**\n * Get the validity extent for this projection.\n * @return {ol.Extent} Extent.\n * @api\n */\n_ol_proj_Projection_.prototype.getExtent = function() {\n  return this.extent_;\n};\n\n\n/**\n * Get the units of this projection.\n * @return {ol.proj.Units} Units.\n * @api\n */\n_ol_proj_Projection_.prototype.getUnits = function() {\n  return this.units_;\n};\n\n\n/**\n * Get the amount of meters per unit of this projection.  If the projection is\n * not configured with `metersPerUnit` or a units identifier, the return is\n * `undefined`.\n * @return {number|undefined} Meters.\n * @api\n */\n_ol_proj_Projection_.prototype.getMetersPerUnit = function() {\n  return this.metersPerUnit_ || _ol_proj_Units_.METERS_PER_UNIT[this.units_];\n};\n\n\n/**\n * Get the world extent for this projection.\n * @return {ol.Extent} Extent.\n * @api\n */\n_ol_proj_Projection_.prototype.getWorldExtent = function() {\n  return this.worldExtent_;\n};\n\n\n/**\n * Get the axis orientation of this projection.\n * Example values are:\n * enu - the default easting, northing, elevation.\n * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n *     or south orientated transverse mercator.\n * wnu - westing, northing, up - some planetary coordinate systems have\n *     \"west positive\" coordinate systems\n * @return {string} Axis orientation.\n */\n_ol_proj_Projection_.prototype.getAxisOrientation = function() {\n  return this.axisOrientation_;\n};\n\n\n/**\n * Is this projection a global projection which spans the whole world?\n * @return {boolean} Whether the projection is global.\n * @api\n */\n_ol_proj_Projection_.prototype.isGlobal = function() {\n  return this.global_;\n};\n\n\n/**\n* Set if the projection is a global projection which spans the whole world\n* @param {boolean} global Whether the projection is global.\n* @api\n*/\n_ol_proj_Projection_.prototype.setGlobal = function(global) {\n  this.global_ = global;\n  this.canWrapX_ = !!(global && this.extent_);\n};\n\n\n/**\n * @return {ol.tilegrid.TileGrid} The default tile grid.\n */\n_ol_proj_Projection_.prototype.getDefaultTileGrid = function() {\n  return this.defaultTileGrid_;\n};\n\n\n/**\n * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.\n */\n_ol_proj_Projection_.prototype.setDefaultTileGrid = function(tileGrid) {\n  this.defaultTileGrid_ = tileGrid;\n};\n\n\n/**\n * Set the validity extent for this projection.\n * @param {ol.Extent} extent Extent.\n * @api\n */\n_ol_proj_Projection_.prototype.setExtent = function(extent) {\n  this.extent_ = extent;\n  this.canWrapX_ = !!(this.global_ && extent);\n};\n\n\n/**\n * Set the world extent for this projection.\n * @param {ol.Extent} worldExtent World extent\n *     [minlon, minlat, maxlon, maxlat].\n * @api\n */\n_ol_proj_Projection_.prototype.setWorldExtent = function(worldExtent) {\n  this.worldExtent_ = worldExtent;\n};\n\n\n/**\n * Set the getPointResolution function for this projection.\n * @param {function(number, ol.Coordinate):number} func Function\n * @api\n */\n_ol_proj_Projection_.prototype.setGetPointResolution = function(func) {\n  this.getPointResolutionFunc_ = func;\n};\n\n\n/**\n * Get the custom point resolution function for this projection (if set).\n * @return {function(number, ol.Coordinate):number|undefined} The custom point\n * resolution function (if set).\n */\n_ol_proj_Projection_.prototype.getPointResolutionFunc = function() {\n  return this.getPointResolutionFunc_;\n};\nexport default _ol_proj_Projection_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/projection.js\n// module id = 27\n// module chunks = 0","import _ol_asserts_ from './asserts';\nimport _ol_events_ from './events';\nimport _ol_events_EventType_ from './events/eventtype';\nimport _ol_ from './index';\nimport _ol_Object_ from './object';\nimport _ol_geom_Geometry_ from './geom/geometry';\nimport _ol_style_Style_ from './style/style';\n\n/**\n * @classdesc\n * A vector object for geographic features with a geometry and other\n * attribute properties, similar to the features in vector file formats like\n * GeoJSON.\n *\n * Features can be styled individually with `setStyle`; otherwise they use the\n * style of their vector layer.\n *\n * Note that attribute properties are set as {@link ol.Object} properties on\n * the feature object, so they are observable, and have get/set accessors.\n *\n * Typically, a feature has a single geometry property. You can set the\n * geometry using the `setGeometry` method and get it with `getGeometry`.\n * It is possible to store more than one geometry on a feature using attribute\n * properties. By default, the geometry used for rendering is identified by\n * the property name `geometry`. If you want to use another geometry property\n * for rendering, use the `setGeometryName` method to change the attribute\n * property associated with the geometry for the feature.  For example:\n *\n * ```js\n * var feature = new ol.Feature({\n *   geometry: new ol.geom.Polygon(polyCoords),\n *   labelPoint: new ol.geom.Point(labelCoords),\n *   name: 'My Polygon'\n * });\n *\n * // get the polygon geometry\n * var poly = feature.getGeometry();\n *\n * // Render the feature as a point using the coordinates from labelPoint\n * feature.setGeometryName('labelPoint');\n *\n * // get the point geometry\n * var point = feature.getGeometry();\n * ```\n *\n * @constructor\n * @extends {ol.Object}\n * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties\n *     You may pass a Geometry object directly, or an object literal\n *     containing properties.  If you pass an object literal, you may\n *     include a Geometry associated with a `geometry` key.\n * @api\n */\nvar _ol_Feature_ = function(opt_geometryOrProperties) {\n\n  _ol_Object_.call(this);\n\n  /**\n   * @private\n   * @type {number|string|undefined}\n   */\n  this.id_ = undefined;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.geometryName_ = 'geometry';\n\n  /**\n   * User provided style.\n   * @private\n   * @type {ol.style.Style|Array.<ol.style.Style>|\n   *     ol.FeatureStyleFunction}\n   */\n  this.style_ = null;\n\n  /**\n   * @private\n   * @type {ol.FeatureStyleFunction|undefined}\n   */\n  this.styleFunction_ = undefined;\n\n  /**\n   * @private\n   * @type {?ol.EventsKey}\n   */\n  this.geometryChangeKey_ = null;\n\n  _ol_events_.listen(\n      this, _ol_Object_.getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_, this);\n\n  if (opt_geometryOrProperties !== undefined) {\n    if (opt_geometryOrProperties instanceof _ol_geom_Geometry_ ||\n        !opt_geometryOrProperties) {\n      var geometry = opt_geometryOrProperties;\n      this.setGeometry(geometry);\n    } else {\n      /** @type {Object.<string, *>} */\n      var properties = opt_geometryOrProperties;\n      this.setProperties(properties);\n    }\n  }\n};\n\n_ol_.inherits(_ol_Feature_, _ol_Object_);\n\n\n/**\n * Clone this feature. If the original feature has a geometry it\n * is also cloned. The feature id is not set in the clone.\n * @return {ol.Feature} The clone.\n * @api\n */\n_ol_Feature_.prototype.clone = function() {\n  var clone = new _ol_Feature_(this.getProperties());\n  clone.setGeometryName(this.getGeometryName());\n  var geometry = this.getGeometry();\n  if (geometry) {\n    clone.setGeometry(geometry.clone());\n  }\n  var style = this.getStyle();\n  if (style) {\n    clone.setStyle(style);\n  }\n  return clone;\n};\n\n\n/**\n * Get the feature's default geometry.  A feature may have any number of named\n * geometries.  The \"default\" geometry (the one that is rendered by default) is\n * set when calling {@link ol.Feature#setGeometry}.\n * @return {ol.geom.Geometry|undefined} The default geometry for the feature.\n * @api\n * @observable\n */\n_ol_Feature_.prototype.getGeometry = function() {\n  return /** @type {ol.geom.Geometry|undefined} */ (\n      this.get(this.geometryName_));\n};\n\n\n/**\n * Get the feature identifier.  This is a stable identifier for the feature and\n * is either set when reading data from a remote source or set explicitly by\n * calling {@link ol.Feature#setId}.\n * @return {number|string|undefined} Id.\n * @api\n */\n_ol_Feature_.prototype.getId = function() {\n  return this.id_;\n};\n\n\n/**\n * Get the name of the feature's default geometry.  By default, the default\n * geometry is named `geometry`.\n * @return {string} Get the property name associated with the default geometry\n *     for this feature.\n * @api\n */\n_ol_Feature_.prototype.getGeometryName = function() {\n  return this.geometryName_;\n};\n\n\n/**\n * Get the feature's style. Will return what was provided to the\n * {@link ol.Feature#setStyle} method.\n * @return {ol.style.Style|Array.<ol.style.Style>|\n *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.\n * @api\n */\n_ol_Feature_.prototype.getStyle = function() {\n  return this.style_;\n};\n\n\n/**\n * Get the feature's style function.\n * @return {ol.FeatureStyleFunction|undefined} Return a function\n * representing the current style of this feature.\n * @api\n */\n_ol_Feature_.prototype.getStyleFunction = function() {\n  return this.styleFunction_;\n};\n\n\n/**\n * @private\n */\n_ol_Feature_.prototype.handleGeometryChange_ = function() {\n  this.changed();\n};\n\n\n/**\n * @private\n */\n_ol_Feature_.prototype.handleGeometryChanged_ = function() {\n  if (this.geometryChangeKey_) {\n    _ol_events_.unlistenByKey(this.geometryChangeKey_);\n    this.geometryChangeKey_ = null;\n  }\n  var geometry = this.getGeometry();\n  if (geometry) {\n    this.geometryChangeKey_ = _ol_events_.listen(geometry,\n        _ol_events_EventType_.CHANGE, this.handleGeometryChange_, this);\n  }\n  this.changed();\n};\n\n\n/**\n * Set the default geometry for the feature.  This will update the property\n * with the name returned by {@link ol.Feature#getGeometryName}.\n * @param {ol.geom.Geometry|undefined} geometry The new geometry.\n * @api\n * @observable\n */\n_ol_Feature_.prototype.setGeometry = function(geometry) {\n  this.set(this.geometryName_, geometry);\n};\n\n\n/**\n * Set the style for the feature.  This can be a single style object, an array\n * of styles, or a function that takes a resolution and returns an array of\n * styles. If it is `null` the feature has no style (a `null` style).\n * @param {ol.style.Style|Array.<ol.style.Style>|\n *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.\n * @api\n * @fires ol.events.Event#event:change\n */\n_ol_Feature_.prototype.setStyle = function(style) {\n  this.style_ = style;\n  this.styleFunction_ = !style ?\n      undefined : _ol_Feature_.createStyleFunction(style);\n  this.changed();\n};\n\n\n/**\n * Set the feature id.  The feature id is considered stable and may be used when\n * requesting features or comparing identifiers returned from a remote source.\n * The feature id can be used with the {@link ol.source.Vector#getFeatureById}\n * method.\n * @param {number|string|undefined} id The feature id.\n * @api\n * @fires ol.events.Event#event:change\n */\n_ol_Feature_.prototype.setId = function(id) {\n  this.id_ = id;\n  this.changed();\n};\n\n\n/**\n * Set the property name to be used when getting the feature's default geometry.\n * When calling {@link ol.Feature#getGeometry}, the value of the property with\n * this name will be returned.\n * @param {string} name The property name of the default geometry.\n * @api\n */\n_ol_Feature_.prototype.setGeometryName = function(name) {\n  _ol_events_.unlisten(\n      this, _ol_Object_.getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_, this);\n  this.geometryName_ = name;\n  _ol_events_.listen(\n      this, _ol_Object_.getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_, this);\n  this.handleGeometryChanged_();\n};\n\n\n/**\n * Convert the provided object into a feature style function.  Functions passed\n * through unchanged.  Arrays of ol.style.Style or single style objects wrapped\n * in a new feature style function.\n * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj\n *     A feature style function, a single style, or an array of styles.\n * @return {ol.FeatureStyleFunction} A style function.\n */\n_ol_Feature_.createStyleFunction = function(obj) {\n  var styleFunction;\n\n  if (typeof obj === 'function') {\n    if (obj.length == 2) {\n      styleFunction = function(resolution) {\n        return /** @type {ol.StyleFunction} */ (obj)(this, resolution);\n      };\n    } else {\n      styleFunction = obj;\n    }\n  } else {\n    /**\n     * @type {Array.<ol.style.Style>}\n     */\n    var styles;\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      _ol_asserts_.assert(obj instanceof _ol_style_Style_,\n          41); // Expected an `ol.style.Style` or an array of `ol.style.Style`\n      styles = [obj];\n    }\n    styleFunction = function() {\n      return styles;\n    };\n  }\n  return styleFunction;\n};\nexport default _ol_Feature_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/feature.js\n// module id = 28\n// module chunks = 0","var getCoord = require('@turf/invariant').getCoord;\nvar radiansToDistance = require('@turf/helpers').radiansToDistance;\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Geometry|Feature<Point>|Array<number>} from origin point\n * @param {Geometry|Feature<Point>|Array<number>} to destination point\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.343, 39.984]\n *   }\n * };\n * var to = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.534, 39.123]\n *   }\n * };\n *\n * var distance = turf.distance(from, to, \"miles\");\n *\n * //addToMap\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n * var addToMap = [from, to];\n */\nmodule.exports = function (from, to, units) {\n    var degrees2radians = Math.PI / 180;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);\n    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/distance/index.js\n// module id = 29\n// module chunks = 0","import _ol_asserts_ from './asserts';\nimport _ol_math_ from './math';\nvar _ol_color_ = {};\n\n\n/**\n * This RegExp matches # followed by 3 or 6 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\n_ol_color_.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3}){1,2}$/i;\n\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\n_ol_color_.NAMED_COLOR_RE_ = /^([a-z]*)$/i;\n\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {ol.Color|string} color Color.\n * @return {ol.Color} Color.\n * @api\n */\n_ol_color_.asArray = function(color) {\n  if (Array.isArray(color)) {\n    return color;\n  } else {\n    return _ol_color_.fromString(/** @type {string} */ (color));\n  }\n};\n\n\n/**\n * Return the color as an rgba string.\n * @param {ol.Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\n_ol_color_.asString = function(color) {\n  if (typeof color === 'string') {\n    return color;\n  } else {\n    return _ol_color_.toString(color);\n  }\n};\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\n_ol_color_.fromNamed = function(color) {\n  var el = document.createElement('div');\n  el.style.color = color;\n  document.body.appendChild(el);\n  var rgb = getComputedStyle(el).color;\n  document.body.removeChild(el);\n  return rgb;\n};\n\n\n/**\n * @param {string} s String.\n * @return {ol.Color} Color.\n */\n_ol_color_.fromString = (\n    function() {\n\n      // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n      // semantics, whenever the cache grows too large we simply delete an\n      // arbitrary 25% of the entries.\n\n      /**\n       * @const\n       * @type {number}\n       */\n      var MAX_CACHE_SIZE = 1024;\n\n      /**\n       * @type {Object.<string, ol.Color>}\n       */\n      var cache = {};\n\n      /**\n       * @type {number}\n       */\n      var cacheSize = 0;\n\n      return (\n          /**\n           * @param {string} s String.\n           * @return {ol.Color} Color.\n           */\n          function(s) {\n            var color;\n            if (cache.hasOwnProperty(s)) {\n              color = cache[s];\n            } else {\n              if (cacheSize >= MAX_CACHE_SIZE) {\n                var i = 0;\n                var key;\n                for (key in cache) {\n                  if ((i++ & 3) === 0) {\n                    delete cache[key];\n                    --cacheSize;\n                  }\n                }\n              }\n              color = _ol_color_.fromStringInternal_(s);\n              cache[s] = color;\n              ++cacheSize;\n            }\n            return color;\n          });\n\n    })();\n\n\n/**\n * @param {string} s String.\n * @private\n * @return {ol.Color} Color.\n */\n_ol_color_.fromStringInternal_ = function(s) {\n  var r, g, b, a, color, parts;\n\n  if (_ol_color_.NAMED_COLOR_RE_.exec(s)) {\n    s = _ol_color_.fromNamed(s);\n  }\n\n  if (_ol_color_.HEX_COLOR_RE_.exec(s)) { // hex\n    var n = s.length - 1; // number of hex digits\n    _ol_asserts_.assert(n == 3 || n == 6, 54); // Hex color should have 3 or 6 digits\n    var d = n == 3 ? 1 : 2; // number of digits per channel\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n    }\n    a = 1;\n    color = [r, g, b, a];\n  } else if (s.indexOf('rgba(') == 0) { // rgba()\n    parts = s.slice(5, -1).split(',').map(Number);\n    color = _ol_color_.normalize(parts);\n  } else if (s.indexOf('rgb(') == 0) { // rgb()\n    parts = s.slice(4, -1).split(',').map(Number);\n    parts.push(1);\n    color = _ol_color_.normalize(parts);\n  } else {\n    _ol_asserts_.assert(false, 14); // Invalid color\n  }\n  return /** @type {ol.Color} */ (color);\n};\n\n\n/**\n * @param {ol.Color} color Color.\n * @param {ol.Color=} opt_color Color.\n * @return {ol.Color} Clamped color.\n */\n_ol_color_.normalize = function(color, opt_color) {\n  var result = opt_color || [];\n  result[0] = _ol_math_.clamp((color[0] + 0.5) | 0, 0, 255);\n  result[1] = _ol_math_.clamp((color[1] + 0.5) | 0, 0, 255);\n  result[2] = _ol_math_.clamp((color[2] + 0.5) | 0, 0, 255);\n  result[3] = _ol_math_.clamp(color[3], 0, 1);\n  return result;\n};\n\n\n/**\n * @param {ol.Color} color Color.\n * @return {string} String.\n */\n_ol_color_.toString = function(color) {\n  var r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  var g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  var b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  var a = color[3] === undefined ? 1 : color[3];\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n};\nexport default _ol_color_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/color.js\n// module id = 30\n// module chunks = 0","/**\n * @classdesc\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\n * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}\n *\n * This implementation only provides `type` and `target` properties, and\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\n * for higher level events defined in the library, and works with\n * {@link ol.events.EventTarget}.\n *\n * @constructor\n * @implements {oli.events.Event}\n * @param {string} type Type.\n */\nvar _ol_events_Event_ = function(type) {\n\n  /**\n   * @type {boolean}\n   */\n  this.propagationStopped;\n\n  /**\n   * The event type.\n   * @type {string}\n   * @api\n   */\n  this.type = type;\n\n  /**\n   * The event target.\n   * @type {Object}\n   * @api\n   */\n  this.target = null;\n\n};\n\n\n/**\n * Stop event propagation.\n * @function\n * @override\n * @api\n */\n_ol_events_Event_.prototype.preventDefault =\n\n/**\n * Stop event propagation.\n * @function\n * @override\n * @api\n */\n_ol_events_Event_.prototype.stopPropagation = function() {\n  this.propagationStopped = true;\n};\n\n\n/**\n * @param {Event|ol.events.Event} evt Event\n */\n_ol_events_Event_.stopPropagation = function(evt) {\n  evt.stopPropagation();\n};\n\n\n/**\n * @param {Event|ol.events.Event} evt Event\n */\n_ol_events_Event_.preventDefault = function(evt) {\n  evt.preventDefault();\n};\nexport default _ol_events_Event_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/events/event.js\n// module id = 31\n// module chunks = 0","import _ol_geom_Geometry_ from '../geom/geometry';\nimport _ol_obj_ from '../obj';\nimport _ol_proj_ from '../proj';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {ol.format.Feature} subclasses provide the ability to decode and encode\n * {@link ol.Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @constructor\n * @abstract\n * @api\n */\nvar _ol_format_Feature_ = function() {\n\n  /**\n   * @protected\n   * @type {ol.proj.Projection}\n   */\n  this.defaultDataProjection = null;\n\n  /**\n   * @protected\n   * @type {ol.proj.Projection}\n   */\n  this.defaultFeatureProjection = null;\n\n};\n\n\n/**\n * Adds the data projection to the read options.\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Options.\n * @return {olx.format.ReadOptions|undefined} Options.\n * @protected\n */\n_ol_format_Feature_.prototype.getReadOptions = function(source, opt_options) {\n  var options;\n  if (opt_options) {\n    options = {\n      dataProjection: opt_options.dataProjection ?\n          opt_options.dataProjection : this.readProjection(source),\n      featureProjection: opt_options.featureProjection\n    };\n  }\n  return this.adaptOptions(options);\n};\n\n\n/**\n * Sets the `defaultDataProjection` on the options, if no `dataProjection`\n * is set.\n * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options\n *     Options.\n * @protected\n * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}\n *     Updated options.\n */\n_ol_format_Feature_.prototype.adaptOptions = function(options) {\n  return _ol_obj_.assign({\n    dataProjection: this.defaultDataProjection,\n    featureProjection: this.defaultFeatureProjection\n  }, options);\n};\n\n\n/**\n * @abstract\n * @return {ol.format.FormatType} Format.\n */\n_ol_format_Feature_.prototype.getType = function() {};\n\n\n/**\n * Read a single feature from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.Feature} Feature.\n */\n_ol_format_Feature_.prototype.readFeature = function(source, opt_options) {};\n\n\n/**\n * Read all features from a source.\n *\n * @abstract\n * @param {Document|Node|ArrayBuffer|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {Array.<ol.Feature>} Features.\n */\n_ol_format_Feature_.prototype.readFeatures = function(source, opt_options) {};\n\n\n/**\n * Read a single geometry from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.geom.Geometry} Geometry.\n */\n_ol_format_Feature_.prototype.readGeometry = function(source, opt_options) {};\n\n\n/**\n * Read the projection from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_format_Feature_.prototype.readProjection = function(source) {};\n\n\n/**\n * Encode a feature in this format.\n *\n * @abstract\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeFeature = function(feature, opt_options) {};\n\n\n/**\n * Encode an array of features in this format.\n *\n * @abstract\n * @param {Array.<ol.Feature>} features Features.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeFeatures = function(features, opt_options) {};\n\n\n/**\n * Write a single geometry in this format.\n *\n * @abstract\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeGeometry = function(geometry, opt_options) {};\n\n\n/**\n * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options\n *     Options.\n * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.\n * @protected\n */\n_ol_format_Feature_.transformWithOptions = function(\n    geometry, write, opt_options) {\n  var featureProjection = opt_options ?\n      _ol_proj_.get(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ?\n      _ol_proj_.get(opt_options.dataProjection) : null;\n  /**\n   * @type {ol.geom.Geometry|ol.Extent}\n   */\n  var transformed;\n  if (featureProjection && dataProjection &&\n      !_ol_proj_.equivalent(featureProjection, dataProjection)) {\n    if (geometry instanceof _ol_geom_Geometry_) {\n      transformed = (write ? geometry.clone() : geometry).transform(\n          write ? featureProjection : dataProjection,\n          write ? dataProjection : featureProjection);\n    } else {\n      // FIXME this is necessary because ol.format.GML treats extents\n      // as geometries\n      transformed = _ol_proj_.transformExtent(\n          write ? geometry.slice() : geometry,\n          write ? featureProjection : dataProjection,\n          write ? dataProjection : featureProjection);\n    }\n  } else {\n    transformed = geometry;\n  }\n  if (write && opt_options && opt_options.decimals) {\n    var power = Math.pow(10, opt_options.decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array.<number>} coordinates Coordinates.\n     * @return {Array.<number>} Transformed coordinates.\n     */\n    var transform = function(coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (Array.isArray(transformed)) {\n      transform(transformed);\n    } else {\n      transformed.applyTransform(transform);\n    }\n  }\n  return transformed;\n};\nexport default _ol_format_Feature_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/format/feature.js\n// module id = 32\n// module chunks = 0","var _ol_functions_ = {};\n\n/**\n * Always returns true.\n * @returns {boolean} true.\n */\n_ol_functions_.TRUE = function() {\n  return true;\n};\n\n/**\n * Always returns false.\n * @returns {boolean} false.\n */\n_ol_functions_.FALSE = function() {\n  return false;\n};\nexport default _ol_functions_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/functions.js\n// module id = 33\n// module chunks = 0","import _ol_array_ from '../../array';\nimport _ol_geom_flat_contains_ from '../flat/contains';\nvar _ol_geom_flat_interiorpoint_ = {};\n\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array.<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Destination.\n */\n_ol_geom_flat_interiorpoint_.linearRings = function(flatCoordinates, offset,\n    ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n  var i, ii, x, x1, x2, y1, y2;\n  var y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array.<number>} */\n  var intersections = [];\n  // Calculate intersections with the horizontal line\n  var end = ends[0];\n  x1 = flatCoordinates[end - stride];\n  y1 = flatCoordinates[end - stride + 1];\n  for (i = offset; i < end; i += stride) {\n    x2 = flatCoordinates[i];\n    y2 = flatCoordinates[i + 1];\n    if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n      x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n      intersections.push(x);\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  var pointX = NaN;\n  var maxSegmentLength = -Infinity;\n  intersections.sort(_ol_array_.numberSafeCompareFunction);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    var segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (_ol_geom_flat_contains_.linearRingsContainsXY(\n          flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (opt_dest) {\n    opt_dest.push(pointX, y);\n    return opt_dest;\n  } else {\n    return [pointX, y];\n  }\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array.<number>} flatCenters Flat centers.\n * @return {Array.<number>} Interior points.\n */\n_ol_geom_flat_interiorpoint_.linearRingss = function(flatCoordinates, offset, endss, stride, flatCenters) {\n  var interiorPoints = [];\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    interiorPoints = _ol_geom_flat_interiorpoint_.linearRings(flatCoordinates,\n        offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n};\nexport default _ol_geom_flat_interiorpoint_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/interiorpoint.js\n// module id = 34\n// module chunks = 0","import _ol_array_ from '../../array';\nimport _ol_math_ from '../../math';\nvar _ol_geom_flat_interpolate_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Destination.\n */\n_ol_geom_flat_interpolate_.lineString = function(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    var i;\n    for (i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = _ol_array_.binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = _ol_math_.lerp(\n          flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = _ol_math_.lerp(\n          flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {ol.Coordinate} Coordinate.\n */\n_ol_geom_flat_interpolate_.lineStringCoordinateAtM = function(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  var i;\n  for (i = 0; i < stride - 1; ++i) {\n    coordinate.push(_ol_math_.lerp(flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {ol.Coordinate} Coordinate.\n */\n_ol_geom_flat_interpolate_.lineStringsCoordinateAtM = function(\n    flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(\n        flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(\n          flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n};\nexport default _ol_geom_flat_interpolate_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/interpolate.js\n// module id = 35\n// module chunks = 0","import _ol_geom_flat_reverse_ from '../flat/reverse';\nvar _ol_geom_flat_orient_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n_ol_geom_flat_orient_.linearRingIsClockwise = function(flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge > 0;\n};\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n_ol_geom_flat_orient_.linearRingsAreOriented = function(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(\n        flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n};\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n_ol_geom_flat_orient_.linearRingssAreOriented = function(flatCoordinates, offset, endss, stride, opt_right) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    if (!_ol_geom_flat_orient_.linearRingsAreOriented(\n        flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n_ol_geom_flat_orient_.orientLinearRings = function(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(\n        flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ?\n        (right && isClockwise) || (!right && !isClockwise) :\n        (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      _ol_geom_flat_reverse_.coordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n};\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n_ol_geom_flat_orient_.orientLinearRingss = function(flatCoordinates, offset, endss, stride, opt_right) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    offset = _ol_geom_flat_orient_.orientLinearRings(\n        flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n  return offset;\n};\nexport default _ol_geom_flat_orient_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/orient.js\n// module id = 36\n// module chunks = 0","var _ol_geom_flat_segments_ = {};\n\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function\n *     called for each segment.\n * @param {S=} opt_this The object to be used as the value of 'this'\n *     within callback.\n * @return {T|boolean} Value.\n * @template T,S\n */\n_ol_geom_flat_segments_.forEach = function(flatCoordinates, offset, end, stride, callback, opt_this) {\n  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  var point2 = [];\n  var ret;\n  for (; (offset + stride) < end; offset += stride) {\n    point2[0] = flatCoordinates[offset + stride];\n    point2[1] = flatCoordinates[offset + stride + 1];\n    ret = callback.call(opt_this, point1, point2);\n    if (ret) {\n      return ret;\n    }\n    point1[0] = point2[0];\n    point1[1] = point2[1];\n  }\n  return false;\n};\nexport default _ol_geom_flat_segments_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/segments.js\n// module id = 37\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_array_ from '../array';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_Point_ from '../geom/point';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate';\nimport _ol_math_ from '../math';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_MultiPoint_ = function(coordinates, opt_layout) {\n  _ol_geom_SimpleGeometry_.call(this);\n  this.setCoordinates(coordinates, opt_layout);\n};\n\n_ol_.inherits(_ol_geom_MultiPoint_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Append the passed point to this multipoint.\n * @param {ol.geom.Point} point Point.\n * @api\n */\n_ol_geom_MultiPoint_.prototype.appendPoint = function(point) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = point.getFlatCoordinates().slice();\n  } else {\n    _ol_array_.extend(this.flatCoordinates, point.getFlatCoordinates());\n  }\n  this.changed();\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.MultiPoint} Clone.\n * @override\n * @api\n */\n_ol_geom_MultiPoint_.prototype.clone = function() {\n  var multiPoint = new _ol_geom_MultiPoint_(null);\n  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return multiPoint;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_MultiPoint_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  var flatCoordinates = this.flatCoordinates;\n  var stride = this.stride;\n  var i, ii, j;\n  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n    var squaredDistance = _ol_math_.squaredDistance(\n        x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (j = 0; j < stride; ++j) {\n        closestPoint[j] = flatCoordinates[i + j];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * Return the coordinates of the multipoint.\n * @return {Array.<ol.Coordinate>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_MultiPoint_.prototype.getCoordinates = function() {\n  return _ol_geom_flat_inflate_.coordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n\n\n/**\n * Return the point at the specified index.\n * @param {number} index Index.\n * @return {ol.geom.Point} Point.\n * @api\n */\n_ol_geom_MultiPoint_.prototype.getPoint = function(index) {\n  var n = !this.flatCoordinates ?\n      0 : this.flatCoordinates.length / this.stride;\n  if (index < 0 || n <= index) {\n    return null;\n  }\n  var point = new _ol_geom_Point_(null);\n  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n      index * this.stride, (index + 1) * this.stride));\n  return point;\n};\n\n\n/**\n * Return the points of this multipoint.\n * @return {Array.<ol.geom.Point>} Points.\n * @api\n */\n_ol_geom_MultiPoint_.prototype.getPoints = function() {\n  var flatCoordinates = this.flatCoordinates;\n  var layout = this.layout;\n  var stride = this.stride;\n  /** @type {Array.<ol.geom.Point>} */\n  var points = [];\n  var i, ii;\n  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n    var point = new _ol_geom_Point_(null);\n    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));\n    points.push(point);\n  }\n  return points;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_MultiPoint_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.MULTI_POINT;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_MultiPoint_.prototype.intersectsExtent = function(extent) {\n  var flatCoordinates = this.flatCoordinates;\n  var stride = this.stride;\n  var i, ii, x, y;\n  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n    x = flatCoordinates[i];\n    y = flatCoordinates[i + 1];\n    if (_ol_extent_.containsXY(extent, x, y)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Set the coordinates of the multipoint.\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_MultiPoint_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null);\n  } else {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = _ol_geom_flat_deflate_.coordinates(\n        this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n_ol_geom_MultiPoint_.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\nexport default _ol_geom_MultiPoint_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/multipoint.js\n// module id = 38\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_array_ from '../array';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_LinearRing_ from '../geom/linearring';\nimport _ol_geom_Point_ from '../geom/point';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_area_ from '../geom/flat/area';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest';\nimport _ol_geom_flat_contains_ from '../geom/flat/contains';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate';\nimport _ol_geom_flat_interiorpoint_ from '../geom/flat/interiorpoint';\nimport _ol_geom_flat_intersectsextent_ from '../geom/flat/intersectsextent';\nimport _ol_geom_flat_orient_ from '../geom/flat/orient';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify';\nimport _ol_math_ from '../math';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear\n *     rings that define the polygon. The first linear ring of the array\n *     defines the outer-boundary or surface of the polygon. Each subsequent\n *     linear ring defines a hole in the surface of the polygon. A linear ring\n *     is an array of vertices' coordinates where the first coordinate and the\n *     last are equivalent.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_Polygon_ = function(coordinates, opt_layout) {\n\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n  this.ends_ = [];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.flatInteriorPointRevision_ = -1;\n\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.flatInteriorPoint_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.orientedRevision_ = -1;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.orientedFlatCoordinates_ = null;\n\n  this.setCoordinates(coordinates, opt_layout);\n\n};\n\n_ol_.inherits(_ol_geom_Polygon_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Append the passed linear ring to this polygon.\n * @param {ol.geom.LinearRing} linearRing Linear ring.\n * @api\n */\n_ol_geom_Polygon_.prototype.appendLinearRing = function(linearRing) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n  } else {\n    _ol_array_.extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n  }\n  this.ends_.push(this.flatCoordinates.length);\n  this.changed();\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.Polygon} Clone.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.clone = function() {\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      this.layout, this.flatCoordinates.slice(), this.ends_.slice());\n  return polygon;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getsMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getsClosestPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.containsXY = function(x, y) {\n  return _ol_geom_flat_contains_.linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n};\n\n\n/**\n * Return the area of the polygon on projected plane.\n * @return {number} Area (on projected plane).\n * @api\n */\n_ol_geom_Polygon_.prototype.getArea = function() {\n  return _ol_geom_flat_area_.linearRings(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n};\n\n\n/**\n * Get the coordinate array for this geometry.  This array has the structure\n * of a GeoJSON coordinate array for polygons.\n *\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\n *     If `false`, coordinates will be oriented according to the left-hand rule\n *     (clockwise for exterior and counter-clockwise for interior rings).\n *     By default, coordinate orientation will depend on how the geometry was\n *     constructed.\n * @return {Array.<Array.<ol.Coordinate>>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.getCoordinates = function(opt_right) {\n  var flatCoordinates;\n  if (opt_right !== undefined) {\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\n    _ol_geom_flat_orient_.orientLinearRings(\n        flatCoordinates, 0, this.ends_, this.stride, opt_right);\n  } else {\n    flatCoordinates = this.flatCoordinates;\n  }\n\n  return _ol_geom_flat_inflate_.coordinatess(\n      flatCoordinates, 0, this.ends_, this.stride);\n};\n\n\n/**\n * @return {Array.<number>} Ends.\n */\n_ol_geom_Polygon_.prototype.getEnds = function() {\n  return this.ends_;\n};\n\n\n/**\n * @return {Array.<number>} Interior point.\n */\n_ol_geom_Polygon_.prototype.getFlatInteriorPoint = function() {\n  if (this.flatInteriorPointRevision_ != this.getRevision()) {\n    var flatCenter = _ol_extent_.getCenter(this.getExtent());\n    this.flatInteriorPoint_ = _ol_geom_flat_interiorpoint_.linearRings(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,\n        flatCenter, 0);\n    this.flatInteriorPointRevision_ = this.getRevision();\n  }\n  return this.flatInteriorPoint_;\n};\n\n\n/**\n * Return an interior point of the polygon.\n * @return {ol.geom.Point} Interior point.\n * @api\n */\n_ol_geom_Polygon_.prototype.getInteriorPoint = function() {\n  return new _ol_geom_Point_(this.getFlatInteriorPoint());\n};\n\n\n/**\n * Return the number of rings of the polygon,  this includes the exterior\n * ring and any interior rings.\n *\n * @return {number} Number of rings.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRingCount = function() {\n  return this.ends_.length;\n};\n\n\n/**\n * Return the Nth linear ring of the polygon geometry. Return `null` if the\n * given index is out of range.\n * The exterior linear ring is available at index `0` and the interior rings\n * at index `1` and beyond.\n *\n * @param {number} index Index.\n * @return {ol.geom.LinearRing} Linear ring.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRing = function(index) {\n  if (index < 0 || this.ends_.length <= index) {\n    return null;\n  }\n  var linearRing = new _ol_geom_LinearRing_(null);\n  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\n  return linearRing;\n};\n\n\n/**\n * Return the linear rings of the polygon.\n * @return {Array.<ol.geom.LinearRing>} Linear rings.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRings = function() {\n  var layout = this.layout;\n  var flatCoordinates = this.flatCoordinates;\n  var ends = this.ends_;\n  var linearRings = [];\n  var offset = 0;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var linearRing = new _ol_geom_LinearRing_(null);\n    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\n    linearRings.push(linearRing);\n    offset = end;\n  }\n  return linearRings;\n};\n\n\n/**\n * @return {Array.<number>} Oriented flat coordinates.\n */\n_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function() {\n  if (this.orientedRevision_ != this.getRevision()) {\n    var flatCoordinates = this.flatCoordinates;\n    if (_ol_geom_flat_orient_.linearRingsAreOriented(\n        flatCoordinates, 0, this.ends_, this.stride)) {\n      this.orientedFlatCoordinates_ = flatCoordinates;\n    } else {\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\n      this.orientedFlatCoordinates_.length =\n          _ol_geom_flat_orient_.orientLinearRings(\n              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n    }\n    this.orientedRevision_ = this.getRevision();\n  }\n  return this.orientedFlatCoordinates_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  var simplifiedEnds = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.quantizes(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n  var simplifiedPolygon = new _ol_geom_Polygon_(null);\n  simplifiedPolygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates, simplifiedEnds);\n  return simplifiedPolygon;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Polygon_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.POLYGON;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Polygon_.prototype.intersectsExtent = function(extent) {\n  return _ol_geom_flat_intersectsextent_.linearRings(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n};\n\n\n/**\n * Set the coordinates of the polygon.\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null, this.ends_);\n  } else {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = _ol_geom_flat_deflate_.coordinatess(\n        this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {Array.<number>} ends Ends.\n */\n_ol_geom_Polygon_.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.ends_ = ends;\n  this.changed();\n};\n\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {ol.Sphere} sphere The sphere.\n * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @return {ol.geom.Polygon} The \"circular\" polygon.\n * @api\n */\n_ol_geom_Polygon_.circular = function(sphere, center, radius, opt_n) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array.<number>} */\n  var flatCoordinates = [];\n  var i;\n  for (i = 0; i < n; ++i) {\n    _ol_array_.extend(\n        flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, flatCoordinates, [flatCoordinates.length]);\n  return polygon;\n};\n\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {ol.Extent} extent The extent.\n * @return {ol.geom.Polygon} The polygon.\n * @api\n */\n_ol_geom_Polygon_.fromExtent = function(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates =\n      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, flatCoordinates, [flatCoordinates.length]);\n  return polygon;\n};\n\n\n/**\n * Create a regular polygon from a circle.\n * @param {ol.geom.Circle} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {ol.geom.Polygon} Polygon geometry.\n * @api\n */\n_ol_geom_Polygon_.fromCircle = function(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var polygon = new _ol_geom_Polygon_(null, layout);\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n  for (var i = 0; i < arrayLength; i++) {\n    flatCoordinates[i] = 0;\n  }\n  var ends = [flatCoordinates.length];\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n  _ol_geom_Polygon_.makeRegular(\n      polygon, circle.getCenter(), circle.getRadius(), opt_angle);\n  return polygon;\n};\n\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {ol.geom.Polygon} polygon Polygon geometry.\n * @param {ol.Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\n_ol_geom_Polygon_.makeRegular = function(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var layout = polygon.getLayout();\n  var stride = polygon.getStride();\n  var ends = polygon.getEnds();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n  var angle, offset;\n  for (var i = 0; i <= sides; ++i) {\n    offset = i * stride;\n    angle = startAngle + (_ol_math_.modulo(i, sides) * 2 * Math.PI / sides);\n    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));\n    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));\n  }\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n};\nexport default _ol_geom_Polygon_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/polygon.js\n// module id = 39\n// module chunks = 0","import _ol_ from './index';\nimport _ol_ObjectEventType_ from './objecteventtype';\nimport _ol_Observable_ from './observable';\nimport _ol_events_Event_ from './events/event';\nimport _ol_obj_ from './obj';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Most non-trivial classes inherit from this.\n *\n * This extends {@link ol.Observable} with observable properties, where each\n * property is observable as well as the object as a whole.\n *\n * Classes that inherit from this have pre-defined properties, to which you can\n * add your owns. The pre-defined properties are listed in this documentation as\n * 'Observable Properties', and have their own accessors; for example,\n * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and\n * changed with `setTarget()`. Not all properties are however settable. There\n * are also general-purpose accessors `get()` and `set()`. For example,\n * `get('target')` is equivalent to `getTarget()`.\n *\n * The `set` accessors trigger a change event, and you can monitor this by\n * registering a listener. For example, {@link ol.View} has a `center`\n * property, so `view.on('change:center', function(evt) {...});` would call the\n * function whenever the value of the center property changes. Within the\n * function, `evt.target` would be the view, so `evt.target.getCenter()` would\n * return the new center.\n *\n * You can add your own observable properties with\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n * You can listen for changes on that property value with\n * `object.on('change:prop', listener)`. You can get a list of all\n * properties with {@link ol.Object#getProperties object.getProperties()}.\n *\n * Note that the observable properties are separate from standard JS properties.\n * You can, for example, give your map object a title with\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n * first will be a `hasOwnProperty`; the second will appear in\n * `getProperties()`. Only the second is observable.\n *\n * Properties can be deleted by using the unset method. E.g.\n * object.unset('foo').\n *\n * @constructor\n * @extends {ol.Observable}\n * @param {Object.<string, *>=} opt_values An object with key-value pairs.\n * @fires ol.Object.Event\n * @api\n */\nvar _ol_Object_ = function(opt_values) {\n  _ol_Observable_.call(this);\n\n  // Call ol.getUid to ensure that the order of objects' ids is the same as\n  // the order in which they were created.  This also helps to ensure that\n  // object properties are always added in the same order, which helps many\n  // JavaScript engines generate faster code.\n  _ol_.getUid(this);\n\n  /**\n   * @private\n   * @type {!Object.<string, *>}\n   */\n  this.values_ = {};\n\n  if (opt_values !== undefined) {\n    this.setProperties(opt_values);\n  }\n};\n\n_ol_.inherits(_ol_Object_, _ol_Observable_);\n\n\n/**\n * @private\n * @type {Object.<string, string>}\n */\n_ol_Object_.changeEventTypeCache_ = {};\n\n\n/**\n * @param {string} key Key name.\n * @return {string} Change name.\n */\n_ol_Object_.getChangeEventType = function(key) {\n  return _ol_Object_.changeEventTypeCache_.hasOwnProperty(key) ?\n      _ol_Object_.changeEventTypeCache_[key] :\n      (_ol_Object_.changeEventTypeCache_[key] = 'change:' + key);\n};\n\n\n/**\n * Gets a value.\n * @param {string} key Key name.\n * @return {*} Value.\n * @api\n */\n_ol_Object_.prototype.get = function(key) {\n  var value;\n  if (this.values_.hasOwnProperty(key)) {\n    value = this.values_[key];\n  }\n  return value;\n};\n\n\n/**\n * Get a list of object property names.\n * @return {Array.<string>} List of property names.\n * @api\n */\n_ol_Object_.prototype.getKeys = function() {\n  return Object.keys(this.values_);\n};\n\n\n/**\n * Get an object of all property names and values.\n * @return {Object.<string, *>} Object.\n * @api\n */\n_ol_Object_.prototype.getProperties = function() {\n  return _ol_obj_.assign({}, this.values_);\n};\n\n\n/**\n * @param {string} key Key name.\n * @param {*} oldValue Old value.\n */\n_ol_Object_.prototype.notify = function(key, oldValue) {\n  var eventType;\n  eventType = _ol_Object_.getChangeEventType(key);\n  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));\n  eventType = _ol_ObjectEventType_.PROPERTYCHANGE;\n  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));\n};\n\n\n/**\n * Sets a value.\n * @param {string} key Key name.\n * @param {*} value Value.\n * @param {boolean=} opt_silent Update without triggering an event.\n * @api\n */\n_ol_Object_.prototype.set = function(key, value, opt_silent) {\n  if (opt_silent) {\n    this.values_[key] = value;\n  } else {\n    var oldValue = this.values_[key];\n    this.values_[key] = value;\n    if (oldValue !== value) {\n      this.notify(key, oldValue);\n    }\n  }\n};\n\n\n/**\n * Sets a collection of key-value pairs.  Note that this changes any existing\n * properties and adds new ones (it does not remove any existing properties).\n * @param {Object.<string, *>} values Values.\n * @param {boolean=} opt_silent Update without triggering an event.\n * @api\n */\n_ol_Object_.prototype.setProperties = function(values, opt_silent) {\n  var key;\n  for (key in values) {\n    this.set(key, values[key], opt_silent);\n  }\n};\n\n\n/**\n * Unsets a property.\n * @param {string} key Key name.\n * @param {boolean=} opt_silent Unset without triggering an event.\n * @api\n */\n_ol_Object_.prototype.unset = function(key, opt_silent) {\n  if (key in this.values_) {\n    var oldValue = this.values_[key];\n    delete this.values_[key];\n    if (!opt_silent) {\n      this.notify(key, oldValue);\n    }\n  }\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link ol.Object} instances are instances of this type.\n *\n * @param {string} type The event type.\n * @param {string} key The property name.\n * @param {*} oldValue The old value for `key`.\n * @extends {ol.events.Event}\n * @implements {oli.Object.Event}\n * @constructor\n */\n_ol_Object_.Event = function(type, key, oldValue) {\n  _ol_events_Event_.call(this, type);\n\n  /**\n   * The name of the property whose value is changing.\n   * @type {string}\n   * @api\n   */\n  this.key = key;\n\n  /**\n   * The old value. To get the new value use `e.target.get(e.key)` where\n   * `e` is the event object.\n   * @type {*}\n   * @api\n   */\n  this.oldValue = oldValue;\n\n};\n_ol_.inherits(_ol_Object_.Event, _ol_events_Event_);\nexport default _ol_Object_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/object.js\n// module id = 40\n// module chunks = 0","var _ol_proj_proj4_ = {};\n\n\n/**\n * @private\n * @type {Proj4}\n */\n_ol_proj_proj4_.cache_ = null;\n\n\n/**\n * Store the proj4 function.\n * @param {Proj4} proj4 The proj4 function.\n */\n_ol_proj_proj4_.set = function(proj4) {\n  _ol_proj_proj4_.cache_ = proj4;\n};\n\n\n/**\n * Get proj4.\n * @return {Proj4} The proj4 function set above or available globally.\n */\n_ol_proj_proj4_.get = function() {\n  return _ol_proj_proj4_.cache_ || window['proj4'];\n};\nexport default _ol_proj_proj4_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/proj4.js\n// module id = 41\n// module chunks = 0","/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\n\nimport _ol_math_ from './math';\n\n/**\n * @classdesc\n * Class to create objects that can be used with {@link\n * ol.geom.Polygon.circular}.\n *\n * For example to create a sphere whose radius is equal to the semi-major\n * axis of the WGS84 ellipsoid:\n *\n * ```js\n * var wgs84Sphere= new ol.Sphere(6378137);\n * ```\n *\n * @constructor\n * @param {number} radius Radius.\n * @api\n */\nvar _ol_Sphere_ = function(radius) {\n\n  /**\n   * @type {number}\n   */\n  this.radius = radius;\n\n};\n\n\n/**\n * Returns the geodesic area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @return {number} Area.\n * @api\n */\n_ol_Sphere_.prototype.geodesicArea = function(coordinates) {\n  var area = 0, len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0], y2 = coordinates[i][1];\n    area += _ol_math_.toRadians(x2 - x1) *\n        (2 + Math.sin(_ol_math_.toRadians(y1)) +\n        Math.sin(_ol_math_.toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * this.radius * this.radius / 2.0;\n};\n\n\n/**\n * Returns the distance from c1 to c2 using the haversine formula.\n *\n * @param {ol.Coordinate} c1 Coordinate 1.\n * @param {ol.Coordinate} c2 Coordinate 2.\n * @return {number} Haversine distance.\n * @api\n */\n_ol_Sphere_.prototype.haversineDistance = function(c1, c2) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n  var lat2 = _ol_math_.toRadians(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = _ol_math_.toRadians(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *\n      Math.cos(lat1) * Math.cos(lat2);\n  return 2 * this.radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n};\n\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @return {ol.Coordinate} The target point.\n */\n_ol_Sphere_.prototype.offset = function(c1, distance, bearing) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n  var lon1 = _ol_math_.toRadians(c1[0]);\n  var dByR = distance / this.radius;\n  var lat = Math.asin(\n      Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [_ol_math_.toDegrees(lon), _ol_math_.toDegrees(lat)];\n};\nexport default _ol_Sphere_;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/sphere.js\n// module id = 42\n// module chunks = 0","import _ol_Sphere_ from '../sphere';\n\n/**\n * The normal sphere.\n * @const\n * @type {ol.Sphere}\n */\nvar _ol_sphere_NORMAL_ = new _ol_Sphere_(6370997);\n\nexport default _ol_sphere_NORMAL_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/sphere/normal.js\n// module id = 43\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar shouldUtil = require('should-util');\nvar t = _interopDefault(require('should-type'));\n\n// TODO in future add generators instead of forEach and iterator implementation\n\n\nfunction ObjectIterator(obj) {\n  this._obj = obj;\n}\n\nObjectIterator.prototype = {\n  __shouldIterator__: true, // special marker\n\n  next: function() {\n    if (this._done) {\n      throw new Error('Iterator already reached the end');\n    }\n\n    if (!this._keys) {\n      this._keys = Object.keys(this._obj);\n      this._index = 0;\n    }\n\n    var key = this._keys[this._index];\n    this._done = this._index === this._keys.length;\n    this._index += 1;\n\n    return {\n      value: this._done ? void 0: [key, this._obj[key]],\n      done: this._done\n    };\n  }\n};\n\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  ObjectIterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n}\n\n\nfunction TypeAdaptorStorage() {\n  this._typeAdaptors = [];\n  this._iterableTypes = {};\n}\n\nTypeAdaptorStorage.prototype = {\n  add: function(type, cls, sub, adaptor) {\n    return this.addType(new t.Type(type, cls, sub), adaptor);\n  },\n\n  addType: function(type, adaptor) {\n    this._typeAdaptors[type.toString()] = adaptor;\n  },\n\n  getAdaptor: function(tp, funcName) {\n    var tries = tp.toTryTypes();\n    while (tries.length) {\n      var toTry = tries.shift();\n      var ad = this._typeAdaptors[toTry];\n      if (ad && ad[funcName]) {\n        return ad[funcName];\n      }\n    }\n  },\n\n  requireAdaptor: function(tp, funcName) {\n    var a = this.getAdaptor(tp, funcName);\n    if (!a) {\n      throw new Error('There is no type adaptor `' + funcName + '` for ' + tp.toString());\n    }\n    return a;\n  },\n\n  addIterableType: function(tp) {\n    this._iterableTypes[tp.toString()] = true;\n  },\n\n  isIterableType: function(tp) {\n    return !!this._iterableTypes[tp.toString()];\n  }\n};\n\nvar defaultTypeAdaptorStorage = new TypeAdaptorStorage();\n\nvar objectAdaptor = {\n  forEach: function(obj, f, context) {\n    for (var prop in obj) {\n      if (shouldUtil.hasOwnProperty(obj, prop) && shouldUtil.propertyIsEnumerable(obj, prop)) {\n        if (f.call(context, obj[prop], prop, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  has: function(obj, prop) {\n    return shouldUtil.hasOwnProperty(obj, prop);\n  },\n\n  get: function(obj, prop) {\n    return obj[prop];\n  },\n\n  iterator: function(obj) {\n    return new ObjectIterator(obj);\n  }\n};\n\n// default for objects\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT), objectAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.FUNCTION), objectAdaptor);\n\nvar mapAdaptor = {\n  has: function(obj, key) {\n    return obj.has(key);\n  },\n\n  get: function(obj, key) {\n    return obj.get(key);\n  },\n\n  forEach: function(obj, f, context) {\n    var iter = obj.entries();\n    forEach(iter, function(value) {\n      return f.call(context, value[1], value[0], obj);\n    });\n  },\n\n  size: function(obj) {\n    return obj.size;\n  },\n\n  isEmpty: function(obj) {\n    return obj.size === 0;\n  },\n\n  iterator: function(obj) {\n    return obj.entries();\n  }\n};\n\nvar setAdaptor = shouldUtil.merge({}, mapAdaptor);\nsetAdaptor.get = function(obj, key) {\n  if (obj.has(key)) {\n    return key;\n  }\n};\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.MAP), mapAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_MAP), mapAdaptor);\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.STRING), {\n  isEmpty: function(obj) {\n    return obj === '';\n  },\n\n  size: function(obj) {\n    return obj.length;\n  }\n});\n\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARRAY));\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARGUMENTS));\n\nfunction forEach(obj, f, context) {\n  if (shouldUtil.isGeneratorFunction(obj)) {\n    return forEach(obj(), f, context);\n  } else if (shouldUtil.isIterator(obj)) {\n    var value = obj.next();\n    while (!value.done) {\n      if (f.call(context, value.value, 'value', obj) === false) {\n        return;\n      }\n      value = obj.next();\n    }\n  } else {\n    var type = t(obj);\n    var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'forEach');\n    func(obj, f, context);\n  }\n}\n\n\nfunction size(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'size');\n  if (func) {\n    return func(obj);\n  } else {\n    var len = 0;\n    forEach(obj, function() {\n      len += 1;\n    });\n    return len;\n  }\n}\n\nfunction isEmpty(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'isEmpty');\n  if (func) {\n    return func(obj);\n  } else {\n    var res = true;\n    forEach(obj, function() {\n      res = false;\n      return false;\n    });\n    return res;\n  }\n}\n\n// return boolean if obj has such 'key'\nfunction has(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'has');\n  return func(obj, key);\n}\n\n// return value for given key\nfunction get(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'get');\n  return func(obj, key);\n}\n\nfunction reduce(obj, f, initialValue) {\n  var res = initialValue;\n  forEach(obj, function(value, key) {\n    res = f(res, value, key, obj);\n  });\n  return res;\n}\n\nfunction some(obj, f, context) {\n  var res = false;\n  forEach(obj, function(value, key) {\n    if (f.call(context, value, key, obj)) {\n      res = true;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction every(obj, f, context) {\n  var res = true;\n  forEach(obj, function(value, key) {\n    if (!f.call(context, value, key, obj)) {\n      res = false;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction isIterable(obj) {\n  return defaultTypeAdaptorStorage.isIterableType(t(obj));\n}\n\nfunction iterator(obj) {\n  return defaultTypeAdaptorStorage.requireAdaptor(t(obj), 'iterator')(obj);\n}\n\nexports.defaultTypeAdaptorStorage = defaultTypeAdaptorStorage;\nexports.forEach = forEach;\nexports.size = size;\nexports.isEmpty = isEmpty;\nexports.has = has;\nexports.get = get;\nexports.reduce = reduce;\nexports.some = some;\nexports.every = every;\nexports.isIterable = isIterable;\nexports.iterator = iterator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should-type-adaptors/cjs/should-type-adaptors.js\n// module id = 44\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction hasOwnProperty(obj, key) {\n  return _hasOwnProperty.call(obj, key);\n}\n\nfunction propertyIsEnumerable(obj, key) {\n  return _propertyIsEnumerable.call(obj, key);\n}\n\nfunction merge(a, b) {\n  if (a && b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n}\n\nfunction isIterator(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (obj.__shouldIterator__) {\n    return true;\n  }\n\n  return typeof obj.next === 'function' &&\n    typeof Symbol === 'function' &&\n    typeof Symbol.iterator === 'symbol' &&\n    typeof obj[Symbol.iterator] === 'function' &&\n    obj[Symbol.iterator]() === obj;\n}\n\n//TODO find better way\nfunction isGeneratorFunction(f) {\n  return typeof f === 'function' && /^function\\s*\\*\\s*/.test(f.toString());\n}\n\nexports.hasOwnProperty = hasOwnProperty;\nexports.propertyIsEnumerable = propertyIsEnumerable;\nexports.merge = merge;\nexports.isIterator = isIterator;\nexports.isGeneratorFunction = isGeneratorFunction;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should-util/cjs/should-util.js\n// module id = 45\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar getType = _interopDefault(require('should-type'));\nvar eql = _interopDefault(require('should-equal'));\nvar sformat = _interopDefault(require('should-format'));\nvar shouldTypeAdaptors = require('should-type-adaptors');\nvar shouldUtil = require('should-util');\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nfunction isWrapperType(obj) {\n  return obj instanceof Number ||\n    obj instanceof String ||\n    obj instanceof Boolean;\n}\n\n// XXX make it more strict: numbers, strings, symbols - and nothing else\nfunction convertPropertyName(name) {\n  return (typeof name === 'symbol') ? name : String(name);\n}\n\nvar functionName = sformat.functionName;\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar config = {\n  typeAdaptors: shouldTypeAdaptors.defaultTypeAdaptorStorage,\n\n  getFormatter: function(opts) {\n    return new sformat.Formatter(opts || config);\n  }\n};\n\nfunction format(value, opts) {\n  return config.getFormatter(opts).format(value);\n}\n\nfunction formatProp(value) {\n  var formatter = config.getFormatter();\n  return sformat.formatPlainObjectKey.call(formatter, value);\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * should AssertionError\n * @param {Object} options\n * @constructor\n * @memberOf should\n * @static\n */\nfunction AssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, 'message', {\n        get: function() {\n          if (!this._message) {\n            this._message = this.generateMessage();\n            this.generatedMessage = true;\n          }\n          return this._message;\n        },\n        configurable: true,\n        enumerable: false\n      }\n    );\n  }\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      if (this.stackStartFunction) {\n        // try to strip useless frames\n        var fn_name = functionName(this.stackStartFunction);\n        var idx = out.indexOf('\\n' + fn_name);\n        if (idx >= 0) {\n          // once we have located the function frame\n          // we need to strip out everything before it (and its line)\n          var next_line = out.indexOf('\\n', idx + 1);\n          out = out.substring(next_line + 1);\n        }\n      }\n\n      this.stack = out;\n    }\n  }\n}\n\n\nvar indent = '    ';\nfunction prependIndent(line) {\n  return indent + line;\n}\n\nfunction indentLines(text) {\n  return text.split('\\n').map(prependIndent).join('\\n');\n}\n\n\n// assert.AssertionError instanceof Error\nAssertionError.prototype = Object.create(Error.prototype, {\n  name: {\n    value: 'AssertionError'\n  },\n\n  generateMessage: {\n    value: function() {\n      if (!this.operator && this.previous) {\n        return this.previous.message;\n      }\n      var actual = format(this.actual);\n      var expected = 'expected' in this ? ' ' + format(this.expected) : '';\n      var details = 'details' in this && this.details ? ' (' + this.details + ')' : '';\n\n      var previous = this.previous ? '\\n' + indentLines(this.previous.message) : '';\n\n      return 'expected ' + actual + (this.negate ? ' not ' : ' ') + this.operator + expected + details + previous;\n    }\n  }\n});\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\n// a bit hacky way how to get error to do not have stack\nfunction LightAssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, 'message', {\n      get: function() {\n        if (!this._message) {\n          this._message = this.generateMessage();\n          this.generatedMessage = true;\n        }\n        return this._message;\n      }\n    });\n  }\n}\n\nLightAssertionError.prototype = {\n  generateMessage: AssertionError.prototype.generateMessage\n};\n\n\n/**\n * should Assertion\n * @param {*} obj Given object for assertion\n * @constructor\n * @memberOf should\n * @static\n */\nfunction Assertion(obj) {\n  this.obj = obj;\n\n  this.anyOne = false;\n  this.negate = false;\n\n  this.params = {actual: obj};\n}\n\nAssertion.prototype = {\n  constructor: Assertion,\n\n  /**\n   * Base method for assertions.\n   *\n   * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.\n   * `Assertion#params` can contain such properties:\n   * * `operator` - required string containing description of this assertion\n   * * `obj` - optional replacement for this.obj, it usefull if you prepare more clear object then given\n   * * `message` - if this property filled with string any others will be ignored and this one used as assertion message\n   * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)\n   * * `details` - additional string with details to generated message\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @param {*} expr Any expression that will be used as a condition for asserting.\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.assert(false);\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  assert: function(expr) {\n    if (expr) {\n      return this;\n    }\n\n    var params = this.params;\n\n    if ('obj' in params && !('actual' in params)) {\n      params.actual = params.obj;\n    } else if (!('obj' in params) && !('actual' in params)) {\n      params.actual = this.obj;\n    }\n\n    params.stackStartFunction = params.stackStartFunction || this.assert;\n    params.negate = this.negate;\n\n    params.assertion = this;\n\n    if (this.light) {\n      throw new LightAssertionError(params);\n    } else {\n      throw new AssertionError(params);\n    }\n  },\n\n  /**\n   * Shortcut for `Assertion#assert(false)`.\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.fail();\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  fail: function() {\n    return this.assert(false);\n  }\n};\n\n\n\n/**\n * Assertion used to delegate calls of Assertion methods inside of Promise.\n * It has almost all methods of Assertion.prototype\n *\n * @param {Promise} obj\n */\nfunction PromisedAssertion(/* obj */) {\n  Assertion.apply(this, arguments);\n}\n\n/**\n * Make PromisedAssertion to look like promise. Delegate resolve and reject to given promise.\n *\n * @private\n * @returns {Promise}\n */\nPromisedAssertion.prototype.then = function(resolve, reject) {\n  return this.obj.then(resolve, reject);\n};\n\n/**\n * Way to extend Assertion function. It uses some logic\n * to define only positive assertions and itself rule with negative assertion.\n *\n * All actions happen in subcontext and this method take care about negation.\n * Potentially we can add some more modifiers that does not depends from state of assertion.\n *\n * @memberOf Assertion\n * @static\n * @param {String} name Name of assertion. It will be used for defining method or getter on Assertion.prototype\n * @param {Function} func Function that will be called on executing assertion\n * @example\n *\n * Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' }\n *\n *      this.obj.should.have.property('id').which.is.a.Number()\n *      this.obj.should.have.property('path')\n * })\n */\nAssertion.add = function(name, func) {\n  Object.defineProperty(Assertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var context = new Assertion(this.obj, this, name);\n      context.anyOne = this.anyOne;\n      context.onlyThis = this.onlyThis;\n      // hack\n      context.light = true;\n\n      try {\n        func.apply(context, arguments);\n      } catch (e) {\n        // check for fail\n        if (e instanceof AssertionError || e instanceof LightAssertionError) {\n          // negative fail\n          if (this.negate) {\n            this.obj = context.obj;\n            this.negate = false;\n            return this;\n          }\n\n          if (context !== e.assertion) {\n            context.params.previous = e;\n          }\n\n          // positive fail\n          context.negate = false;\n          // hack\n          context.light = false;\n          context.fail();\n        }\n        // throw if it is another exception\n        throw e;\n      }\n\n      // negative pass\n      if (this.negate) {\n        context.negate = true; // because .fail will set negate\n        context.params.details = 'false negative fail';\n        // hack\n        context.light = false;\n        context.fail();\n      }\n\n      // positive pass\n      if (!this.params.operator) {\n        this.params = context.params; // shortcut\n      }\n      this.obj = context.obj;\n      this.negate = false;\n      return this;\n    }\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var args = arguments;\n      this.obj = this.obj.then(function(a) {\n        return a[name].apply(a, args);\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Add chaining getter to Assertion like .a, .which etc\n *\n * @memberOf Assertion\n * @static\n * @param  {string} name   name of getter\n * @param  {function} [onCall] optional function to call\n */\nAssertion.addChain = function(name, onCall) {\n  onCall = onCall || function() {};\n  Object.defineProperty(Assertion.prototype, name, {\n    get: function() {\n      onCall.call(this);\n      return this;\n    },\n    enumerable: true\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      this.obj = this.obj.then(function(a) {\n        return a[name];\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Create alias for some `Assertion` property\n *\n * @memberOf Assertion\n * @static\n * @param {String} from Name of to map\n * @param {String} to Name of alias\n * @example\n *\n * Assertion.alias('true', 'True')\n */\nAssertion.alias = function(from, to) {\n  var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);\n  if (!desc) {\n    throw new Error('Alias ' + from + ' -> ' + to + ' could not be created as ' + from + ' not defined');\n  }\n  Object.defineProperty(Assertion.prototype, to, desc);\n\n  var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);\n  if (desc2) {\n    Object.defineProperty(PromisedAssertion.prototype, to, desc2);\n  }\n};\n/**\n * Negation modifier. Current assertion chain become negated. Each call invert negation on current assertion.\n *\n * @name not\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('not', function() {\n  this.negate = !this.negate;\n});\n\n/**\n * Any modifier - it affect on execution of sequenced assertion to do not `check all`, but `check any of`.\n *\n * @name any\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('any', function() {\n  this.anyOne = true;\n});\n\n\n/**\n * Only modifier - currently used with .keys to check if object contains only exactly this .keys\n *\n * @name only\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('only', function() {\n  this.onlyThis = true;\n});\n\n// implement assert interface using already written peaces of should.js\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = ok;\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n/**\n * Node.js standard [`assert.fail`](http://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual Actual object\n * @param {*} expected Expected object\n * @param {string} message Message for assertion\n * @param {string} operator Operator text\n */\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  var a = new Assertion(actual);\n  a.params = {\n    operator: operator,\n    expected: expected,\n    message: message,\n    stackStartFunction: stackStartFunction || fail\n  };\n\n  a.fail();\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n/**\n * Node.js standard [`assert.ok`](http://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} value\n * @param {string} [message]\n */\nfunction ok(value, message) {\n  if (!value) {\n    fail(value, true, message, '==', assert.ok);\n  }\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\n/**\n * Node.js standard [`assert.equal`](http://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) {\n    fail(actual, expected, message, '==', assert.equal);\n  }\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notEqual`](http://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.deepEqual`](http://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (eql(actual, expected).length !== 0) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notDeepEqual`](http://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (eql(actual, expected).result) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.strictEqual`](http://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notStrictEqual`](http://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected == 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ')' : '.') +\n  (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n/**\n * Node.js standard [`assert.throws`](http://nodejs.org/api/assert.html#assert_assert_throws_block_error_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {Function} [error]\n * @param {String} [message]\n */\nassert.throws = function(/*block, error, message*/) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\n/**\n * Node.js standard [`assert.doesNotThrow`](http://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {String} [message]\n */\nassert.doesNotThrow = function(/*block, message*/) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\n/**\n * Node.js standard [`assert.ifError`](http://nodejs.org/api/assert.html#assert_assert_iferror_value).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Error} err\n */\nassert.ifError = function(err) {\n  if (err) {\n    throw err;\n  }\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar assertExtensions = function(should) {\n  var i = should.format;\n\n  /*\n   * Expose assert to should\n   *\n   * This allows you to do things like below\n   * without require()ing the assert module.\n   *\n   *    should.equal(foo.bar, undefined);\n   *\n   */\n  shouldUtil.merge(should, assert);\n\n  /**\n   * Assert _obj_ exists, with optional message.\n   *\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.exist(1);\n   * should.exist(new Date());\n   */\n  should.exist = should.exists = function(obj, msg) {\n    if (null == obj) {\n      throw new AssertionError({\n        message: msg || ('expected ' + i(obj) + ' to exist'), stackStartFunction: should.exist\n      });\n    }\n  };\n\n  should.not = {};\n  /**\n   * Asserts _obj_ does not exist, with optional message.\n   *\n   * @name not.exist\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.not.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.not.exist(null);\n   * should.not.exist(void 0);\n   */\n  should.not.exist = should.not.exists = function(obj, msg) {\n    if (null != obj) {\n      throw new AssertionError({\n        message: msg || ('expected ' + i(obj) + ' to not exist'), stackStartFunction: should.not.exist\n      });\n    }\n  };\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar chainAssertions = function(should, Assertion) {\n  /**\n   * Simple chaining to improve readability. Does nothing.\n   *\n   * @memberOf Assertion\n   * @name be\n   * @property {should.Assertion} be\n   * @alias Assertion#an\n   * @alias Assertion#of\n   * @alias Assertion#a\n   * @alias Assertion#and\n   * @alias Assertion#been\n   * @alias Assertion#have\n   * @alias Assertion#has\n   * @alias Assertion#with\n   * @alias Assertion#is\n   * @alias Assertion#which\n   * @alias Assertion#the\n   * @alias Assertion#it\n   * @category assertion chaining\n   */\n  ['an', 'of', 'a', 'and', 'be', 'been', 'has', 'have', 'with', 'is', 'which', 'the', 'it'].forEach(function(name) {\n    Assertion.addChain(name);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar booleanAssertions = function(should, Assertion) {\n  /**\n   * Assert given object is exactly `true`.\n   *\n   * @name true\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#True\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.be.true();\n   * false.should.not.be.true();\n   *\n   * ({ a: 10}).should.not.be.true();\n   */\n  Assertion.add('true', function(message) {\n    this.is.exactly(true, message);\n  });\n\n  Assertion.alias('true', 'True');\n\n  /**\n   * Assert given object is exactly `false`.\n   *\n   * @name false\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#False\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.not.be.false();\n   * false.should.be.false();\n   */\n  Assertion.add('false', function(message) {\n    this.is.exactly(false, message);\n  });\n\n  Assertion.alias('false', 'False');\n\n  /**\n   * Assert given object is truthy according javascript type conversions.\n   *\n   * @name ok\n   * @memberOf Assertion\n   * @category assertion bool\n   * @example\n   *\n   * (true).should.be.ok();\n   * ''.should.not.be.ok();\n   * should(null).not.be.ok();\n   * should(void 0).not.be.ok();\n   *\n   * (10).should.be.ok();\n   * (0).should.not.be.ok();\n   */\n  Assertion.add('ok', function() {\n    this.params = { operator: 'to be truthy' };\n\n    this.assert(this.obj);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar numberAssertions = function(should, Assertion) {\n\n  /**\n   * Assert given object is NaN\n   * @name NaN\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.NaN();\n   * NaN.should.be.NaN();\n   */\n  Assertion.add('NaN', function() {\n    this.params = { operator: 'to be NaN' };\n\n    this.assert(this.obj !== this.obj);\n  });\n\n  /**\n   * Assert given object is not finite (positive or negative)\n   *\n   * @name Infinity\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.Infinity();\n   * NaN.should.not.be.Infinity();\n   */\n  Assertion.add('Infinity', function() {\n    this.params = { operator: 'to be Infinity' };\n\n    this.is.a.Number()\n      .and.not.a.NaN()\n      .and.assert(!isFinite(this.obj));\n  });\n\n  /**\n   * Assert given number between `start` and `finish` or equal one of them.\n   *\n   * @name within\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} start Start number\n   * @param {number} finish Finish number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.within(0, 20);\n   */\n  Assertion.add('within', function(start, finish, description) {\n    this.params = { operator: 'to be within ' + start + '..' + finish, message: description };\n\n    this.assert(this.obj >= start && this.obj <= finish);\n  });\n\n  /**\n   * Assert given number near some other `value` within `delta`\n   *\n   * @name approximately\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} value Center number\n   * @param {number} delta Radius\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (9.99).should.be.approximately(10, 0.1);\n   */\n  Assertion.add('approximately', function(value, delta, description) {\n    this.params = { operator: 'to be approximately ' + value + ' ' + delta, message: description };\n\n    this.assert(Math.abs(this.obj - value) <= delta);\n  });\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name above\n   * @alias Assertion#greaterThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.above(0);\n   */\n  Assertion.add('above', function(n, description) {\n    this.params = { operator: 'to be above ' + n, message: description };\n\n    this.assert(this.obj > n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name below\n   * @alias Assertion#lessThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.below(10);\n   */\n  Assertion.add('below', function(n, description) {\n    this.params = { operator: 'to be below ' + n, message: description };\n\n    this.assert(this.obj < n);\n  });\n\n  Assertion.alias('above', 'greaterThan');\n  Assertion.alias('below', 'lessThan');\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name aboveOrEqual\n   * @alias Assertion#greaterThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.aboveOrEqual(0);\n   * (10).should.be.aboveOrEqual(10);\n   */\n  Assertion.add('aboveOrEqual', function(n, description) {\n    this.params = { operator: 'to be above or equal' + n, message: description };\n\n    this.assert(this.obj >= n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name belowOrEqual\n   * @alias Assertion#lessThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.belowOrEqual(10);\n   * (0).should.be.belowOrEqual(0);\n   */\n  Assertion.add('belowOrEqual', function(n, description) {\n    this.params = { operator: 'to be below or equal' + n, message: description };\n\n    this.assert(this.obj <= n);\n  });\n\n  Assertion.alias('aboveOrEqual', 'greaterThanOrEqual');\n  Assertion.alias('belowOrEqual', 'lessThanOrEqual');\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar typeAssertions = function(should, Assertion) {\n  /**\n   * Assert given object is number\n   * @name Number\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Number', function() {\n    this.params = {operator: 'to be a number'};\n\n    this.have.type('number');\n  });\n\n  /**\n   * Assert given object is arguments\n   * @name arguments\n   * @alias Assertion#Arguments\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('arguments', function() {\n    this.params = {operator: 'to be arguments'};\n\n    this.have.class('Arguments');\n  });\n\n  Assertion.alias('arguments', 'Arguments');\n\n  /**\n   * Assert given object has some type using `typeof`\n   * @name type\n   * @memberOf Assertion\n   * @param {string} type Type name\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add('type', function(type, description) {\n    this.params = {operator: 'to have type ' + type, message: description};\n\n    should(typeof this.obj).be.exactly(type);\n  });\n\n  /**\n   * Assert given object is instance of `constructor`\n   * @name instanceof\n   * @alias Assertion#instanceOf\n   * @memberOf Assertion\n   * @param {Function} constructor Constructor function\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add('instanceof', function(constructor, description) {\n    this.params = {operator: 'to be an instance of ' + functionName(constructor), message: description};\n\n    this.assert(Object(this.obj) instanceof constructor);\n  });\n\n  Assertion.alias('instanceof', 'instanceOf');\n\n  /**\n   * Assert given object is function\n   * @name Function\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Function', function() {\n    this.params = {operator: 'to be a function'};\n\n    this.have.type('function');\n  });\n\n  /**\n   * Assert given object is object\n   * @name Object\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Object', function() {\n    this.params = {operator: 'to be an object'};\n\n    this.is.not.null().and.have.type('object');\n  });\n\n  /**\n   * Assert given object is string\n   * @name String\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('String', function() {\n    this.params = {operator: 'to be a string'};\n\n    this.have.type('string');\n  });\n\n  /**\n   * Assert given object is array\n   * @name Array\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Array', function() {\n    this.params = {operator: 'to be an array'};\n\n    this.have.class('Array');\n  });\n\n  /**\n   * Assert given object is boolean\n   * @name Boolean\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Boolean', function() {\n    this.params = {operator: 'to be a boolean'};\n\n    this.have.type('boolean');\n  });\n\n  /**\n   * Assert given object is error\n   * @name Error\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Error', function() {\n    this.params = {operator: 'to be an error'};\n\n    this.have.instanceOf(Error);\n  });\n\n  /**\n   * Assert given object is a date\n   * @name Date\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Date', function() {\n    this.params = {operator: 'to be a date'};\n\n    this.have.instanceOf(Date);\n  });\n\n  /**\n   * Assert given object is null\n   * @name null\n   * @alias Assertion#Null\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('null', function() {\n    this.params = {operator: 'to be null'};\n\n    this.assert(this.obj === null);\n  });\n\n  Assertion.alias('null', 'Null');\n\n  /**\n   * Assert given object has some internal [[Class]], via Object.prototype.toString call\n   * @name class\n   * @alias Assertion#Class\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('class', function(cls) {\n    this.params = {operator: 'to have [[Class]] ' + cls};\n\n    this.assert(Object.prototype.toString.call(this.obj) === '[object ' + cls + ']');\n  });\n\n  Assertion.alias('class', 'Class');\n\n  /**\n   * Assert given object is undefined\n   * @name undefined\n   * @alias Assertion#Undefined\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('undefined', function() {\n    this.params = {operator: 'to be undefined'};\n\n    this.assert(this.obj === void 0);\n  });\n\n  Assertion.alias('undefined', 'Undefined');\n\n  /**\n   * Assert given object supports es6 iterable protocol (just check\n   * that object has property Symbol.iterator, which is a function)\n   * @name iterable\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('iterable', function() {\n    this.params = {operator: 'to be iterable'};\n\n    should(this.obj).have.property(Symbol.iterator).which.is.a.Function();\n  });\n\n  /**\n   * Assert given object supports es6 iterator protocol (just check\n   * that object has property next, which is a function)\n   * @name iterator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('iterator', function() {\n    this.params = {operator: 'to be iterator'};\n\n    should(this.obj).have.property('next').which.is.a.Function();\n  });\n\n  /**\n   * Assert given object is a generator object\n   * @name generator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('generator', function() {\n    this.params = {operator: 'to be generator'};\n\n    should(this.obj).be.iterable\n      .and.iterator\n      .and.it.is.equal(this.obj[Symbol.iterator]());\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction formatEqlResult(r, a, b) {\n  return ((r.path.length > 0 ? 'at ' + r.path.map(formatProp).join(' -> ') : '') +\n  (r.a === a ? '' : ', A has ' + format(r.a)) +\n  (r.b === b ? '' : ' and B has ' + format(r.b)) +\n  (r.showReason ? ' because ' + r.reason : '')).trim();\n}\n\nvar equalityAssertions = function(should, Assertion) {\n\n\n  /**\n   * Deep object equality comparison. For full spec see [`should-equal tests`](https://github.com/shouldjs/equal/blob/master/test.js).\n   *\n   * @name eql\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#deepEqual\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.eql(10);\n   * ('10').should.not.be.eql(10);\n   * (-0).should.not.be.eql(+0);\n   *\n   * NaN.should.be.eql(NaN);\n   *\n   * ({ a: 10}).should.be.eql({ a: 10 });\n   * [ 'a' ].should.not.be.eql({ '0': 'a' });\n   */\n  Assertion.add('eql', function(val, description) {\n    this.params = {operator: 'to equal', expected: val, message: description};\n    var obj = this.obj;\n    var fails = eql(this.obj, val, should.config);\n    this.params.details = fails.map(function(fail) {\n      return formatEqlResult(fail, obj, val);\n    }).join(', ');\n\n    this.params.showDiff = eql(getType(obj), getType(val)).length === 0;\n\n    this.assert(fails.length === 0);\n  });\n\n  /**\n   * Exact comparison using ===.\n   *\n   * @name equal\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#exactly\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 10.should.be.equal(10);\n   * 'a'.should.be.exactly('a');\n   *\n   * should(null).be.exactly(null);\n   */\n  Assertion.add('equal', function(val, description) {\n    this.params = {operator: 'to be', expected: val, message: description};\n\n    this.params.showDiff = eql(getType(this.obj), getType(val)).length === 0;\n\n    this.assert(val === this.obj);\n  });\n\n  Assertion.alias('equal', 'exactly');\n  Assertion.alias('eql', 'deepEqual');\n\n  function addOneOf(name, message, method) {\n    Assertion.add(name, function(vals) {\n      if (arguments.length !== 1) {\n        vals = Array.prototype.slice.call(arguments);\n      } else {\n        should(vals).be.Array();\n      }\n\n      this.params = {operator: message, expected: vals};\n\n      var obj = this.obj;\n      var found = false;\n\n      shouldTypeAdaptors.forEach(vals, function(val) {\n        try {\n          should(val)[method](obj);\n          found = true;\n          return false;\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            return;//do nothing\n          }\n          throw e;\n        }\n      });\n\n      this.assert(found);\n    });\n  }\n\n  /**\n   * Exact comparison using === to be one of supplied objects.\n   *\n   * @name equalOneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * 'ab'.should.be.equalOneOf('a', 10, 'ab');\n   * 'ab'.should.be.equalOneOf(['a', 10, 'ab']);\n   */\n  addOneOf('equalOneOf', 'to be equals one of', 'equal');\n\n  /**\n   * Exact comparison using .eql to be one of supplied objects.\n   *\n   * @name oneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * ({a: 10}).should.be.oneOf('a', 10, 'ab', {a: 10});\n   * ({a: 10}).should.be.oneOf(['a', 10, 'ab', {a: 10}]);\n   */\n  addOneOf('oneOf', 'to be one of', 'eql');\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar promiseAssertions = function(should, Assertion$$1) {\n  /**\n   * Assert given object is a Promise\n   *\n   * @name Promise\n   * @memberOf Assertion\n   * @category assertion promises\n   * @example\n   *\n   * promise.should.be.Promise()\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.a.Promise()\n   * (10).should.not.be.a.Promise()\n   */\n  Assertion$$1.add('Promise', function() {\n    this.params = {operator: 'to be promise'};\n\n    var obj = this.obj;\n\n    should(obj).have.property('then')\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given promise will be fulfilled. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilled\n   * @memberOf Assertion\n   * @returns {Promise}\n   * @category assertion promises\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.fulfilled();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.fulfilled();\n   * });\n   */\n  Assertion$$1.prototype.fulfilled = function Assertion$fulfilled() {\n    this.params = {operator: 'to be fulfilled'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function next$onResolve(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onReject(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejected\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.not.be.rejected();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => reject(new Error('boom')))\n   *      .should.be.rejected();\n   * });\n   */\n  Assertion$$1.prototype.rejected = function() {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.params.operator += ', but it was fulfilled';\n        if (arguments.length != 0) {\n          that.params.operator += ' with ' + should.format(value);\n        }\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be fulfilled with some expected value (value compared using .eql).\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilledWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.fulfilledWith(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => resolve(10))\n   *       .should.be.fulfilledWith(10);\n   * });\n   */\n  Assertion$$1.prototype.fulfilledWith = function(expectedValue) {\n    this.params = {operator: 'to be fulfilled with ' + should.format(expectedValue)};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      should(value).eql(expectedValue);\n      return value;\n    }, function next$onError(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected with some sort of error. Arguments is the same for Assertion#throw.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejectedWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * function failedPromise() {\n   *   return new Promise(function(resolve, reject) {\n   *     reject(new Error('boom'))\n   *   })\n   * }\n   * failedPromise().should.be.rejectedWith(Error);\n   * failedPromise().should.be.rejectedWith('boom');\n   * failedPromise().should.be.rejectedWith(/boom/);\n   * failedPromise().should.be.rejectedWith(Error, { message: 'boom' });\n   * failedPromise().should.be.rejectedWith({ message: 'boom' });\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return failedPromise().should.be.rejectedWith({ message: 'boom' });\n   * });\n   */\n  Assertion$$1.prototype.rejectedWith = function(message, properties) {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n\n      var errorMatched = true;\n      var errorInfo = '';\n\n      if ('string' === typeof message) {\n        errorMatched = message === err.message;\n      } else if (message instanceof RegExp) {\n        errorMatched = message.test(err.message);\n      } else if ('function' === typeof message) {\n        errorMatched = err instanceof message;\n      } else if (message !== null && typeof message === 'object') {\n        try {\n          should(err).match(message);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      if (!errorMatched) {\n        if ( typeof message === 'string' || message instanceof RegExp) {\n          errorInfo = ' with a message matching ' + should.format(message) + \", but got '\" + err.message + \"'\";\n        } else if ('function' === typeof message) {\n          errorInfo = ' of type ' + functionName(message) + ', but got ' + functionName(err.constructor);\n        }\n      } else if ('function' === typeof message && properties) {\n        try {\n          should(err).match(properties);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      that.params.operator += errorInfo;\n\n      that.assert(errorMatched);\n\n      return err;\n    });\n  };\n\n  /**\n   * Assert given object is promise and wrap it in PromisedAssertion, which has all properties of Assertion.\n   * That means you can chain as with usual Assertion.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name finally\n   * @memberOf Assertion\n   * @alias Assertion#eventually\n   * @category assertion promises\n   * @returns {PromisedAssertion} Like Assertion, but .then this.obj in Assertion\n   * @example\n   *\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.eventually.equal(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.finally.equal(10);\n   * });\n   */\n  Object.defineProperty(Assertion$$1.prototype, 'finally', {\n    get: function() {\n      should(this.obj).be.a.Promise();\n\n      var that = this;\n\n      return new PromisedAssertion(this.obj.then(function(obj) {\n        var a = should(obj);\n\n        a.negate = that.negate;\n        a.anyOne = that.anyOne;\n\n        return a;\n      }));\n    }\n  });\n\n  Assertion$$1.alias('finally', 'eventually');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar stringAssertions = function(should, Assertion) {\n  /**\n   * Assert given string starts with prefix\n   * @name startWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abc'.should.startWith('a');\n   */\n  Assertion.add('startWith', function(str, description) {\n    this.params = { operator: 'to start with ' + should.format(str), message: description };\n\n    this.assert(0 === this.obj.indexOf(str));\n  });\n\n  /**\n   * Assert given string ends with prefix\n   * @name endWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abca'.should.endWith('a');\n   */\n  Assertion.add('endWith', function(str, description) {\n    this.params = { operator: 'to end with ' + should.format(str), message: description };\n\n    this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar containAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert that given object contain something that equal to `other`. It uses `should-equal` for equality checks.\n   * If given object is array it search that one of elements was equal to `other`.\n   * If given object is string it checks if `other` is a substring - expected that `other` is a string.\n   * If given object is Object it checks that `other` is a subobject - expected that `other` is a object.\n   *\n   * @name containEql\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [1, 2, 3].should.containEql(1);\n   * [{ a: 1 }, 'a', 10].should.containEql({ a: 1 });\n   *\n   * 'abc'.should.containEql('b');\n   * 'ab1c'.should.containEql(1);\n   *\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ a: 10 });\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ c: { d: 10 }});\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ b: 10 });\n   * // throws AssertionError: expected { a: 10, c: { d: 10 } } to contain { b: 10 }\n   * //            expected { a: 10, c: { d: 10 } } to have property b\n   */\n  Assertion.add('containEql', function(other) {\n    this.params = { operator: 'to contain ' + i(other) };\n\n    this.is.not.null().and.not.undefined();\n\n    var obj = this.obj;\n\n    if (typeof obj == 'string') {\n      this.assert(obj.indexOf(String(other)) >= 0);\n    } else if (shouldTypeAdaptors.isIterable(obj)) {\n      this.assert(shouldTypeAdaptors.some(obj, function(v) {\n        return eql(v, other).length === 0;\n      }));\n    } else {\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj).have.value(key, value);\n      }, this);\n    }\n  });\n\n  /**\n   * Assert that given object is contain equally structured object on the same depth level.\n   * If given object is an array and `other` is an array it checks that the eql elements is going in the same sequence in given array (recursive)\n   * If given object is an object it checks that the same keys contain deep equal values (recursive)\n   * On other cases it try to check with `.eql`\n   *\n   * @name containDeepOrdered\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeepOrdered([1, 2]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeepOrdered([ 1, [ 2, 3 ]]);\n   *\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({a: 10});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {c: 10}});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {d: [1, 3]}});\n   */\n  Assertion.add('containDeepOrdered', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var objIterator = shouldTypeAdaptors.iterator(obj);\n      var otherIterator = shouldTypeAdaptors.iterator(other);\n\n      var nextObj = objIterator.next();\n      var nextOther = otherIterator.next();\n      while (!nextObj.done && !nextOther.done) {\n        try {\n          should(nextObj.value[1]).containDeepOrdered(nextOther.value[1]);\n          nextOther = otherIterator.next();\n        } catch (e) {\n          if (!(e instanceof should.AssertionError)) {\n            throw e;\n          }\n        }\n        nextObj = objIterator.next();\n      }\n\n      this.assert(nextOther.done);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {//TODO compare types object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeepOrdered(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n  /**\n   * The same like `Assertion#containDeepOrdered` but all checks on arrays without order.\n   *\n   * @name containDeep\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeep([2, 1]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeep([ 1, [ 3, 1 ]]);\n   */\n  Assertion.add('containDeep', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var usedKeys = {};\n      shouldTypeAdaptors.forEach(other, function(otherItem) {\n        this.assert(shouldTypeAdaptors.some(obj, function(item, index) {\n          if (index in usedKeys) {\n            return false;\n          }\n\n          try {\n            should(item).containDeep(otherItem);\n            usedKeys[index] = true;\n            return true;\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              return false;\n            }\n            throw e;\n          }\n        }));\n      }, this);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {// object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeep(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar aSlice = Array.prototype.slice;\n\nvar propertyAssertions = function(should, Assertion) {\n  var i = should.format;\n  /**\n   * Asserts given object has some descriptor. **On success it change given object to be value of property**.\n   *\n   * @name propertyWithDescriptor\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {Object} desc Descriptor like used in Object.defineProperty (not required to add all properties)\n   * @example\n   *\n   * ({ a: 10 }).should.have.propertyWithDescriptor('a', { enumerable: true });\n   */\n  Assertion.add('propertyWithDescriptor', function(name, desc) {\n    this.params = {actual: this.obj, operator: 'to have own property with descriptor ' + i(desc)};\n    var obj = this.obj;\n    this.have.ownProperty(name);\n    should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);\n  });\n\n  function processPropsArgs() {\n    var args = {};\n    if (arguments.length > 1) {\n      args.names = aSlice.call(arguments);\n    } else {\n      var arg = arguments[0];\n      if (typeof arg === 'string') {\n        args.names = [arg];\n      } else if (Array.isArray(arg)) {\n        args.names = arg;\n      } else {\n        args.names = Object.keys(arg);\n        args.values = arg;\n      }\n    }\n    return args;\n  }\n\n  Assertion.add('enumerable', function(name, val) {\n    name = convertPropertyName(name);\n\n    this.params = {\n      operator: \"to have enumerable property \" + formatProp(name) + (arguments.length > 1 ? \" equal to \" + i(val): \"\")\n    };\n\n    var desc = { enumerable: true };\n    if (arguments.length > 1) {\n      desc.value = val;\n    }\n    this.have.propertyWithDescriptor(name, desc);\n  });\n\n  Assertion.add('enumerables', function(/*names*/) {\n    var args = processPropsArgs.apply(null, arguments);\n\n    this.params = {\n      operator: \"to have enumerables \" + args.names.map(formatProp)\n    };\n\n    var obj = this.obj;\n    args.names.forEach(function(name) {\n      should(obj).have.enumerable(name);\n    });\n  });\n\n  /**\n   * Asserts given object has property with optionally value. **On success it change given object to be value of property**.\n   *\n   * @name property\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {*} [val] Optional property value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.property('a');\n   */\n  Assertion.add('property', function(name, val) {\n    name = convertPropertyName(name);\n    if (arguments.length > 1) {\n      var p = {};\n      p[name] = val;\n      this.have.properties(p);\n    } else {\n      this.have.properties(name);\n    }\n    this.obj = this.obj[name];\n  });\n\n  /**\n   * Asserts given object has properties. On this method affect .any modifier, which allow to check not all properties.\n   *\n   * @name properties\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string|Object} names Names of property\n   * @example\n   *\n   * ({ a: 10 }).should.have.properties('a');\n   * ({ a: 10, b: 20 }).should.have.properties([ 'a' ]);\n   * ({ a: 10, b: 20 }).should.have.properties({ b: 20 });\n   */\n  Assertion.add('properties', function(names) {\n    var values = {};\n    if (arguments.length > 1) {\n      names = aSlice.call(arguments);\n    } else if (!Array.isArray(names)) {\n      if (typeof names == 'string' || typeof names == 'symbol') {\n        names = [names];\n      } else {\n        values = names;\n        names = Object.keys(names);\n      }\n    }\n\n    var obj = Object(this.obj), missingProperties = [];\n\n    //just enumerate properties and check if they all present\n    names.forEach(function(name) {\n      if (!(name in obj)) {\n        missingProperties.push(formatProp(name));\n      }\n    });\n\n    var props = missingProperties;\n    if (props.length === 0) {\n      props = names.map(formatProp);\n    } else if (this.anyOne) {\n      props = names.filter(function(name) {\n        return missingProperties.indexOf(formatProp(name)) < 0;\n      }).map(formatProp);\n    }\n\n    var operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n    this.params = {obj: this.obj, operator: operator};\n\n    //check that all properties presented\n    //or if we request one of them that at least one them presented\n    this.assert(missingProperties.length === 0 || (this.anyOne && missingProperties.length != names.length));\n\n    // check if values in object matched expected\n    var valueCheckNames = Object.keys(values);\n    if (valueCheckNames.length) {\n      var wrongValues = [];\n      props = [];\n\n      // now check values, as there we have all properties\n      valueCheckNames.forEach(function(name) {\n        var value = values[name];\n        if (eql(obj[name], value).length !== 0) {\n          wrongValues.push(formatProp(name) + ' of ' + i(value) + ' (got ' + i(obj[name]) + ')');\n        } else {\n          props.push(formatProp(name) + ' of ' + i(value));\n        }\n      });\n\n      if ((wrongValues.length !== 0 && !this.anyOne) || (this.anyOne && props.length === 0)) {\n        props = wrongValues;\n      }\n\n      operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n      this.params = {obj: this.obj, operator: operator};\n\n      //if there is no not matched values\n      //or there is at least one matched\n      this.assert(wrongValues.length === 0 || (this.anyOne && wrongValues.length != valueCheckNames.length));\n    }\n  });\n\n  /**\n   * Asserts given object has property `length` with given value `n`\n   *\n   * @name length\n   * @alias Assertion#lengthOf\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} n Expected length\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * [1, 2].should.have.length(2);\n   */\n  Assertion.add('length', function(n, description) {\n    this.have.property('length', n, description);\n  });\n\n  Assertion.alias('length', 'lengthOf');\n\n  /**\n   * Asserts given object has own property. **On success it change given object to be value of property**.\n   *\n   * @name ownProperty\n   * @alias Assertion#hasOwnProperty\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * ({ a: 10 }).should.have.ownProperty('a');\n   */\n  Assertion.add('ownProperty', function(name, description) {\n    name = convertPropertyName(name);\n    this.params = {\n      actual: this.obj,\n      operator: 'to have own property ' + formatProp(name),\n      message: description\n    };\n\n    this.assert(shouldUtil.hasOwnProperty(this.obj, name));\n\n    this.obj = this.obj[name];\n  });\n\n  Assertion.alias('ownProperty', 'hasOwnProperty');\n\n  /**\n   * Asserts given object is empty. For strings, arrays and arguments it checks .length property, for objects it checks keys.\n   *\n   * @name empty\n   * @memberOf Assertion\n   * @category assertion property\n   * @example\n   *\n   * ''.should.be.empty();\n   * [].should.be.empty();\n   * ({}).should.be.empty();\n   */\n  Assertion.add('empty', function() {\n    this.params = {operator: 'to be empty'};\n    this.assert(shouldTypeAdaptors.isEmpty(this.obj));\n  }, true);\n\n  /**\n   * Asserts given object has such keys. Compared to `properties`, `keys` does not accept Object as a argument.\n   * When calling via .key current object in assertion changed to value of this key\n   *\n   * @name keys\n   * @alias Assertion#key\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {...*} keys Keys to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.keys('a');\n   * ({ a: 10, b: 20 }).should.have.keys('a', 'b');\n   * (new Map([[1, 2]])).should.have.key(1);\n   *\n   * json.should.have.only.keys('type', 'version')\n   */\n  Assertion.add('keys', function(keys) {\n    keys = aSlice.call(arguments);\n\n    var obj = Object(this.obj);\n\n    // first check if some keys are missing\n    var missingKeys = keys.filter(function(key) {\n      return !shouldTypeAdaptors.has(obj, key);\n    });\n\n    var verb = 'to have ' + (this.onlyThis ? 'only ': '') + (keys.length === 1 ? 'key ' : 'keys ');\n\n    this.params = {operator: verb + keys.join(', ')};\n\n    if (missingKeys.length > 0) {\n      this.params.operator += '\\n\\tmissing keys: ' + missingKeys.join(', ');\n    }\n\n    this.assert(missingKeys.length === 0);\n\n    if (this.onlyThis) {\n      obj.should.have.size(keys.length);\n    }\n  });\n\n\n  Assertion.add('key', function(key) {\n    this.have.keys(key);\n    this.obj = shouldTypeAdaptors.get(this.obj, key);\n  });\n\n  /**\n   * Asserts given object has such value for given key\n   *\n   * @name value\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {*} key Key to check\n   * @param {*} value Value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.value('a', 10);\n   * (new Map([[1, 2]])).should.have.value(1, 2);\n   */\n  Assertion.add('value', function(key, value) {\n    this.have.key(key).which.is.eql(value);\n  });\n\n  /**\n   * Asserts given object has such size.\n   *\n   * @name size\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} s Size to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.size(1);\n   * (new Map([[1, 2]])).should.have.size(1);\n   */\n  Assertion.add('size', function(s) {\n    this.params = { operator: 'to have size ' + s };\n    shouldTypeAdaptors.size(this.obj).should.be.exactly(s);\n  });\n\n  /**\n   * Asserts given object has nested property in depth by path. **On success it change given object to be value of final property**.\n   *\n   * @name propertyByPath\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string} properties Properties path to search\n   * @example\n   *\n   * ({ a: {b: 10}}).should.have.propertyByPath('a', 'b').eql(10);\n   */\n  Assertion.add('propertyByPath', function(properties) {\n    properties = aSlice.call(arguments);\n\n    var allProps = properties.map(formatProp);\n\n    properties = properties.map(convertPropertyName);\n\n    var obj = should(Object(this.obj));\n\n    var foundProperties = [];\n\n    var currentProperty;\n    while (properties.length) {\n      currentProperty = properties.shift();\n      this.params = {operator: 'to have property by path ' + allProps.join(', ') + ' - failed on ' + formatProp(currentProperty)};\n      obj = obj.have.property(currentProperty);\n      foundProperties.push(currentProperty);\n    }\n\n    this.params = {obj: this.obj, operator: 'to have property by path ' + allProps.join(', ')};\n\n    this.obj = obj.obj;\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nvar errorAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert given function throws error with such message.\n   *\n   * @name throw\n   * @memberOf Assertion\n   * @category assertion errors\n   * @alias Assertion#throwError\n   * @param {string|RegExp|Function|Object|GeneratorFunction|GeneratorObject} [message] Message to match or properties\n   * @param {Object} [properties] Optional properties that will be matched to thrown error\n   * @example\n   *\n   * (function(){ throw new Error('fail') }).should.throw();\n   * (function(){ throw new Error('fail') }).should.throw('fail');\n   * (function(){ throw new Error('fail') }).should.throw(/fail/);\n   *\n   * (function(){ throw new Error('fail') }).should.throw(Error);\n   * var error = new Error();\n   * error.a = 10;\n   * (function(){ throw error; }).should.throw(Error, { a: 10 });\n   * (function(){ throw error; }).should.throw({ a: 10 });\n   * (function*() {\n   *   yield throwError();\n   * }).should.throw();\n   */\n  Assertion.add('throw', function(message, properties) {\n    var fn = this.obj;\n    var err = {};\n    var errorInfo = '';\n    var thrown = false;\n\n    if (shouldUtil.isGeneratorFunction(fn)) {\n      return should(fn()).throw(message, properties);\n    } else if (shouldUtil.isIterator(fn)) {\n      return should(fn.next.bind(fn)).throw(message, properties);\n    }\n\n    this.is.a.Function();\n\n    var errorMatched = true;\n\n    try {\n      fn();\n    } catch (e) {\n      thrown = true;\n      err = e;\n    }\n\n    if (thrown) {\n      if (message) {\n        if ('string' == typeof message) {\n          errorMatched = message == err.message;\n        } else if (message instanceof RegExp) {\n          errorMatched = message.test(err.message);\n        } else if ('function' == typeof message) {\n          errorMatched = err instanceof message;\n        } else if (null != message) {\n          try {\n            should(err).match(message);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        if (!errorMatched) {\n          if ('string' == typeof message || message instanceof RegExp) {\n            errorInfo = \" with a message matching \" + i(message) + \", but got '\" + err.message + \"'\";\n          } else if ('function' == typeof message) {\n            errorInfo = \" of type \" + functionName(message) + \", but got \" + functionName(err.constructor);\n          }\n        } else if ('function' == typeof message && properties) {\n          try {\n            should(err).match(properties);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n      } else {\n        errorInfo = \" (got \" + i(err) + \")\";\n      }\n    }\n\n    this.params = { operator: 'to throw exception' + errorInfo };\n\n    this.assert(thrown);\n    this.assert(errorMatched);\n  });\n\n  Assertion.alias('throw', 'throwError');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar matchingAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Asserts if given object match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp and given object is a string check on matching with regexp\n   * If `other` is a regexp and given object is an array check if all elements matched regexp\n   * If `other` is a regexp and given object is an object check values on matching regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * If `other` is an object check if the same keys matched with above rules\n   * All other cases failed.\n   *\n   * Usually it is right idea to add pre type assertions, like `.String()` or `.Object()` to be sure assertions will do what you are expecting.\n   * Object iteration happen by keys (properties with enumerable: true), thus some objects can cause small pain. Typical example is js\n   * Error - it by default has 2 properties `name` and `message`, but they both non-enumerable. In this case make sure you specify checking props (see examples).\n   *\n   * @name match\n   * @memberOf Assertion\n   * @category assertion matching\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * 'foobar'.should.match(/^foo/);\n   * 'foobar'.should.not.match(/^bar/);\n   *\n   * ({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);\n   *\n   * ['a', 'b', 'c'].should.match(/[a-z]/);\n   *\n   * (5).should.not.match(function(n) {\n   *   return n < 0;\n   * });\n   * (5).should.not.match(function(it) {\n   *    it.should.be.an.Array();\n   * });\n   * ({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should\n   * .match({ a: 10, b: /c$/, c: function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * [10, 'abc', { d: 10 }, 0].should\n   * .match({ '0': 10, '1': /c$/, '2': function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * var myString = 'abc';\n   *\n   * myString.should.be.a.String().and.match(/abc/);\n   *\n   * myString = {};\n   *\n   * myString.should.match(/abc/); //yes this will pass\n   * //better to do\n   * myString.should.be.an.Object().and.not.empty().and.match(/abc/);//fixed\n   *\n   * (new Error('boom')).should.match(/abc/);//passed because no keys\n   * (new Error('boom')).should.not.match({ message: /abc/ });//check specified property\n   */\n  Assertion.add('match', function(other, description) {\n    this.params = {operator: 'to match ' + i(other), message: description};\n\n    if (eql(this.obj, other).length !== 0) {\n      if (other instanceof RegExp) { // something - regex\n\n        if (typeof this.obj == 'string') {\n\n          this.assert(other.exec(this.obj));\n        } else if (null != this.obj && typeof this.obj == 'object') {\n\n          var notMatchedProps = [], matchedProps = [];\n          shouldTypeAdaptors.forEach(this.obj, function(value, name) {\n            if (other.exec(value)) {\n              matchedProps.push(formatProp(name));\n            } else {\n              notMatchedProps.push(formatProp(name) + ' (' + i(value) + ')');\n            }\n          }, this);\n\n          if (notMatchedProps.length) {\n            this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n          }\n          if (matchedProps.length) {\n            this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n          }\n\n          this.assert(notMatchedProps.length === 0);\n        } // should we try to convert to String and exec?\n        else {\n          this.assert(false);\n        }\n      } else if (typeof other == 'function') {\n        var res;\n\n        res = other(this.obj);\n\n        //if we throw exception ok - it is used .should inside\n        if (typeof res == 'boolean') {\n          this.assert(res); // if it is just boolean function assert on it\n        }\n      } else if (other != null && this.obj != null && typeof other == 'object' && typeof this.obj == 'object') { // try to match properties (for Object and Array)\n        notMatchedProps = [];\n        matchedProps = [];\n\n        shouldTypeAdaptors.forEach(other, function(value, key) {\n          try {\n            should(this.obj).have.property(key).which.match(value);\n            matchedProps.push(formatProp(key));\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              notMatchedProps.push(formatProp(key) + ' (' + i(this.obj[key]) + ')');\n            } else {\n              throw e;\n            }\n          }\n        }, this);\n\n        if (notMatchedProps.length) {\n          this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n        }\n        if (matchedProps.length) {\n          this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n        }\n\n        this.assert(notMatchedProps.length === 0);\n      } else {\n        this.assert(false);\n      }\n    }\n  });\n\n  /**\n   * Asserts if given object values or array elements all match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp - matching with regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * All other cases check if this `other` equal to each element\n   *\n   * @name matchEach\n   * @memberOf Assertion\n   * @category assertion matching\n   * @alias Assertion#matchEvery\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * [ 'a', 'b', 'c'].should.matchEach(/\\w+/);\n   * [ 'a', 'a', 'a'].should.matchEach('a');\n   *\n   * [ 'a', 'a', 'a'].should.matchEach(function(value) { value.should.be.eql('a') });\n   *\n   * { a: 'a', b: 'a', c: 'a' }.should.matchEach(function(value) { value.should.be.eql('a') });\n   */\n  Assertion.add('matchEach', function(other, description) {\n    this.params = {operator: 'to match each ' + i(other), message: description};\n\n    shouldTypeAdaptors.forEach(this.obj, function(value) {\n      should(value).match(other);\n    }, this);\n  });\n\n  /**\n  * Asserts if any of given object values or array elements match `other` object, using some assumptions:\n  * First object matched if they are equal,\n  * If `other` is a regexp - matching with regexp\n  * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n  * All other cases check if this `other` equal to each element\n  *\n  * @name matchAny\n  * @memberOf Assertion\n  * @category assertion matching\n  * @param {*} other Object to match\n  * @alias Assertion#matchSome\n  * @param {string} [description] Optional message\n  * @example\n  * [ 'a', 'b', 'c'].should.matchAny(/\\w+/);\n  * [ 'a', 'b', 'c'].should.matchAny('a');\n  *\n  * [ 'a', 'b', 'c'].should.matchAny(function(value) { value.should.be.eql('a') });\n  *\n  * { a: 'a', b: 'b', c: 'c' }.should.matchAny(function(value) { value.should.be.eql('a') });\n  */\n  Assertion.add('matchAny', function(other, description) {\n    this.params = {operator: 'to match any ' + i(other), message: description};\n\n    this.assert(shouldTypeAdaptors.some(this.obj, function(value) {\n      try {\n        should(value).match(other);\n        return true;\n      } catch (e) {\n        if (e instanceof should.AssertionError) {\n          // Caught an AssertionError, return false to the iterator\n          return false;\n        }\n        throw e;\n      }\n    }));\n  });\n\n  Assertion.alias('matchAny', 'matchSome');\n  Assertion.alias('matchEach', 'matchEvery');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * Our function should\n *\n * @param {*} obj Object to assert\n * @returns {should.Assertion} Returns new Assertion for beginning assertion chain\n * @example\n *\n * var should = require('should');\n * should('abc').be.a.String();\n */\nfunction should(obj) {\n  return (new Assertion(obj));\n}\n\nshould.AssertionError = AssertionError;\nshould.Assertion = Assertion;\n\n// exposing modules dirty way\nshould.modules = {\n  format: sformat,\n  type: getType,\n  equal: eql\n};\nshould.format = format;\n\n/**\n * Object with configuration.\n * It contains such properties:\n * * `checkProtoEql` boolean - Affect if `.eql` will check objects prototypes\n * * `plusZeroAndMinusZeroEqual` boolean - Affect if `.eql` will treat +0 and -0 as equal\n * Also it can contain options for should-format.\n *\n * @type {Object}\n * @memberOf should\n * @static\n * @example\n *\n * var a = { a: 10 }, b = Object.create(null);\n * b.a = 10;\n *\n * a.should.be.eql(b);\n * //not throws\n *\n * should.config.checkProtoEql = true;\n * a.should.be.eql(b);\n * //throws AssertionError: expected { a: 10 } to equal { a: 10 } (because A and B have different prototypes)\n */\nshould.config = config;\n\n/**\n * Allow to extend given prototype with should property using given name. This getter will **unwrap** all standard wrappers like `Number`, `Boolean`, `String`.\n * Using `should(obj)` is the equivalent of using `obj.should` with known issues (like nulls and method calls etc).\n *\n * To add new assertions, need to use Assertion.add method.\n *\n * @param {string} [propertyName] Name of property to add. Default is `'should'`.\n * @param {Object} [proto] Prototype to extend with. Default is `Object.prototype`.\n * @memberOf should\n * @returns {{ name: string, descriptor: Object, proto: Object }} Descriptor enough to return all back\n * @static\n * @example\n *\n * var prev = should.extend('must', Object.prototype);\n *\n * 'abc'.must.startWith('a');\n *\n * var should = should.noConflict(prev);\n * should.not.exist(Object.prototype.must);\n */\nshould.extend = function(propertyName, proto) {\n  propertyName = propertyName || 'should';\n  proto = proto || Object.prototype;\n\n  var prevDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n\n  Object.defineProperty(proto, propertyName, {\n    set: function() {\n    },\n    get: function() {\n      return should(isWrapperType(this) ? this.valueOf() : this);\n    },\n    configurable: true\n  });\n\n  return { name: propertyName, descriptor: prevDescriptor, proto: proto };\n};\n\n/**\n * Delete previous extension. If `desc` missing it will remove default extension.\n *\n * @param {{ name: string, descriptor: Object, proto: Object }} [desc] Returned from `should.extend` object\n * @memberOf should\n * @returns {Function} Returns should function\n * @static\n * @example\n *\n * var should = require('should').noConflict();\n *\n * should(Object.prototype).not.have.property('should');\n *\n * var prev = should.extend('must', Object.prototype);\n * 'abc'.must.startWith('a');\n * should.noConflict(prev);\n *\n * should(Object.prototype).not.have.property('must');\n */\nshould.noConflict = function(desc) {\n  desc = desc || should._prevShould;\n\n  if (desc) {\n    delete desc.proto[desc.name];\n\n    if (desc.descriptor) {\n      Object.defineProperty(desc.proto, desc.name, desc.descriptor);\n    }\n  }\n  return should;\n};\n\n/**\n * Simple utility function for a bit more easier should assertion extension\n * @param {Function} f So called plugin function. It should accept 2 arguments: `should` function and `Assertion` constructor\n * @memberOf should\n * @returns {Function} Returns `should` function\n * @static\n * @example\n *\n * should.use(function(should, Assertion) {\n *   Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' };\n *\n *      this.obj.should.have.property('id').which.is.a.Number();\n *      this.obj.should.have.property('path');\n *  })\n * })\n */\nshould.use = function(f) {\n  f(should, should.Assertion);\n  return this;\n};\n\nshould\n  .use(assertExtensions)\n  .use(chainAssertions)\n  .use(booleanAssertions)\n  .use(numberAssertions)\n  .use(equalityAssertions)\n  .use(typeAssertions)\n  .use(stringAssertions)\n  .use(propertyAssertions)\n  .use(errorAssertions)\n  .use(matchingAssertions)\n  .use(containAssertions)\n  .use(promiseAssertions);\n\nmodule.exports = should;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should/cjs/should.js\n// module id = 46\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 47\n// module chunks = 0","var Assertion = require('should').Assertion;\nvar util = require('util');\n\nAssertion.add('approximatelyDeep', function (other, delta, description) {\n    this.params = {\n        operator: 'to be approximately deep close to ' + util.inspect(other) + ' (' + delta + ')',\n        message: description\n    };\n    goDeeper(this.obj, other, delta, this);\n});\n\nfunction goDeeper(actual, expected, maxDifference, assertion) {\n    if (typeof actual === 'number') {\n        return assertion.assert((actual === expected) || (Math.abs(actual - expected) <= maxDifference));\n    } else if (Array.isArray(actual)) {\n        var l = actual.length;\n        assertion.assert(l === expected.length);\n        for (var i = 0; i < l; i++) {\n            goDeeper(actual[i], expected[i], maxDifference, assertion);\n        }\n    } else {\n        // error for all other types\n        assertion.assert(false);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should-approximately-deep/index.js\n// module id = 48\n// module chunks = 0","module.exports = require('./cjs/should');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should/as-function.js\n// module id = 49\n// module chunks = 0","import along from '@turf/along';\nimport GeoJSON from 'ol/format/geojson';\nimport lineDistance from '@turf/line-distance';\n\nvar format = new GeoJSON();\n\nexport default function(line, distance) {\n  var turfLine = format.writeFeatureObject(line);\n  var length = lineDistance(turfLine, 'kilometers');\n  var points = [];\n  for (var i = 1, ii = length / distance; i <= ii; ++i) {\n    var turfPoint = along(turfLine, i * distance, 'kilometers');\n    var point = format.readFeature(turfPoint);\n    points.push(point);\n  }\n  return points;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./pointsalongline.js\n// module id = 50\n// module chunks = 0","var measureDistance = require('@turf/distance');\nvar point = require('@turf/helpers').point;\nvar bearing = require('@turf/bearing');\nvar destination = require('@turf/destination');\n\n/**\n * Takes a {@link LineString|line} and returns a {@link Point|point} at a specified distance along the line.\n *\n * @name along\n * @param {Feature<LineString>} line input line\n * @param {number} distance distance along the line\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} Point `distance` `units` along the line\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [[-83, 30], [-84, 36], [-78, 41]]\n *   }\n * };\n *\n * var along = turf.along(line, 200, 'miles');\n *\n * //addToMap\n * var addToMap = [along, line]\n */\nmodule.exports = function (line, distance, units) {\n    var coords;\n    if (line.type === 'Feature') coords = line.geometry.coordinates;\n    else if (line.type === 'LineString') coords = line.coordinates;\n    else throw new Error('input must be a LineString Feature or Geometry');\n\n    var travelled = 0;\n    for (var i = 0; i < coords.length; i++) {\n        if (distance >= travelled && i === coords.length - 1) break;\n        else if (travelled >= distance) {\n            var overshot = distance - travelled;\n            if (!overshot) return point(coords[i]);\n            else {\n                var direction = bearing(coords[i], coords[i - 1]) - 180;\n                var interpolated = destination(coords[i], overshot, direction, units);\n                return interpolated;\n            }\n        } else {\n            travelled += measureDistance(coords[i], coords[i + 1], units);\n        }\n    }\n    return point(coords[coords.length - 1]);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/along/index.js\n// module id = 51\n// module chunks = 0","var getCoord = require('@turf/invariant').getCoord;\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Geometry|Feature<Point>|Array<number>} start starting Point\n * @param {Geometry|Feature<Point>|Array<number>} end ending Point\n * @param {boolean} [final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.343, 39.984]\n *   }\n * };\n * var point2 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.534, 39.123]\n *   }\n * };\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\n\nfunction bearing(start, end, final) {\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degrees2radians * coordinates1[0];\n    var lon2 = degrees2radians * coordinates2[0];\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    var bear = radians2degrees * Math.atan2(a, b);\n\n    return bear;\n}\n\n/**\n * Calculates Final Bearing\n * @private\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nmodule.exports = bearing;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/bearing/index.js\n// module id = 52\n// module chunks = 0","//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\nvar getCoord = require('@turf/invariant').getCoord;\nvar helpers = require('@turf/helpers');\nvar point = helpers.point;\nvar distanceToRadians = helpers.distanceToRadians;\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Geometry|Feature<Point>|Array<number>} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {string} [units=kilometers] miles, kilometers, degrees, or radians\n * @returns {Feature<Point>} destination point\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.343, 39.984]\n *   }\n * };\n * var distance = 50;\n * var bearing = 90;\n * var units = 'miles';\n *\n * var destination = turf.destination(point, distance, bearing, units);\n *\n * //addToMap\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n * var addToMap = [point, destination]\n */\nmodule.exports = function (origin, distance, bearing, units) {\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degrees2radians * coordinates1[0];\n    var latitude1 = degrees2radians * coordinates1[1];\n    var bearing_rad = degrees2radians * bearing;\n\n    var radians = distanceToRadians(distance, units);\n\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) *\n        Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n\n    return point([radians2degrees * longitude2, radians2degrees * latitude2]);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/destination/index.js\n// module id = 53\n// module chunks = 0","var flattenEach = require('@turf/meta').flattenEach;\nvar featureCollection = require('@turf/helpers').featureCollection;\n\n/**\n * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).\n *\n * @name flatten\n * @param {FeatureCollection|Geometry|Feature<any>} geojson any valid GeoJSON Object\n * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features\n * @example\n * var multiGeometry = {\n *   \"type\": \"MultiPolygon\",\n *   \"coordinates\": [\n *      [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n *      [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n *      [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n *    ]\n *  };\n *\n * var flatten = turf.flatten(multiGeometry);\n *\n * //addToMap\n * var addToMap = [flatten]\n */\nfunction flatten(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        results.push(feature);\n    });\n    return featureCollection(results);\n}\nmodule.exports = flatten;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/flatten/index.js\n// module id = 54\n// module chunks = 0","var distance = require('@turf/distance');\nvar featureEach = require('@turf/meta').featureEach;\nvar coordReduce = require('@turf/meta').coordReduce;\nvar geomEach = require('@turf/meta').geomEach;\nvar flatten = require('@turf/flatten');\nvar lineString = require('@turf/helpers').lineString;\nvar point = require('@turf/helpers').point;\n\n/**\n * Takes a {@link LineString} or {@link Polygon} and measures its length in the specified units.\n *\n * @name lineDistance\n * @param {Feature<(LineString|Polygon)>|FeatureCollection<(LineString|Polygon)>} geojson feature to measure\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length feature\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n *\n * var length = turf.lineDistance(line, 'miles');\n *\n * //addToMap\n * line.properties.distance = length;\n * var addToMap = [line];\n */\nmodule.exports = function lineDistance(geojson, units) {\n    // Input Validation\n    if (!geojson) throw new Error('geojson is required');\n    geomEach(geojson, function (geometry) {\n        if (geometry.type === 'Point') throw new Error('geojson cannot be a Point');\n        if (geometry.type === 'MultiPoint') throw new Error('geojson cannot be a MultiPoint');\n    });\n\n    // Calculate distance from 2-vertex line segements\n    return segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        var start = point(coords[0]);\n        var end = point(coords[1]);\n        return previousValue + distance(start, end, units);\n    }, 0);\n};\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n *\n * @private\n * @param {FeatureCollection|Feature<any>} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, currentIndex)\n * @returns {void}\n * @example\n * var polygon = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]\n *   }\n * }\n * turf.segmentEach(polygon, function (segment) {\n *   //= segment\n * });\n */\nfunction segmentEach(geojson, callback) {\n    var count = 0;\n    featureEach(geojson, function (multiFeature) {\n        featureEach(flatten(multiFeature), function (feature) {\n            coordReduce(feature, function (previousCoords, currentCoords) {\n                var line = lineString([previousCoords, currentCoords], feature.properties);\n                callback(line, count);\n                count++;\n                return currentCoords;\n            });\n        });\n    });\n}\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n *\n * @private\n * @param {FeatureCollection|Feature<any>} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    segmentEach(geojson, function (currentSegment, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentSegment;\n        } else {\n            previousValue = callback(previousValue, currentSegment, currentIndex);\n        }\n    });\n    return previousValue;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@turf/line-distance/index.js\n// module id = 55\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 56\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 57\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 58\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 59\n// module chunks = 0","import _ol_ from './index';\n\n/**\n * Error object thrown when an assertion failed. This is an ECMA-262 Error,\n * extended with a `code` property.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\n * @constructor\n * @extends {Error}\n * @implements {oli.AssertionError}\n * @param {number} code Error code.\n */\nvar _ol_AssertionError_ = function(code) {\n\n  var path = _ol_.VERSION ? _ol_.VERSION.split('-')[0] : 'latest';\n\n  /**\n   * @type {string}\n   */\n  this.message = 'Assertion failed. See https://openlayers.org/en/' + path +\n      '/doc/errors/#' + code + ' for details.';\n\n  /**\n   * Error code. The meaning of the code can be found on\n   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with\n   * the version found in the OpenLayers script's header comment if a version\n   * other than the latest is used).\n   * @type {number}\n   * @api\n   */\n  this.code = code;\n\n  this.name = 'AssertionError';\n\n};\n\n_ol_.inherits(_ol_AssertionError_, Error);\nexport default _ol_AssertionError_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/assertionerror.js\n// module id = 60\n// module chunks = 0","import _ol_color_ from './color';\nvar _ol_colorlike_ = {};\n\n\n/**\n * @param {ol.Color|ol.ColorLike} color Color.\n * @return {ol.ColorLike} The color as an ol.ColorLike\n * @api\n */\n_ol_colorlike_.asColorLike = function(color) {\n  if (_ol_colorlike_.isColorLike(color)) {\n    return /** @type {string|CanvasPattern|CanvasGradient} */ (color);\n  } else {\n    return _ol_color_.asString(/** @type {ol.Color} */ (color));\n  }\n};\n\n\n/**\n * @param {?} color The value that is potentially an ol.ColorLike\n * @return {boolean} Whether the color is an ol.ColorLike\n */\n_ol_colorlike_.isColorLike = function(color) {\n  return (\n      typeof color === 'string' ||\n      color instanceof CanvasPattern ||\n      color instanceof CanvasGradient\n  );\n};\nexport default _ol_colorlike_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/colorlike.js\n// module id = 61\n// module chunks = 0","import _ol_ from './index';\n\n/**\n * Objects that need to clean up after themselves.\n * @constructor\n */\nvar _ol_Disposable_ = function() {};\n\n/**\n * The object has already been disposed.\n * @type {boolean}\n * @private\n */\n_ol_Disposable_.prototype.disposed_ = false;\n\n/**\n * Clean up.\n */\n_ol_Disposable_.prototype.dispose = function() {\n  if (!this.disposed_) {\n    this.disposed_ = true;\n    this.disposeInternal();\n  }\n};\n\n/**\n * Extension point for disposable objects.\n * @protected\n */\n_ol_Disposable_.prototype.disposeInternal = _ol_.nullFunction;\nexport default _ol_Disposable_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/disposable.js\n// module id = 62\n// module chunks = 0","var _ol_dom_ = {};\n\n\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number=} opt_width Canvas width.\n * @param {number=} opt_height Canvas height.\n * @return {CanvasRenderingContext2D} The context.\n */\n_ol_dom_.createCanvasContext2D = function(opt_width, opt_height) {\n  var canvas = document.createElement('CANVAS');\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n  if (opt_height) {\n    canvas.height = opt_height;\n  }\n  return canvas.getContext('2d');\n};\n\n\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!Element} element Element.\n * @return {number} The width.\n */\n_ol_dom_.outerWidth = function(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n\n  return width;\n};\n\n\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!Element} element Element.\n * @return {number} The height.\n */\n_ol_dom_.outerHeight = function(element) {\n  var height = element.offsetHeight;\n  var style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n\n  return height;\n};\n\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\n_ol_dom_.replaceNode = function(newNode, oldNode) {\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n};\n\n/**\n * @param {Node} node The node to remove.\n * @returns {Node} The node that was removed or null.\n */\n_ol_dom_.removeNode = function(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n};\n\n/**\n * @param {Node} node The node to remove the children from.\n */\n_ol_dom_.removeChildren = function(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n};\nexport default _ol_dom_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/dom.js\n// module id = 63\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_Disposable_ from '../disposable';\nimport _ol_events_ from '../events';\nimport _ol_events_Event_ from '../events/event';\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n *\n * @constructor\n * @extends {ol.Disposable}\n */\nvar _ol_events_EventTarget_ = function() {\n\n  _ol_Disposable_.call(this);\n\n  /**\n   * @private\n   * @type {!Object.<string, number>}\n   */\n  this.pendingRemovals_ = {};\n\n  /**\n   * @private\n   * @type {!Object.<string, number>}\n   */\n  this.dispatching_ = {};\n\n  /**\n   * @private\n   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}\n   */\n  this.listeners_ = {};\n\n};\n\n_ol_.inherits(_ol_events_EventTarget_, _ol_Disposable_);\n\n\n/**\n * @param {string} type Type.\n * @param {ol.EventsListenerFunctionType} listener Listener.\n */\n_ol_events_EventTarget_.prototype.addEventListener = function(type, listener) {\n  var listeners = this.listeners_[type];\n  if (!listeners) {\n    listeners = this.listeners_[type] = [];\n  }\n  if (listeners.indexOf(listener) === -1) {\n    listeners.push(listener);\n  }\n};\n\n\n/**\n * @param {{type: string,\n *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|\n *     string} event Event or event type.\n * @return {boolean|undefined} `false` if anyone called preventDefault on the\n *     event object or if any of the listeners returned false.\n */\n_ol_events_EventTarget_.prototype.dispatchEvent = function(event) {\n  var evt = typeof event === 'string' ? new _ol_events_Event_(event) : event;\n  var type = evt.type;\n  evt.target = this;\n  var listeners = this.listeners_[type];\n  var propagate;\n  if (listeners) {\n    if (!(type in this.dispatching_)) {\n      this.dispatching_[type] = 0;\n      this.pendingRemovals_[type] = 0;\n    }\n    ++this.dispatching_[type];\n    for (var i = 0, ii = listeners.length; i < ii; ++i) {\n      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    --this.dispatching_[type];\n    if (this.dispatching_[type] === 0) {\n      var pendingRemovals = this.pendingRemovals_[type];\n      delete this.pendingRemovals_[type];\n      while (pendingRemovals--) {\n        this.removeEventListener(type, _ol_.nullFunction);\n      }\n      delete this.dispatching_[type];\n    }\n    return propagate;\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_events_EventTarget_.prototype.disposeInternal = function() {\n  _ol_events_.unlistenAll(this);\n};\n\n\n/**\n * Get the listeners for a specified event type. Listeners are returned in the\n * order that they will be called in.\n *\n * @param {string} type Type.\n * @return {Array.<ol.EventsListenerFunctionType>} Listeners.\n */\n_ol_events_EventTarget_.prototype.getListeners = function(type) {\n  return this.listeners_[type];\n};\n\n\n/**\n * @param {string=} opt_type Type. If not provided,\n *     `true` will be returned if this EventTarget has any listeners.\n * @return {boolean} Has listeners.\n */\n_ol_events_EventTarget_.prototype.hasListener = function(opt_type) {\n  return opt_type ?\n      opt_type in this.listeners_ :\n      Object.keys(this.listeners_).length > 0;\n};\n\n\n/**\n * @param {string} type Type.\n * @param {ol.EventsListenerFunctionType} listener Listener.\n */\n_ol_events_EventTarget_.prototype.removeEventListener = function(type, listener) {\n  var listeners = this.listeners_[type];\n  if (listeners) {\n    var index = listeners.indexOf(listener);\n    if (type in this.pendingRemovals_) {\n      // make listener a no-op, and remove later in #dispatchEvent()\n      listeners[index] = _ol_.nullFunction;\n      ++this.pendingRemovals_[type];\n    } else {\n      listeners.splice(index, 1);\n      if (listeners.length === 0) {\n        delete this.listeners_[type];\n      }\n    }\n  }\n};\nexport default _ol_events_EventTarget_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/events/eventtarget.js\n// module id = 64\n// module chunks = 0","/**\n * Extent corner.\n * @enum {string}\n */\nvar _ol_extent_Corner_ = {\n  BOTTOM_LEFT: 'bottom-left',\n  BOTTOM_RIGHT: 'bottom-right',\n  TOP_LEFT: 'top-left',\n  TOP_RIGHT: 'top-right'\n};\n\nexport default _ol_extent_Corner_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/extent/corner.js\n// module id = 65\n// module chunks = 0","/**\n * Relationship to an extent.\n * @enum {number}\n */\nvar _ol_extent_Relationship_ = {\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16\n};\n\nexport default _ol_extent_Relationship_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/extent/relationship.js\n// module id = 66\n// module chunks = 0","/**\n * @enum {string}\n */\nvar _ol_format_FormatType_ = {\n  ARRAY_BUFFER: 'arraybuffer',\n  JSON: 'json',\n  TEXT: 'text',\n  XML: 'xml'\n};\n\nexport default _ol_format_FormatType_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/format/formattype.js\n// module id = 67\n// module chunks = 0","// TODO: serialize dataProjection as crs member when writing\n// see https://github.com/openlayers/openlayers/issues/2078\n\nimport _ol_ from '../index';\nimport _ol_asserts_ from '../asserts';\nimport _ol_Feature_ from '../feature';\nimport _ol_format_Feature_ from '../format/feature';\nimport _ol_format_JSONFeature_ from '../format/jsonfeature';\nimport _ol_geom_GeometryCollection_ from '../geom/geometrycollection';\nimport _ol_geom_LineString_ from '../geom/linestring';\nimport _ol_geom_MultiLineString_ from '../geom/multilinestring';\nimport _ol_geom_MultiPoint_ from '../geom/multipoint';\nimport _ol_geom_MultiPolygon_ from '../geom/multipolygon';\nimport _ol_geom_Point_ from '../geom/point';\nimport _ol_geom_Polygon_ from '../geom/polygon';\nimport _ol_obj_ from '../obj';\nimport _ol_proj_ from '../proj';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @constructor\n * @extends {ol.format.JSONFeature}\n * @param {olx.format.GeoJSONOptions=} opt_options Options.\n * @api\n */\nvar _ol_format_GeoJSON_ = function(opt_options) {\n\n  var options = opt_options ? opt_options : {};\n\n  _ol_format_JSONFeature_.call(this);\n\n  /**\n   * @inheritDoc\n   */\n  this.defaultDataProjection = _ol_proj_.get(\n      options.defaultDataProjection ?\n          options.defaultDataProjection : 'EPSG:4326');\n\n\n  if (options.featureProjection) {\n    this.defaultFeatureProjection = _ol_proj_.get(options.featureProjection);\n  }\n\n  /**\n   * Name of the geometry attribute for features.\n   * @type {string|undefined}\n   * @private\n   */\n  this.geometryName_ = options.geometryName;\n\n};\n\n_ol_.inherits(_ol_format_GeoJSON_, _ol_format_JSONFeature_);\n\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @private\n * @return {ol.geom.Geometry} Geometry.\n */\n_ol_format_GeoJSON_.readGeometry_ = function(object, opt_options) {\n  if (!object) {\n    return null;\n  }\n  var geometryReader = _ol_format_GeoJSON_.GEOMETRY_READERS_[object.type];\n  return /** @type {ol.geom.Geometry} */ (\n      _ol_format_Feature_.transformWithOptions(\n          geometryReader(object), false, opt_options));\n};\n\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @private\n * @return {ol.geom.GeometryCollection} Geometry collection.\n */\n_ol_format_GeoJSON_.readGeometryCollectionGeometry_ = function(\n    object, opt_options) {\n  var geometries = object.geometries.map(\n      /**\n       * @param {GeoJSONGeometry} geometry Geometry.\n       * @return {ol.geom.Geometry} geometry Geometry.\n       */\n      function(geometry) {\n        return _ol_format_GeoJSON_.readGeometry_(geometry, opt_options);\n      });\n  return new _ol_geom_GeometryCollection_(geometries);\n};\n\n\n/**\n * @param {GeoJSONGeometry} object Object.\n * @private\n * @return {ol.geom.Point} Point.\n */\n_ol_format_GeoJSON_.readPointGeometry_ = function(object) {\n  return new _ol_geom_Point_(object.coordinates);\n};\n\n\n/**\n * @param {GeoJSONGeometry} object Object.\n * @private\n * @return {ol.geom.LineString} LineString.\n */\n_ol_format_GeoJSON_.readLineStringGeometry_ = function(object) {\n  return new _ol_geom_LineString_(object.coordinates);\n};\n\n\n/**\n * @param {GeoJSONGeometry} object Object.\n * @private\n * @return {ol.geom.MultiLineString} MultiLineString.\n */\n_ol_format_GeoJSON_.readMultiLineStringGeometry_ = function(object) {\n  return new _ol_geom_MultiLineString_(object.coordinates);\n};\n\n\n/**\n * @param {GeoJSONGeometry} object Object.\n * @private\n * @return {ol.geom.MultiPoint} MultiPoint.\n */\n_ol_format_GeoJSON_.readMultiPointGeometry_ = function(object) {\n  return new _ol_geom_MultiPoint_(object.coordinates);\n};\n\n\n/**\n * @param {GeoJSONGeometry} object Object.\n * @private\n * @return {ol.geom.MultiPolygon} MultiPolygon.\n */\n_ol_format_GeoJSON_.readMultiPolygonGeometry_ = function(object) {\n  return new _ol_geom_MultiPolygon_(object.coordinates);\n};\n\n\n/**\n * @param {GeoJSONGeometry} object Object.\n * @private\n * @return {ol.geom.Polygon} Polygon.\n */\n_ol_format_GeoJSON_.readPolygonGeometry_ = function(object) {\n  return new _ol_geom_Polygon_(object.coordinates);\n};\n\n\n/**\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writeGeometry_ = function(geometry, opt_options) {\n  var geometryWriter = _ol_format_GeoJSON_.GEOMETRY_WRITERS_[geometry.getType()];\n  return geometryWriter(/** @type {ol.geom.Geometry} */ (\n      _ol_format_Feature_.transformWithOptions(geometry, true, opt_options)),\n      opt_options);\n};\n\n\n/**\n * @param {ol.geom.Geometry} geometry Geometry.\n * @private\n * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.\n */\n_ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_ = function(geometry) {\n  return /** @type {GeoJSONGeometryCollection} */ ({\n    type: 'GeometryCollection',\n    geometries: []\n  });\n};\n\n\n/**\n * @param {ol.geom.GeometryCollection} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\n_ol_format_GeoJSON_.writeGeometryCollectionGeometry_ = function(\n    geometry, opt_options) {\n  var geometries = geometry.getGeometriesArray().map(function(geometry) {\n    var options = _ol_obj_.assign({}, opt_options);\n    delete options.featureProjection;\n    return _ol_format_GeoJSON_.writeGeometry_(geometry, options);\n  });\n  return /** @type {GeoJSONGeometryCollection} */ ({\n    type: 'GeometryCollection',\n    geometries: geometries\n  });\n};\n\n\n/**\n * @param {ol.geom.LineString} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writeLineStringGeometry_ = function(geometry, opt_options) {\n  return /** @type {GeoJSONGeometry} */ ({\n    type: 'LineString',\n    coordinates: geometry.getCoordinates()\n  });\n};\n\n\n/**\n * @param {ol.geom.MultiLineString} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writeMultiLineStringGeometry_ = function(geometry, opt_options) {\n  return /** @type {GeoJSONGeometry} */ ({\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates()\n  });\n};\n\n\n/**\n * @param {ol.geom.MultiPoint} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writeMultiPointGeometry_ = function(geometry, opt_options) {\n  return /** @type {GeoJSONGeometry} */ ({\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates()\n  });\n};\n\n\n/**\n * @param {ol.geom.MultiPolygon} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writeMultiPolygonGeometry_ = function(geometry, opt_options) {\n  var right;\n  if (opt_options) {\n    right = opt_options.rightHanded;\n  }\n  return /** @type {GeoJSONGeometry} */ ({\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right)\n  });\n};\n\n\n/**\n * @param {ol.geom.Point} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writePointGeometry_ = function(geometry, opt_options) {\n  return /** @type {GeoJSONGeometry} */ ({\n    type: 'Point',\n    coordinates: geometry.getCoordinates()\n  });\n};\n\n\n/**\n * @param {ol.geom.Polygon} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @private\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n_ol_format_GeoJSON_.writePolygonGeometry_ = function(geometry, opt_options) {\n  var right;\n  if (opt_options) {\n    right = opt_options.rightHanded;\n  }\n  return /** @type {GeoJSONGeometry} */ ({\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right)\n  });\n};\n\n\n/**\n * @const\n * @private\n * @type {Object.<string, function(GeoJSONObject): ol.geom.Geometry>}\n */\n_ol_format_GeoJSON_.GEOMETRY_READERS_ = {\n  'Point': _ol_format_GeoJSON_.readPointGeometry_,\n  'LineString': _ol_format_GeoJSON_.readLineStringGeometry_,\n  'Polygon': _ol_format_GeoJSON_.readPolygonGeometry_,\n  'MultiPoint': _ol_format_GeoJSON_.readMultiPointGeometry_,\n  'MultiLineString': _ol_format_GeoJSON_.readMultiLineStringGeometry_,\n  'MultiPolygon': _ol_format_GeoJSON_.readMultiPolygonGeometry_,\n  'GeometryCollection': _ol_format_GeoJSON_.readGeometryCollectionGeometry_\n};\n\n\n/**\n * @const\n * @private\n * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}\n */\n_ol_format_GeoJSON_.GEOMETRY_WRITERS_ = {\n  'Point': _ol_format_GeoJSON_.writePointGeometry_,\n  'LineString': _ol_format_GeoJSON_.writeLineStringGeometry_,\n  'Polygon': _ol_format_GeoJSON_.writePolygonGeometry_,\n  'MultiPoint': _ol_format_GeoJSON_.writeMultiPointGeometry_,\n  'MultiLineString': _ol_format_GeoJSON_.writeMultiLineStringGeometry_,\n  'MultiPolygon': _ol_format_GeoJSON_.writeMultiPolygonGeometry_,\n  'GeometryCollection': _ol_format_GeoJSON_.writeGeometryCollectionGeometry_,\n  'Circle': _ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_\n};\n\n\n/**\n * Read a feature from a GeoJSON Feature source.  Only works for Feature or\n * geometry types.  Use {@link ol.format.GeoJSON#readFeatures} to read\n * FeatureCollection source.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.Feature} Feature.\n * @api\n */\n_ol_format_GeoJSON_.prototype.readFeature;\n\n\n/**\n * Read all features from a GeoJSON source.  Works for all GeoJSON types.\n * If the source includes only geometries, features will be created with those\n * geometries.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {Array.<ol.Feature>} Features.\n * @api\n */\n_ol_format_GeoJSON_.prototype.readFeatures;\n\n\n/**\n * @inheritDoc\n */\n_ol_format_GeoJSON_.prototype.readFeatureFromObject = function(\n    object, opt_options) {\n  /**\n   * @type {GeoJSONFeature}\n   */\n  var geoJSONFeature = null;\n  if (object.type === 'Feature') {\n    geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n  } else {\n    geoJSONFeature = /** @type {GeoJSONFeature} */ ({\n      type: 'Feature',\n      geometry: /** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */ (object)\n    });\n  }\n\n  var geometry = _ol_format_GeoJSON_.readGeometry_(geoJSONFeature.geometry, opt_options);\n  var feature = new _ol_Feature_();\n  if (this.geometryName_) {\n    feature.setGeometryName(this.geometryName_);\n  }\n  feature.setGeometry(geometry);\n  if (geoJSONFeature.id !== undefined) {\n    feature.setId(geoJSONFeature.id);\n  }\n  if (geoJSONFeature.properties) {\n    feature.setProperties(geoJSONFeature.properties);\n  }\n  return feature;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_GeoJSON_.prototype.readFeaturesFromObject = function(\n    object, opt_options) {\n  var geoJSONObject = /** @type {GeoJSONObject} */ (object);\n  /** @type {Array.<ol.Feature>} */\n  var features = null;\n  if (geoJSONObject.type === 'FeatureCollection') {\n    var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */\n        (object);\n    features = [];\n    var geoJSONFeatures = geoJSONFeatureCollection.features;\n    var i, ii;\n    for (i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n      features.push(this.readFeatureFromObject(geoJSONFeatures[i],\n          opt_options));\n    }\n  } else {\n    features = [this.readFeatureFromObject(object, opt_options)];\n  }\n  return features;\n};\n\n\n/**\n * Read a geometry from a GeoJSON source.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.geom.Geometry} Geometry.\n * @api\n */\n_ol_format_GeoJSON_.prototype.readGeometry;\n\n\n/**\n * @inheritDoc\n */\n_ol_format_GeoJSON_.prototype.readGeometryFromObject = function(\n    object, opt_options) {\n  return _ol_format_GeoJSON_.readGeometry_(\n      /** @type {GeoJSONGeometry} */ (object), opt_options);\n};\n\n\n/**\n * Read the projection from a GeoJSON source.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @return {ol.proj.Projection} Projection.\n * @api\n */\n_ol_format_GeoJSON_.prototype.readProjection;\n\n\n/**\n * @inheritDoc\n */\n_ol_format_GeoJSON_.prototype.readProjectionFromObject = function(object) {\n  var geoJSONObject = /** @type {GeoJSONObject} */ (object);\n  var crs = geoJSONObject.crs;\n  var projection;\n  if (crs) {\n    if (crs.type == 'name') {\n      projection = _ol_proj_.get(crs.properties.name);\n    } else if (crs.type == 'EPSG') {\n      // 'EPSG' is not part of the GeoJSON specification, but is generated by\n      // GeoServer.\n      // TODO: remove this when http://jira.codehaus.org/browse/GEOS-5996\n      // is fixed and widely deployed.\n      projection = _ol_proj_.get('EPSG:' + crs.properties.code);\n    } else {\n      _ol_asserts_.assert(false, 36); // Unknown SRS type\n    }\n  } else {\n    projection = this.defaultDataProjection;\n  }\n  return /** @type {ol.proj.Projection} */ (projection);\n};\n\n\n/**\n * Encode a feature as a GeoJSON Feature string.\n *\n * @function\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} GeoJSON.\n * @override\n * @api\n */\n_ol_format_GeoJSON_.prototype.writeFeature;\n\n\n/**\n * Encode a feature as a GeoJSON Feature object.\n *\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {GeoJSONFeature} Object.\n * @override\n * @api\n */\n_ol_format_GeoJSON_.prototype.writeFeatureObject = function(feature, opt_options) {\n  opt_options = this.adaptOptions(opt_options);\n\n  var object = /** @type {GeoJSONFeature} */ ({\n    'type': 'Feature'\n  });\n  var id = feature.getId();\n  if (id !== undefined) {\n    object.id = id;\n  }\n  var geometry = feature.getGeometry();\n  if (geometry) {\n    object.geometry =\n        _ol_format_GeoJSON_.writeGeometry_(geometry, opt_options);\n  } else {\n    object.geometry = null;\n  }\n  var properties = feature.getProperties();\n  delete properties[feature.getGeometryName()];\n  if (!_ol_obj_.isEmpty(properties)) {\n    object.properties = properties;\n  } else {\n    object.properties = null;\n  }\n  return object;\n};\n\n\n/**\n * Encode an array of features as GeoJSON.\n *\n * @function\n * @param {Array.<ol.Feature>} features Features.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} GeoJSON.\n * @api\n */\n_ol_format_GeoJSON_.prototype.writeFeatures;\n\n\n/**\n * Encode an array of features as a GeoJSON object.\n *\n * @param {Array.<ol.Feature>} features Features.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {GeoJSONFeatureCollection} GeoJSON Object.\n * @override\n * @api\n */\n_ol_format_GeoJSON_.prototype.writeFeaturesObject = function(features, opt_options) {\n  opt_options = this.adaptOptions(opt_options);\n  var objects = [];\n  var i, ii;\n  for (i = 0, ii = features.length; i < ii; ++i) {\n    objects.push(this.writeFeatureObject(features[i], opt_options));\n  }\n  return /** @type {GeoJSONFeatureCollection} */ ({\n    type: 'FeatureCollection',\n    features: objects\n  });\n};\n\n\n/**\n * Encode a geometry as a GeoJSON string.\n *\n * @function\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} GeoJSON.\n * @api\n */\n_ol_format_GeoJSON_.prototype.writeGeometry;\n\n\n/**\n * Encode a geometry as a GeoJSON object.\n *\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n * @override\n * @api\n */\n_ol_format_GeoJSON_.prototype.writeGeometryObject = function(geometry,\n    opt_options) {\n  return _ol_format_GeoJSON_.writeGeometry_(geometry,\n      this.adaptOptions(opt_options));\n};\nexport default _ol_format_GeoJSON_;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/format/geojson.js\n// module id = 68\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_format_Feature_ from '../format/feature';\nimport _ol_format_FormatType_ from '../format/formattype';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @constructor\n * @abstract\n * @extends {ol.format.Feature}\n */\nvar _ol_format_JSONFeature_ = function() {\n  _ol_format_Feature_.call(this);\n};\n\n_ol_.inherits(_ol_format_JSONFeature_, _ol_format_Feature_);\n\n\n/**\n * @param {Document|Node|Object|string} source Source.\n * @private\n * @return {Object} Object.\n */\n_ol_format_JSONFeature_.prototype.getObject_ = function(source) {\n  if (typeof source === 'string') {\n    var object = JSON.parse(source);\n    return object ? /** @type {Object} */ (object) : null;\n  } else if (source !== null) {\n    return source;\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.getType = function() {\n  return _ol_format_FormatType_.JSON;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.readFeature = function(source, opt_options) {\n  return this.readFeatureFromObject(\n      this.getObject_(source), this.getReadOptions(source, opt_options));\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.readFeatures = function(source, opt_options) {\n  return this.readFeaturesFromObject(\n      this.getObject_(source), this.getReadOptions(source, opt_options));\n};\n\n\n/**\n * @abstract\n * @param {Object} object Object.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @protected\n * @return {ol.Feature} Feature.\n */\n_ol_format_JSONFeature_.prototype.readFeatureFromObject = function(object, opt_options) {};\n\n\n/**\n * @abstract\n * @param {Object} object Object.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @protected\n * @return {Array.<ol.Feature>} Features.\n */\n_ol_format_JSONFeature_.prototype.readFeaturesFromObject = function(object, opt_options) {};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.readGeometry = function(source, opt_options) {\n  return this.readGeometryFromObject(\n      this.getObject_(source), this.getReadOptions(source, opt_options));\n};\n\n\n/**\n * @abstract\n * @param {Object} object Object.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @protected\n * @return {ol.geom.Geometry} Geometry.\n */\n_ol_format_JSONFeature_.prototype.readGeometryFromObject = function(object, opt_options) {};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.readProjection = function(source) {\n  return this.readProjectionFromObject(this.getObject_(source));\n};\n\n\n/**\n * @abstract\n * @param {Object} object Object.\n * @protected\n * @return {ol.proj.Projection} Projection.\n */\n_ol_format_JSONFeature_.prototype.readProjectionFromObject = function(object) {};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.writeFeature = function(feature, opt_options) {\n  return JSON.stringify(this.writeFeatureObject(feature, opt_options));\n};\n\n\n/**\n * @abstract\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {Object} Object.\n */\n_ol_format_JSONFeature_.prototype.writeFeatureObject = function(feature, opt_options) {};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.writeFeatures = function(features, opt_options) {\n  return JSON.stringify(this.writeFeaturesObject(features, opt_options));\n};\n\n\n/**\n * @abstract\n * @param {Array.<ol.Feature>} features Features.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {Object} Object.\n */\n_ol_format_JSONFeature_.prototype.writeFeaturesObject = function(features, opt_options) {};\n\n\n/**\n * @inheritDoc\n */\n_ol_format_JSONFeature_.prototype.writeGeometry = function(geometry, opt_options) {\n  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));\n};\n\n\n/**\n * @abstract\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {Object} Object.\n */\n_ol_format_JSONFeature_.prototype.writeGeometryObject = function(geometry, opt_options) {};\nexport default _ol_format_JSONFeature_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/format/jsonfeature.js\n// module id = 69\n// module chunks = 0","import _ol_extent_ from '../../extent';\nvar _ol_geom_flat_center_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array.<number>} Flat centers.\n */\n_ol_geom_flat_center_.linearRingss = function(flatCoordinates, offset, endss, stride) {\n  var flatCenters = [];\n  var i, ii;\n  var extent = _ol_extent_.createEmpty();\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    extent = _ol_extent_.createOrUpdateFromFlatCoordinates(\n        flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n};\nexport default _ol_geom_flat_center_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/center.js\n// module id = 70\n// module chunks = 0","var _ol_geom_flat_length_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\n_ol_geom_flat_length_.lineString = function(flatCoordinates, offset, end, stride) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  var length = 0;\n  var i;\n  for (i = offset + stride; i < end; i += stride) {\n    var x2 = flatCoordinates[i];\n    var y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\n_ol_geom_flat_length_.linearRing = function(flatCoordinates, offset, end, stride) {\n  var perimeter =\n      _ol_geom_flat_length_.lineString(flatCoordinates, offset, end, stride);\n  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n};\nexport default _ol_geom_flat_length_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/length.js\n// module id = 71\n// module chunks = 0","var _ol_geom_flat_reverse_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\n_ol_geom_flat_reverse_.coordinates = function(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    var i;\n    for (i = 0; i < stride; ++i) {\n      var tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n};\nexport default _ol_geom_flat_reverse_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/reverse.js\n// module id = 72\n// module chunks = 0","var _ol_geom_flat_transform_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {ol.Transform} transform Transform.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Transformed coordinates.\n */\n_ol_geom_flat_transform_.transform2D = function(flatCoordinates, offset, end, stride, transform, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n  var j;\n  for (j = offset; j < end; j += stride) {\n    var x = flatCoordinates[j];\n    var y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array.<number>} anchor Rotation anchor point.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Transformed coordinates.\n */\n_ol_geom_flat_transform_.rotate = function(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n};\n\n\n/**\n * Scale the coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array.<number>} anchor Scale anchor point.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Transformed coordinates.\n */\n_ol_geom_flat_transform_.scale = function(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Transformed coordinates.\n */\n_ol_geom_flat_transform_.translate = function(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n  var j, k;\n  for (j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n};\nexport default _ol_geom_flat_transform_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/flat/transform.js\n// module id = 73\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_events_ from '../events';\nimport _ol_events_EventType_ from '../events/eventtype';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_Geometry_ from '../geom/geometry';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_obj_ from '../obj';\n\n/**\n * @classdesc\n * An array of {@link ol.geom.Geometry} objects.\n *\n * @constructor\n * @extends {ol.geom.Geometry}\n * @param {Array.<ol.geom.Geometry>=} opt_geometries Geometries.\n * @api\n */\nvar _ol_geom_GeometryCollection_ = function(opt_geometries) {\n\n  _ol_geom_Geometry_.call(this);\n\n  /**\n   * @private\n   * @type {Array.<ol.geom.Geometry>}\n   */\n  this.geometries_ = opt_geometries ? opt_geometries : null;\n\n  this.listenGeometriesChange_();\n};\n\n_ol_.inherits(_ol_geom_GeometryCollection_, _ol_geom_Geometry_);\n\n\n/**\n * @param {Array.<ol.geom.Geometry>} geometries Geometries.\n * @private\n * @return {Array.<ol.geom.Geometry>} Cloned geometries.\n */\n_ol_geom_GeometryCollection_.cloneGeometries_ = function(geometries) {\n  var clonedGeometries = [];\n  var i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    clonedGeometries.push(geometries[i].clone());\n  }\n  return clonedGeometries;\n};\n\n\n/**\n * @private\n */\n_ol_geom_GeometryCollection_.prototype.unlistenGeometriesChange_ = function() {\n  var i, ii;\n  if (!this.geometries_) {\n    return;\n  }\n  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {\n    _ol_events_.unlisten(\n        this.geometries_[i], _ol_events_EventType_.CHANGE,\n        this.changed, this);\n  }\n};\n\n\n/**\n * @private\n */\n_ol_geom_GeometryCollection_.prototype.listenGeometriesChange_ = function() {\n  var i, ii;\n  if (!this.geometries_) {\n    return;\n  }\n  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {\n    _ol_events_.listen(\n        this.geometries_[i], _ol_events_EventType_.CHANGE,\n        this.changed, this);\n  }\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.GeometryCollection} Clone.\n * @override\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.clone = function() {\n  var geometryCollection = new _ol_geom_GeometryCollection_(null);\n  geometryCollection.setGeometries(this.geometries_);\n  return geometryCollection;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_GeometryCollection_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  var geometries = this.geometries_;\n  var i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    minSquaredDistance = geometries[i].closestPointXY(\n        x, y, closestPoint, minSquaredDistance);\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_GeometryCollection_.prototype.containsXY = function(x, y) {\n  var geometries = this.geometries_;\n  var i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    if (geometries[i].containsXY(x, y)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_GeometryCollection_.prototype.computeExtent = function(extent) {\n  _ol_extent_.createOrUpdateEmpty(extent);\n  var geometries = this.geometries_;\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    _ol_extent_.extend(extent, geometries[i].getExtent());\n  }\n  return extent;\n};\n\n\n/**\n * Return the geometries that make up this geometry collection.\n * @return {Array.<ol.geom.Geometry>} Geometries.\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.getGeometries = function() {\n  return _ol_geom_GeometryCollection_.cloneGeometries_(this.geometries_);\n};\n\n\n/**\n * @return {Array.<ol.geom.Geometry>} Geometries.\n */\n_ol_geom_GeometryCollection_.prototype.getGeometriesArray = function() {\n  return this.geometries_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_GeometryCollection_.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n  if (this.simplifiedGeometryRevision != this.getRevision()) {\n    _ol_obj_.clear(this.simplifiedGeometryCache);\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    this.simplifiedGeometryRevision = this.getRevision();\n  }\n  if (squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n       squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\n    return this;\n  }\n  var key = squaredTolerance.toString();\n  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n    return this.simplifiedGeometryCache[key];\n  } else {\n    var simplifiedGeometries = [];\n    var geometries = this.geometries_;\n    var simplified = false;\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      var geometry = geometries[i];\n      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      var simplifiedGeometryCollection = new _ol_geom_GeometryCollection_(null);\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;\n      return simplifiedGeometryCollection;\n    } else {\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  }\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.GEOMETRY_COLLECTION;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.intersectsExtent = function(extent) {\n  var geometries = this.geometries_;\n  var i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    if (geometries[i].intersectsExtent(extent)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @return {boolean} Is empty.\n */\n_ol_geom_GeometryCollection_.prototype.isEmpty = function() {\n  return this.geometries_.length === 0;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.rotate = function(angle, anchor) {\n  var geometries = this.geometries_;\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].rotate(angle, anchor);\n  }\n  this.changed();\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.scale = function(sx, opt_sy, opt_anchor) {\n  var anchor = opt_anchor;\n  if (!anchor) {\n    anchor = _ol_extent_.getCenter(this.getExtent());\n  }\n  var geometries = this.geometries_;\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].scale(sx, opt_sy, anchor);\n  }\n  this.changed();\n};\n\n\n/**\n * Set the geometries that make up this geometry collection.\n * @param {Array.<ol.geom.Geometry>} geometries Geometries.\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.setGeometries = function(geometries) {\n  this.setGeometriesArray(\n      _ol_geom_GeometryCollection_.cloneGeometries_(geometries));\n};\n\n\n/**\n * @param {Array.<ol.geom.Geometry>} geometries Geometries.\n */\n_ol_geom_GeometryCollection_.prototype.setGeometriesArray = function(geometries) {\n  this.unlistenGeometriesChange_();\n  this.geometries_ = geometries;\n  this.listenGeometriesChange_();\n  this.changed();\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.applyTransform = function(transformFn) {\n  var geometries = this.geometries_;\n  var i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].applyTransform(transformFn);\n  }\n  this.changed();\n};\n\n\n/**\n * Translate the geometry.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @override\n * @api\n */\n_ol_geom_GeometryCollection_.prototype.translate = function(deltaX, deltaY) {\n  var geometries = this.geometries_;\n  var i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].translate(deltaX, deltaY);\n  }\n  this.changed();\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_GeometryCollection_.prototype.disposeInternal = function() {\n  this.unlistenGeometriesChange_();\n  _ol_geom_Geometry_.prototype.disposeInternal.call(this);\n};\nexport default _ol_geom_GeometryCollection_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/geometrycollection.js\n// module id = 74\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_area_ from '../geom/flat/area';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_LinearRing_ = function(coordinates, opt_layout) {\n\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  this.setCoordinates(coordinates, opt_layout);\n\n};\n\n_ol_.inherits(_ol_geom_LinearRing_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.LinearRing} Clone.\n * @override\n * @api\n */\n_ol_geom_LinearRing_.prototype.clone = function() {\n  var linearRing = new _ol_geom_LinearRing_(null);\n  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return linearRing;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_LinearRing_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getMaxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n};\n\n\n/**\n * Return the area of the linear ring on projected plane.\n * @return {number} Area (on projected plane).\n * @api\n */\n_ol_geom_LinearRing_.prototype.getArea = function() {\n  return _ol_geom_flat_area_.linearRing(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n\n\n/**\n * Return the coordinates of the linear ring.\n * @return {Array.<ol.Coordinate>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_LinearRing_.prototype.getCoordinates = function() {\n  return _ol_geom_flat_inflate_.coordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_LinearRing_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n  var simplifiedLinearRing = new _ol_geom_LinearRing_(null);\n  simplifiedLinearRing.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates);\n  return simplifiedLinearRing;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_LinearRing_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.LINEAR_RING;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_LinearRing_.prototype.intersectsExtent = function(extent) {};\n\n\n/**\n * Set the coordinates of the linear ring.\n * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_LinearRing_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null);\n  } else {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = _ol_geom_flat_deflate_.coordinates(\n        this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n_ol_geom_LinearRing_.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\nexport default _ol_geom_LinearRing_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/linearring.js\n// module id = 75\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_array_ from '../array';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_LineString_ from '../geom/linestring';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate';\nimport _ol_geom_flat_interpolate_ from '../geom/flat/interpolate';\nimport _ol_geom_flat_intersectsextent_ from '../geom/flat/intersectsextent';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_MultiLineString_ = function(coordinates, opt_layout) {\n\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n  this.ends_ = [];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  this.setCoordinates(coordinates, opt_layout);\n\n};\n\n_ol_.inherits(_ol_geom_MultiLineString_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Append the passed linestring to the multilinestring.\n * @param {ol.geom.LineString} lineString LineString.\n * @api\n */\n_ol_geom_MultiLineString_.prototype.appendLineString = function(lineString) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = lineString.getFlatCoordinates().slice();\n  } else {\n    _ol_array_.extend(\n        this.flatCoordinates, lineString.getFlatCoordinates().slice());\n  }\n  this.ends_.push(this.flatCoordinates.length);\n  this.changed();\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.MultiLineString} Clone.\n * @override\n * @api\n */\n_ol_geom_MultiLineString_.prototype.clone = function() {\n  var multiLineString = new _ol_geom_MultiLineString_(null);\n  multiLineString.setFlatCoordinates(\n      this.layout, this.flatCoordinates.slice(), this.ends_.slice());\n  return multiLineString;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_MultiLineString_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getsMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getsClosestPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n};\n\n\n/**\n * Returns the coordinate at `m` using linear interpolation, or `null` if no\n * such coordinate exists.\n *\n * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n * M will return the first coordinate and Ms greater than the last M will\n * return the last coordinate.\n *\n * `opt_interpolate` controls interpolation between consecutive LineStrings\n * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n * will be linearly interpolated between the last coordinate of one LineString\n * and the first coordinate of the next LineString.  If `opt_interpolate` is\n * `false` then the function will return `null` for Ms falling between\n * LineStrings.\n *\n * @param {number} m M.\n * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n_ol_geom_MultiLineString_.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {\n  if ((this.layout != _ol_geom_GeometryLayout_.XYM &&\n       this.layout != _ol_geom_GeometryLayout_.XYZM) ||\n      this.flatCoordinates.length === 0) {\n    return null;\n  }\n  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n  var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n  return _ol_geom_flat_interpolate_.lineStringsCoordinateAtM(this.flatCoordinates, 0,\n      this.ends_, this.stride, m, extrapolate, interpolate);\n};\n\n\n/**\n * Return the coordinates of the multilinestring.\n * @return {Array.<Array.<ol.Coordinate>>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_MultiLineString_.prototype.getCoordinates = function() {\n  return _ol_geom_flat_inflate_.coordinatess(\n      this.flatCoordinates, 0, this.ends_, this.stride);\n};\n\n\n/**\n * @return {Array.<number>} Ends.\n */\n_ol_geom_MultiLineString_.prototype.getEnds = function() {\n  return this.ends_;\n};\n\n\n/**\n * Return the linestring at the specified index.\n * @param {number} index Index.\n * @return {ol.geom.LineString} LineString.\n * @api\n */\n_ol_geom_MultiLineString_.prototype.getLineString = function(index) {\n  if (index < 0 || this.ends_.length <= index) {\n    return null;\n  }\n  var lineString = new _ol_geom_LineString_(null);\n  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\n  return lineString;\n};\n\n\n/**\n * Return the linestrings of this multilinestring.\n * @return {Array.<ol.geom.LineString>} LineStrings.\n * @api\n */\n_ol_geom_MultiLineString_.prototype.getLineStrings = function() {\n  var flatCoordinates = this.flatCoordinates;\n  var ends = this.ends_;\n  var layout = this.layout;\n  /** @type {Array.<ol.geom.LineString>} */\n  var lineStrings = [];\n  var offset = 0;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var lineString = new _ol_geom_LineString_(null);\n    lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\n    lineStrings.push(lineString);\n    offset = end;\n  }\n  return lineStrings;\n};\n\n\n/**\n * @return {Array.<number>} Flat midpoints.\n */\n_ol_geom_MultiLineString_.prototype.getFlatMidpoints = function() {\n  var midpoints = [];\n  var flatCoordinates = this.flatCoordinates;\n  var offset = 0;\n  var ends = this.ends_;\n  var stride = this.stride;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var midpoint = _ol_geom_flat_interpolate_.lineString(\n        flatCoordinates, offset, end, stride, 0.5);\n    _ol_array_.extend(midpoints, midpoint);\n    offset = end;\n  }\n  return midpoints;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_MultiLineString_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  var simplifiedEnds = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeuckers(\n      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n  var simplifiedMultiLineString = new _ol_geom_MultiLineString_(null);\n  simplifiedMultiLineString.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates, simplifiedEnds);\n  return simplifiedMultiLineString;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_MultiLineString_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.MULTI_LINE_STRING;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_MultiLineString_.prototype.intersectsExtent = function(extent) {\n  return _ol_geom_flat_intersectsextent_.lineStrings(\n      this.flatCoordinates, 0, this.ends_, this.stride, extent);\n};\n\n\n/**\n * Set the coordinates of the multilinestring.\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_MultiLineString_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null, this.ends_);\n  } else {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = _ol_geom_flat_deflate_.coordinatess(\n        this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {Array.<number>} ends Ends.\n */\n_ol_geom_MultiLineString_.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.ends_ = ends;\n  this.changed();\n};\n\n\n/**\n * @param {Array.<ol.geom.LineString>} lineStrings LineStrings.\n */\n_ol_geom_MultiLineString_.prototype.setLineStrings = function(lineStrings) {\n  var layout = this.getLayout();\n  var flatCoordinates = [];\n  var ends = [];\n  var i, ii;\n  for (i = 0, ii = lineStrings.length; i < ii; ++i) {\n    var lineString = lineStrings[i];\n    if (i === 0) {\n      layout = lineString.getLayout();\n    }\n    _ol_array_.extend(flatCoordinates, lineString.getFlatCoordinates());\n    ends.push(flatCoordinates.length);\n  }\n  this.setFlatCoordinates(layout, flatCoordinates, ends);\n};\nexport default _ol_geom_MultiLineString_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/multilinestring.js\n// module id = 76\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_array_ from '../array';\nimport _ol_extent_ from '../extent';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_geom_MultiPoint_ from '../geom/multipoint';\nimport _ol_geom_Polygon_ from '../geom/polygon';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry';\nimport _ol_geom_flat_area_ from '../geom/flat/area';\nimport _ol_geom_flat_center_ from '../geom/flat/center';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest';\nimport _ol_geom_flat_contains_ from '../geom/flat/contains';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate';\nimport _ol_geom_flat_interiorpoint_ from '../geom/flat/interiorpoint';\nimport _ol_geom_flat_intersectsextent_ from '../geom/flat/intersectsextent';\nimport _ol_geom_flat_orient_ from '../geom/flat/orient';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_MultiPolygon_ = function(coordinates, opt_layout) {\n\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @type {Array.<Array.<number>>}\n   * @private\n   */\n  this.endss_ = [];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.flatInteriorPointsRevision_ = -1;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.flatInteriorPoints_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.orientedRevision_ = -1;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.orientedFlatCoordinates_ = null;\n\n  this.setCoordinates(coordinates, opt_layout);\n\n};\n\n_ol_.inherits(_ol_geom_MultiPolygon_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Append the passed polygon to this multipolygon.\n * @param {ol.geom.Polygon} polygon Polygon.\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.appendPolygon = function(polygon) {\n  /** @type {Array.<number>} */\n  var ends;\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = polygon.getFlatCoordinates().slice();\n    ends = polygon.getEnds().slice();\n    this.endss_.push();\n  } else {\n    var offset = this.flatCoordinates.length;\n    _ol_array_.extend(this.flatCoordinates, polygon.getFlatCoordinates());\n    ends = polygon.getEnds().slice();\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      ends[i] += offset;\n    }\n  }\n  this.endss_.push(ends);\n  this.changed();\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.MultiPolygon} Clone.\n * @override\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.clone = function() {\n  var multiPolygon = new _ol_geom_MultiPolygon_(null);\n\n  var len = this.endss_.length;\n  var newEndss = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    newEndss[i] = this.endss_[i].slice();\n  }\n\n  multiPolygon.setFlatCoordinates(\n      this.layout, this.flatCoordinates.slice(), newEndss);\n  return multiPolygon;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_MultiPolygon_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getssMaxSquaredDelta(\n        this.flatCoordinates, 0, this.endss_, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getssClosestPoint(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_MultiPolygon_.prototype.containsXY = function(x, y) {\n  return _ol_geom_flat_contains_.linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n};\n\n\n/**\n * Return the area of the multipolygon on projected plane.\n * @return {number} Area (on projected plane).\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.getArea = function() {\n  return _ol_geom_flat_area_.linearRingss(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n};\n\n\n/**\n * Get the coordinate array for this geometry.  This array has the structure\n * of a GeoJSON coordinate array for multi-polygons.\n *\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\n *     If `false`, coordinates will be oriented according to the left-hand rule\n *     (clockwise for exterior and counter-clockwise for interior rings).\n *     By default, coordinate orientation will depend on how the geometry was\n *     constructed.\n * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.getCoordinates = function(opt_right) {\n  var flatCoordinates;\n  if (opt_right !== undefined) {\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\n    _ol_geom_flat_orient_.orientLinearRingss(\n        flatCoordinates, 0, this.endss_, this.stride, opt_right);\n  } else {\n    flatCoordinates = this.flatCoordinates;\n  }\n\n  return _ol_geom_flat_inflate_.coordinatesss(\n      flatCoordinates, 0, this.endss_, this.stride);\n};\n\n\n/**\n * @return {Array.<Array.<number>>} Endss.\n */\n_ol_geom_MultiPolygon_.prototype.getEndss = function() {\n  return this.endss_;\n};\n\n\n/**\n * @return {Array.<number>} Flat interior points.\n */\n_ol_geom_MultiPolygon_.prototype.getFlatInteriorPoints = function() {\n  if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n    var flatCenters = _ol_geom_flat_center_.linearRingss(\n        this.flatCoordinates, 0, this.endss_, this.stride);\n    this.flatInteriorPoints_ = _ol_geom_flat_interiorpoint_.linearRingss(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        flatCenters);\n    this.flatInteriorPointsRevision_ = this.getRevision();\n  }\n  return this.flatInteriorPoints_;\n};\n\n\n/**\n * Return the interior points as {@link ol.geom.MultiPoint multipoint}.\n * @return {ol.geom.MultiPoint} Interior points.\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.getInteriorPoints = function() {\n  var interiorPoints = new _ol_geom_MultiPoint_(null);\n  interiorPoints.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,\n      this.getFlatInteriorPoints().slice());\n  return interiorPoints;\n};\n\n\n/**\n * @return {Array.<number>} Oriented flat coordinates.\n */\n_ol_geom_MultiPolygon_.prototype.getOrientedFlatCoordinates = function() {\n  if (this.orientedRevision_ != this.getRevision()) {\n    var flatCoordinates = this.flatCoordinates;\n    if (_ol_geom_flat_orient_.linearRingssAreOriented(\n        flatCoordinates, 0, this.endss_, this.stride)) {\n      this.orientedFlatCoordinates_ = flatCoordinates;\n    } else {\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\n      this.orientedFlatCoordinates_.length =\n          _ol_geom_flat_orient_.orientLinearRingss(\n              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n    }\n    this.orientedRevision_ = this.getRevision();\n  }\n  return this.orientedFlatCoordinates_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_MultiPolygon_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  var simplifiedEndss = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.quantizess(\n      this.flatCoordinates, 0, this.endss_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEndss);\n  var simplifiedMultiPolygon = new _ol_geom_MultiPolygon_(null);\n  simplifiedMultiPolygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates, simplifiedEndss);\n  return simplifiedMultiPolygon;\n};\n\n\n/**\n * Return the polygon at the specified index.\n * @param {number} index Index.\n * @return {ol.geom.Polygon} Polygon.\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.getPolygon = function(index) {\n  if (index < 0 || this.endss_.length <= index) {\n    return null;\n  }\n  var offset;\n  if (index === 0) {\n    offset = 0;\n  } else {\n    var prevEnds = this.endss_[index - 1];\n    offset = prevEnds[prevEnds.length - 1];\n  }\n  var ends = this.endss_[index].slice();\n  var end = ends[ends.length - 1];\n  if (offset !== 0) {\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      ends[i] -= offset;\n    }\n  }\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      this.layout, this.flatCoordinates.slice(offset, end), ends);\n  return polygon;\n};\n\n\n/**\n * Return the polygons of this multipolygon.\n * @return {Array.<ol.geom.Polygon>} Polygons.\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.getPolygons = function() {\n  var layout = this.layout;\n  var flatCoordinates = this.flatCoordinates;\n  var endss = this.endss_;\n  var polygons = [];\n  var offset = 0;\n  var i, ii, j, jj;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (j = 0, jj = ends.length; j < jj; ++j) {\n        ends[j] -= offset;\n      }\n    }\n    var polygon = new _ol_geom_Polygon_(null);\n    polygon.setFlatCoordinates(\n        layout, flatCoordinates.slice(offset, end), ends);\n    polygons.push(polygon);\n    offset = end;\n  }\n  return polygons;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.MULTI_POLYGON;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.intersectsExtent = function(extent) {\n  return _ol_geom_flat_intersectsextent_.linearRingss(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n};\n\n\n/**\n * Set the coordinates of the multipolygon.\n * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_MultiPolygon_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null, this.endss_);\n  } else {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = _ol_geom_flat_deflate_.coordinatesss(\n        this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ?\n          0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {Array.<Array.<number>>} endss Endss.\n */\n_ol_geom_MultiPolygon_.prototype.setFlatCoordinates = function(layout, flatCoordinates, endss) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.endss_ = endss;\n  this.changed();\n};\n\n\n/**\n * @param {Array.<ol.geom.Polygon>} polygons Polygons.\n */\n_ol_geom_MultiPolygon_.prototype.setPolygons = function(polygons) {\n  var layout = this.getLayout();\n  var flatCoordinates = [];\n  var endss = [];\n  var i, ii, ends;\n  for (i = 0, ii = polygons.length; i < ii; ++i) {\n    var polygon = polygons[i];\n    if (i === 0) {\n      layout = polygon.getLayout();\n    }\n    var offset = flatCoordinates.length;\n    ends = polygon.getEnds();\n    var j, jj;\n    for (j = 0, jj = ends.length; j < jj; ++j) {\n      ends[j] += offset;\n    }\n    _ol_array_.extend(flatCoordinates, polygon.getFlatCoordinates());\n    endss.push(ends);\n  }\n  this.setFlatCoordinates(layout, flatCoordinates, endss);\n};\nexport default _ol_geom_MultiPolygon_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/geom/multipolygon.js\n// module id = 77\n// module chunks = 0","import _ol_ from './index';\nimport _ol_webgl_ from './webgl';\nvar _ol_has_ = {};\n\nvar ua = typeof navigator !== 'undefined' ?\n    navigator.userAgent.toLowerCase() : '';\n\n/**\n * User agent string says we are dealing with Firefox as browser.\n * @type {boolean}\n */\n_ol_has_.FIREFOX = ua.indexOf('firefox') !== -1;\n\n/**\n * User agent string says we are dealing with Safari as browser.\n * @type {boolean}\n */\n_ol_has_.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;\n\n/**\n * User agent string says we are dealing with a WebKit engine.\n * @type {boolean}\n */\n_ol_has_.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;\n\n/**\n * User agent string says we are dealing with a Mac as platform.\n * @type {boolean}\n */\n_ol_has_.MAC = ua.indexOf('macintosh') !== -1;\n\n\n/**\n * The ratio between physical pixels and device-independent pixels\n * (dips) on the device (`window.devicePixelRatio`).\n * @const\n * @type {number}\n * @api\n */\n_ol_has_.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;\n\n\n/**\n * True if the browser's Canvas implementation implements {get,set}LineDash.\n * @type {boolean}\n */\n_ol_has_.CANVAS_LINE_DASH = false;\n\n\n/**\n * True if both the library and browser support Canvas.  Always `false`\n * if `ol.ENABLE_CANVAS` is set to `false` at compile time.\n * @const\n * @type {boolean}\n * @api\n */\n_ol_has_.CANVAS = _ol_.ENABLE_CANVAS && (\n    /**\n     * @return {boolean} Canvas supported.\n     */\n    function() {\n      if (!('HTMLCanvasElement' in window)) {\n        return false;\n      }\n      try {\n        var context = document.createElement('CANVAS').getContext('2d');\n        if (!context) {\n          return false;\n        } else {\n          if (context.setLineDash !== undefined) {\n            _ol_has_.CANVAS_LINE_DASH = true;\n          }\n          return true;\n        }\n      } catch (e) {\n        return false;\n      }\n    })();\n\n\n/**\n * Indicates if DeviceOrientation is supported in the user's browser.\n * @const\n * @type {boolean}\n * @api\n */\n_ol_has_.DEVICE_ORIENTATION = 'DeviceOrientationEvent' in window;\n\n\n/**\n * Is HTML5 geolocation supported in the current browser?\n * @const\n * @type {boolean}\n * @api\n */\n_ol_has_.GEOLOCATION = 'geolocation' in navigator;\n\n\n/**\n * True if browser supports touch events.\n * @const\n * @type {boolean}\n * @api\n */\n_ol_has_.TOUCH = _ol_.ASSUME_TOUCH || 'ontouchstart' in window;\n\n\n/**\n * True if browser supports pointer events.\n * @const\n * @type {boolean}\n */\n_ol_has_.POINTER = 'PointerEvent' in window;\n\n\n/**\n * True if browser supports ms pointer events (IE 10).\n * @const\n * @type {boolean}\n */\n_ol_has_.MSPOINTER = !!(navigator.msPointerEnabled);\n\n\n/**\n * True if both OpenLayers and browser support WebGL.  Always `false`\n * if `ol.ENABLE_WEBGL` is set to `false` at compile time.\n * @const\n * @type {boolean}\n * @api\n */\n_ol_has_.WEBGL;\n\n\n(function() {\n  if (false) {\n    var hasWebGL = false;\n    var textureSize;\n    var /** @type {Array.<string>} */ extensions = [];\n\n    if ('WebGLRenderingContext' in window) {\n      try {\n        var canvas = /** @type {HTMLCanvasElement} */\n            (document.createElement('CANVAS'));\n        var gl = _ol_webgl_.getContext(canvas, {\n          failIfMajorPerformanceCaveat: true\n        });\n        if (gl) {\n          hasWebGL = true;\n          textureSize = /** @type {number} */\n              (gl.getParameter(gl.MAX_TEXTURE_SIZE));\n          extensions = gl.getSupportedExtensions();\n        }\n      } catch (e) {\n        // pass\n      }\n    }\n    _ol_has_.WEBGL = hasWebGL;\n    _ol_.WEBGL_EXTENSIONS = extensions;\n    _ol_.WEBGL_MAX_TEXTURE_SIZE = textureSize;\n  }\n})();\nexport default _ol_has_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/has.js\n// module id = 78\n// module chunks = 0","/**\n * @enum {number}\n */\nvar _ol_ImageState_ = {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3\n};\n\nexport default _ol_ImageState_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/imagestate.js\n// module id = 79\n// module chunks = 0","/**\n * @enum {string}\n */\nvar _ol_ObjectEventType_ = {\n  /**\n   * Triggered when a property is changed.\n   * @event ol.Object.Event#propertychange\n   * @api\n   */\n  PROPERTYCHANGE: 'propertychange'\n};\n\nexport default _ol_ObjectEventType_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/objecteventtype.js\n// module id = 80\n// module chunks = 0","import _ol_ from './index';\nimport _ol_events_ from './events';\nimport _ol_events_EventTarget_ from './events/eventtarget';\nimport _ol_events_EventType_ from './events/eventtype';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link ol.Observable#changed}.\n *\n * @constructor\n * @extends {ol.events.EventTarget}\n * @fires ol.events.Event\n * @struct\n * @api\n */\nvar _ol_Observable_ = function() {\n\n  _ol_events_EventTarget_.call(this);\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.revision_ = 0;\n\n};\n\n_ol_.inherits(_ol_Observable_, _ol_events_EventTarget_);\n\n\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\n_ol_Observable_.unByKey = function(key) {\n  if (Array.isArray(key)) {\n    for (var i = 0, ii = key.length; i < ii; ++i) {\n      _ol_events_.unlistenByKey(key[i]);\n    }\n  } else {\n    _ol_events_.unlistenByKey(/** @type {ol.EventsKey} */ (key));\n  }\n};\n\n\n/**\n * Increases the revision counter and dispatches a 'change' event.\n * @api\n */\n_ol_Observable_.prototype.changed = function() {\n  ++this.revision_;\n  this.dispatchEvent(_ol_events_EventType_.CHANGE);\n};\n\n\n/**\n * Dispatches an event and calls all listeners listening for events\n * of this type. The event parameter can either be a string or an\n * Object with a `type` property.\n *\n * @param {{type: string,\n *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|\n *     string} event Event object.\n * @function\n * @api\n */\n_ol_Observable_.prototype.dispatchEvent;\n\n\n/**\n * Get the version number for this object.  Each time the object is modified,\n * its version number will be incremented.\n * @return {number} Revision.\n * @api\n */\n_ol_Observable_.prototype.getRevision = function() {\n  return this.revision_;\n};\n\n\n/**\n * Listen for a certain type of event.\n * @param {string|Array.<string>} type The event type or array of event types.\n * @param {function(?): ?} listener The listener function.\n * @param {Object=} opt_this The object to use as `this` in `listener`.\n * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\n_ol_Observable_.prototype.on = function(type, listener, opt_this) {\n  if (Array.isArray(type)) {\n    var len = type.length;\n    var keys = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      keys[i] = _ol_events_.listen(this, type[i], listener, opt_this);\n    }\n    return keys;\n  } else {\n    return _ol_events_.listen(\n        this, /** @type {string} */ (type), listener, opt_this);\n  }\n};\n\n\n/**\n * Listen once for a certain type of event.\n * @param {string|Array.<string>} type The event type or array of event types.\n * @param {function(?): ?} listener The listener function.\n * @param {Object=} opt_this The object to use as `this` in `listener`.\n * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\n_ol_Observable_.prototype.once = function(type, listener, opt_this) {\n  if (Array.isArray(type)) {\n    var len = type.length;\n    var keys = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      keys[i] = _ol_events_.listenOnce(this, type[i], listener, opt_this);\n    }\n    return keys;\n  } else {\n    return _ol_events_.listenOnce(\n        this, /** @type {string} */ (type), listener, opt_this);\n  }\n};\n\n\n/**\n * Unlisten for a certain type of event.\n * @param {string|Array.<string>} type The event type or array of event types.\n * @param {function(?): ?} listener The listener function.\n * @param {Object=} opt_this The object which was used as `this` by the\n * `listener`.\n * @api\n */\n_ol_Observable_.prototype.un = function(type, listener, opt_this) {\n  if (Array.isArray(type)) {\n    for (var i = 0, ii = type.length; i < ii; ++i) {\n      _ol_events_.unlisten(this, type[i], listener, opt_this);\n    }\n    return;\n  } else {\n    _ol_events_.unlisten(this, /** @type {string} */ (type), listener, opt_this);\n  }\n};\nexport default _ol_Observable_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/observable.js\n// module id = 81\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_math_ from '../math';\nimport _ol_proj_Projection_ from '../proj/projection';\nimport _ol_proj_Units_ from '../proj/units';\nvar _ol_proj_EPSG3857_ = {};\n\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n *\n * @constructor\n * @extends {ol.proj.Projection}\n * @param {string} code Code.\n * @private\n */\n_ol_proj_EPSG3857_.Projection_ = function(code) {\n  _ol_proj_Projection_.call(this, {\n    code: code,\n    units: _ol_proj_Units_.METERS,\n    extent: _ol_proj_EPSG3857_.EXTENT,\n    global: true,\n    worldExtent: _ol_proj_EPSG3857_.WORLD_EXTENT,\n    getPointResolution: function(resolution, point) {\n      return resolution / _ol_math_.cosh(point[1] / _ol_proj_EPSG3857_.RADIUS);\n    }\n  });\n};\n_ol_.inherits(_ol_proj_EPSG3857_.Projection_, _ol_proj_Projection_);\n\n\n/**\n * @const\n * @type {number}\n */\n_ol_proj_EPSG3857_.RADIUS = 6378137;\n\n\n/**\n * @const\n * @type {number}\n */\n_ol_proj_EPSG3857_.HALF_SIZE = Math.PI * _ol_proj_EPSG3857_.RADIUS;\n\n\n/**\n * @const\n * @type {ol.Extent}\n */\n_ol_proj_EPSG3857_.EXTENT = [\n  -_ol_proj_EPSG3857_.HALF_SIZE, -_ol_proj_EPSG3857_.HALF_SIZE,\n  _ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE\n];\n\n\n/**\n * @const\n * @type {ol.Extent}\n */\n_ol_proj_EPSG3857_.WORLD_EXTENT = [-180, -85, 180, 85];\n\n\n/**\n * Lists several projection codes with the same meaning as EPSG:3857.\n *\n * @type {Array.<string>}\n */\n_ol_proj_EPSG3857_.CODES = [\n  'EPSG:3857',\n  'EPSG:102100',\n  'EPSG:102113',\n  'EPSG:900913',\n  'urn:ogc:def:crs:EPSG:6.18:3:3857',\n  'urn:ogc:def:crs:EPSG::3857',\n  'http://www.opengis.net/gml/srs/epsg.xml#3857'\n];\n\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array.<ol.proj.Projection>}\n */\n_ol_proj_EPSG3857_.PROJECTIONS = _ol_proj_EPSG3857_.CODES.map(function(code) {\n  return new _ol_proj_EPSG3857_.Projection_(code);\n});\n\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array.<number>} input Input array of coordinate values.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension (default is `2`).\n * @return {Array.<number>} Output array of coordinate values.\n */\n_ol_proj_EPSG3857_.fromEPSG4326 = function(input, opt_output, opt_dimension) {\n  var length = input.length,\n      dimension = opt_dimension > 1 ? opt_dimension : 2,\n      output = opt_output;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  var halfSize = _ol_proj_EPSG3857_.HALF_SIZE;\n  for (var i = 0; i < length; i += dimension) {\n    output[i] = halfSize * input[i] / 180;\n    var y = _ol_proj_EPSG3857_.RADIUS *\n        Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));\n    if (y > halfSize) {\n      y = halfSize;\n    } else if (y < -halfSize) {\n      y = -halfSize;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n};\n\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array.<number>} input Input array of coordinate values.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension (default is `2`).\n * @return {Array.<number>} Output array of coordinate values.\n */\n_ol_proj_EPSG3857_.toEPSG4326 = function(input, opt_output, opt_dimension) {\n  var length = input.length,\n      dimension = opt_dimension > 1 ? opt_dimension : 2,\n      output = opt_output;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (var i = 0; i < length; i += dimension) {\n    output[i] = 180 * input[i] / _ol_proj_EPSG3857_.HALF_SIZE;\n    output[i + 1] = 360 * Math.atan(\n        Math.exp(input[i + 1] / _ol_proj_EPSG3857_.RADIUS)) / Math.PI - 90;\n  }\n  return output;\n};\nexport default _ol_proj_EPSG3857_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/epsg3857.js\n// module id = 82\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_proj_Projection_ from '../proj/projection';\nimport _ol_proj_Units_ from '../proj/units';\nimport _ol_sphere_WGS84_ from '../sphere/wgs84';\nvar _ol_proj_EPSG4326_ = {};\n\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n *\n * @constructor\n * @extends {ol.proj.Projection}\n * @param {string} code Code.\n * @param {string=} opt_axisOrientation Axis orientation.\n * @private\n */\n_ol_proj_EPSG4326_.Projection_ = function(code, opt_axisOrientation) {\n  _ol_proj_Projection_.call(this, {\n    code: code,\n    units: _ol_proj_Units_.DEGREES,\n    extent: _ol_proj_EPSG4326_.EXTENT,\n    axisOrientation: opt_axisOrientation,\n    global: true,\n    metersPerUnit: _ol_proj_EPSG4326_.METERS_PER_UNIT,\n    worldExtent: _ol_proj_EPSG4326_.EXTENT\n  });\n};\n_ol_.inherits(_ol_proj_EPSG4326_.Projection_, _ol_proj_Projection_);\n\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {ol.Extent}\n */\n_ol_proj_EPSG4326_.EXTENT = [-180, -90, 180, 90];\n\n\n/**\n * @const\n * @type {number}\n */\n_ol_proj_EPSG4326_.METERS_PER_UNIT = Math.PI * _ol_sphere_WGS84_.radius / 180;\n\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array.<ol.proj.Projection>}\n */\n_ol_proj_EPSG4326_.PROJECTIONS = [\n  new _ol_proj_EPSG4326_.Projection_('CRS:84'),\n  new _ol_proj_EPSG4326_.Projection_('EPSG:4326', 'neu'),\n  new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG::4326', 'neu'),\n  new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),\n  new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'),\n  new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:2:84'),\n  new _ol_proj_EPSG4326_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n  new _ol_proj_EPSG4326_.Projection_('urn:x-ogc:def:crs:EPSG:4326', 'neu')\n];\nexport default _ol_proj_EPSG4326_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/epsg4326.js\n// module id = 83\n// module chunks = 0","var _ol_proj_projections_ = {};\n\n\n/**\n * @private\n * @type {Object.<string, ol.proj.Projection>}\n */\n_ol_proj_projections_.cache_ = {};\n\n\n/**\n * Clear the projections cache.\n */\n_ol_proj_projections_.clear = function() {\n  _ol_proj_projections_.cache_ = {};\n};\n\n\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {ol.proj.Projection} The projection (if cached).\n */\n_ol_proj_projections_.get = function(code) {\n  var projections = _ol_proj_projections_.cache_;\n  return projections[code] || null;\n};\n\n\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {ol.proj.Projection} projection The projection to cache.\n */\n_ol_proj_projections_.add = function(code, projection) {\n  var projections = _ol_proj_projections_.cache_;\n  projections[code] = projection;\n};\nexport default _ol_proj_projections_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/projections.js\n// module id = 84\n// module chunks = 0","import _ol_obj_ from '../obj';\nvar _ol_proj_transforms_ = {};\n\n\n/**\n * @private\n * @type {Object.<string, Object.<string, ol.TransformFunction>>}\n */\n_ol_proj_transforms_.cache_ = {};\n\n\n/**\n * Clear the transform cache.\n */\n_ol_proj_transforms_.clear = function() {\n  _ol_proj_transforms_.cache_ = {};\n};\n\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {ol.proj.Projection} source Source.\n * @param {ol.proj.Projection} destination Destination.\n * @param {ol.TransformFunction} transformFn Transform.\n */\n_ol_proj_transforms_.add = function(source, destination, transformFn) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  var transforms = _ol_proj_transforms_.cache_;\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n};\n\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {ol.proj.Projection} source Source projection.\n * @param {ol.proj.Projection} destination Destination projection.\n * @return {ol.TransformFunction} transformFn The unregistered transform.\n */\n_ol_proj_transforms_.remove = function(source, destination) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  var transforms = _ol_proj_transforms_.cache_;\n  var transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (_ol_obj_.isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n};\n\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {ol.TransformFunction|undefined} The transform function (if found).\n */\n_ol_proj_transforms_.get = function(sourceCode, destinationCode) {\n  var transform;\n  var transforms = _ol_proj_transforms_.cache_;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n};\nexport default _ol_proj_transforms_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/proj/transforms.js\n// module id = 85\n// module chunks = 0","var _ol_render_canvas_ = {};\n\n\n/**\n * @const\n * @type {string}\n */\n_ol_render_canvas_.defaultFont = '10px sans-serif';\n\n\n/**\n * @const\n * @type {ol.Color}\n */\n_ol_render_canvas_.defaultFillStyle = [0, 0, 0, 1];\n\n\n/**\n * @const\n * @type {string}\n */\n_ol_render_canvas_.defaultLineCap = 'round';\n\n\n/**\n * @const\n * @type {Array.<number>}\n */\n_ol_render_canvas_.defaultLineDash = [];\n\n\n/**\n * @const\n * @type {number}\n */\n_ol_render_canvas_.defaultLineDashOffset = 0;\n\n\n/**\n * @const\n * @type {string}\n */\n_ol_render_canvas_.defaultLineJoin = 'round';\n\n\n/**\n * @const\n * @type {number}\n */\n_ol_render_canvas_.defaultMiterLimit = 10;\n\n\n/**\n * @const\n * @type {ol.Color}\n */\n_ol_render_canvas_.defaultStrokeStyle = [0, 0, 0, 1];\n\n\n/**\n * @const\n * @type {string}\n */\n_ol_render_canvas_.defaultTextAlign = 'center';\n\n\n/**\n * @const\n * @type {string}\n */\n_ol_render_canvas_.defaultTextBaseline = 'middle';\n\n\n/**\n * @const\n * @type {number}\n */\n_ol_render_canvas_.defaultLineWidth = 1;\n\n\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {number} offsetX X offset.\n * @param {number} offsetY Y offset.\n */\n_ol_render_canvas_.rotateAtOffset = function(context, rotation, offsetX, offsetY) {\n  if (rotation !== 0) {\n    context.translate(offsetX, offsetY);\n    context.rotate(rotation);\n    context.translate(-offsetX, -offsetY);\n  }\n};\nexport default _ol_render_canvas_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/render/canvas.js\n// module id = 86\n// module chunks = 0","import _ol_Sphere_ from '../sphere';\n\n/**\n * A sphere with radius equal to the semi-major axis of the WGS84 ellipsoid.\n * @const\n * @type {ol.Sphere}\n */\nvar _ol_sphere_WGS84_ = new _ol_Sphere_(6378137);\n\nexport default _ol_sphere_WGS84_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/sphere/wgs84.js\n// module id = 87\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_style_RegularShape_ from '../style/regularshape';\n\n/**\n * @classdesc\n * Set circle style for vector features.\n *\n * @constructor\n * @param {olx.style.CircleOptions=} opt_options Options.\n * @extends {ol.style.RegularShape}\n * @api\n */\nvar _ol_style_Circle_ = function(opt_options) {\n\n  var options = opt_options || {};\n\n  _ol_style_RegularShape_.call(this, {\n    points: Infinity,\n    fill: options.fill,\n    radius: options.radius,\n    snapToPixel: options.snapToPixel,\n    stroke: options.stroke,\n    atlasManager: options.atlasManager\n  });\n\n};\n\n_ol_.inherits(_ol_style_Circle_, _ol_style_RegularShape_);\n\n\n/**\n * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n * @return {ol.style.Circle} The cloned style.\n * @override\n * @api\n */\n_ol_style_Circle_.prototype.clone = function() {\n  var style = new _ol_style_Circle_({\n    fill: this.getFill() ? this.getFill().clone() : undefined,\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n    radius: this.getRadius(),\n    snapToPixel: this.getSnapToPixel(),\n    atlasManager: this.atlasManager_\n  });\n  style.setOpacity(this.getOpacity());\n  style.setScale(this.getScale());\n  return style;\n};\n\n\n/**\n * Set the circle radius.\n *\n * @param {number} radius Circle radius.\n * @api\n */\n_ol_style_Circle_.prototype.setRadius = function(radius) {\n  this.radius_ = radius;\n  this.render_(this.atlasManager_);\n};\nexport default _ol_style_Circle_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/style/circle.js\n// module id = 88\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_color_ from '../color';\n\n/**\n * @classdesc\n * Set fill style for vector features.\n *\n * @constructor\n * @param {olx.style.FillOptions=} opt_options Options.\n * @api\n */\nvar _ol_style_Fill_ = function(opt_options) {\n\n  var options = opt_options || {};\n\n  /**\n   * @private\n   * @type {ol.Color|ol.ColorLike}\n   */\n  this.color_ = options.color !== undefined ? options.color : null;\n\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.\n * @return {ol.style.Fill} The cloned style.\n * @api\n */\n_ol_style_Fill_.prototype.clone = function() {\n  var color = this.getColor();\n  return new _ol_style_Fill_({\n    color: (color && color.slice) ? color.slice() : color || undefined\n  });\n};\n\n\n/**\n * Get the fill color.\n * @return {ol.Color|ol.ColorLike} Color.\n * @api\n */\n_ol_style_Fill_.prototype.getColor = function() {\n  return this.color_;\n};\n\n\n/**\n * Set the color.\n *\n * @param {ol.Color|ol.ColorLike} color Color.\n * @api\n */\n_ol_style_Fill_.prototype.setColor = function(color) {\n  this.color_ = color;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * @return {string} The checksum.\n */\n_ol_style_Fill_.prototype.getChecksum = function() {\n  if (this.checksum_ === undefined) {\n    if (\n        this.color_ instanceof CanvasPattern ||\n        this.color_ instanceof CanvasGradient\n    ) {\n      this.checksum_ = _ol_.getUid(this.color_).toString();\n    } else {\n      this.checksum_ = 'f' + (this.color_ ?\n          _ol_color_.asString(this.color_) : '-');\n    }\n  }\n\n  return this.checksum_;\n};\nexport default _ol_style_Fill_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/style/fill.js\n// module id = 89\n// module chunks = 0","/**\n * @classdesc\n * A base class used for creating subclasses and not instantiated in\n * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and\n * {@link ol.style.RegularShape}.\n *\n * @constructor\n * @abstract\n * @param {ol.StyleImageOptions} options Options.\n * @api\n */\nvar _ol_style_Image_ = function(options) {\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.opacity_ = options.opacity;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.rotateWithView_ = options.rotateWithView;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.rotation_ = options.rotation;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.scale_ = options.scale;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.snapToPixel_ = options.snapToPixel;\n\n};\n\n\n/**\n * Get the symbolizer opacity.\n * @return {number} Opacity.\n * @api\n */\n_ol_style_Image_.prototype.getOpacity = function() {\n  return this.opacity_;\n};\n\n\n/**\n * Determine whether the symbolizer rotates with the map.\n * @return {boolean} Rotate with map.\n * @api\n */\n_ol_style_Image_.prototype.getRotateWithView = function() {\n  return this.rotateWithView_;\n};\n\n\n/**\n * Get the symoblizer rotation.\n * @return {number} Rotation.\n * @api\n */\n_ol_style_Image_.prototype.getRotation = function() {\n  return this.rotation_;\n};\n\n\n/**\n * Get the symbolizer scale.\n * @return {number} Scale.\n * @api\n */\n_ol_style_Image_.prototype.getScale = function() {\n  return this.scale_;\n};\n\n\n/**\n * Determine whether the symbolizer should be snapped to a pixel.\n * @return {boolean} The symbolizer should snap to a pixel.\n * @api\n */\n_ol_style_Image_.prototype.getSnapToPixel = function() {\n  return this.snapToPixel_;\n};\n\n\n/**\n * Get the anchor point in pixels. The anchor determines the center point for the\n * symbolizer.\n * @abstract\n * @return {Array.<number>} Anchor.\n */\n_ol_style_Image_.prototype.getAnchor = function() {};\n\n\n/**\n * Get the image element for the symbolizer.\n * @abstract\n * @param {number} pixelRatio Pixel ratio.\n * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.\n */\n_ol_style_Image_.prototype.getImage = function(pixelRatio) {};\n\n\n/**\n * @abstract\n * @param {number} pixelRatio Pixel ratio.\n * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.\n */\n_ol_style_Image_.prototype.getHitDetectionImage = function(pixelRatio) {};\n\n\n/**\n * @abstract\n * @return {ol.ImageState} Image state.\n */\n_ol_style_Image_.prototype.getImageState = function() {};\n\n\n/**\n * @abstract\n * @return {ol.Size} Image size.\n */\n_ol_style_Image_.prototype.getImageSize = function() {};\n\n\n/**\n * @abstract\n * @return {ol.Size} Size of the hit-detection image.\n */\n_ol_style_Image_.prototype.getHitDetectionImageSize = function() {};\n\n\n/**\n * Get the origin of the symbolizer.\n * @abstract\n * @return {Array.<number>} Origin.\n */\n_ol_style_Image_.prototype.getOrigin = function() {};\n\n\n/**\n * Get the size of the symbolizer (in pixels).\n * @abstract\n * @return {ol.Size} Size.\n */\n_ol_style_Image_.prototype.getSize = function() {};\n\n\n/**\n * Set the opacity.\n *\n * @param {number} opacity Opacity.\n * @api\n */\n_ol_style_Image_.prototype.setOpacity = function(opacity) {\n  this.opacity_ = opacity;\n};\n\n\n/**\n * Set whether to rotate the style with the view.\n *\n * @param {boolean} rotateWithView Rotate with map.\n */\n_ol_style_Image_.prototype.setRotateWithView = function(rotateWithView) {\n  this.rotateWithView_ = rotateWithView;\n};\n\n\n/**\n * Set the rotation.\n *\n * @param {number} rotation Rotation.\n * @api\n */\n_ol_style_Image_.prototype.setRotation = function(rotation) {\n  this.rotation_ = rotation;\n};\n\n\n/**\n * Set the scale.\n *\n * @param {number} scale Scale.\n * @api\n */\n_ol_style_Image_.prototype.setScale = function(scale) {\n  this.scale_ = scale;\n};\n\n\n/**\n * Set whether to snap the image to the closest pixel.\n *\n * @param {boolean} snapToPixel Snap to pixel?\n */\n_ol_style_Image_.prototype.setSnapToPixel = function(snapToPixel) {\n  this.snapToPixel_ = snapToPixel;\n};\n\n\n/**\n * @abstract\n * @param {function(this: T, ol.events.Event)} listener Listener function.\n * @param {T} thisArg Value to use as `this` when executing `listener`.\n * @return {ol.EventsKey|undefined} Listener key.\n * @template T\n */\n_ol_style_Image_.prototype.listenImageChange = function(listener, thisArg) {};\n\n\n/**\n * Load not yet loaded URI.\n * @abstract\n */\n_ol_style_Image_.prototype.load = function() {};\n\n\n/**\n * @abstract\n * @param {function(this: T, ol.events.Event)} listener Listener function.\n * @param {T} thisArg Value to use as `this` when executing `listener`.\n * @template T\n */\n_ol_style_Image_.prototype.unlistenImageChange = function(listener, thisArg) {};\nexport default _ol_style_Image_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/style/image.js\n// module id = 90\n// module chunks = 0","import _ol_ from '../index';\nimport _ol_colorlike_ from '../colorlike';\nimport _ol_dom_ from '../dom';\nimport _ol_has_ from '../has';\nimport _ol_ImageState_ from '../imagestate';\nimport _ol_render_canvas_ from '../render/canvas';\nimport _ol_style_Image_ from '../style/image';\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n *\n * @constructor\n * @param {olx.style.RegularShapeOptions} options Options.\n * @extends {ol.style.Image}\n * @api\n */\nvar _ol_style_RegularShape_ = function(options) {\n  /**\n   * @private\n   * @type {Array.<string>}\n   */\n  this.checksums_ = null;\n\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n  this.canvas_ = null;\n\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n  this.hitDetectionCanvas_ = null;\n\n  /**\n   * @private\n   * @type {ol.style.Fill}\n   */\n  this.fill_ = options.fill !== undefined ? options.fill : null;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.origin_ = [0, 0];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.points_ = options.points;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.radius_ = /** @type {number} */ (options.radius !== undefined ?\n      options.radius : options.radius1);\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.radius2_ =\n      options.radius2 !== undefined ? options.radius2 : this.radius_;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n  /**\n   * @private\n   * @type {ol.style.Stroke}\n   */\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.anchor_ = null;\n\n  /**\n   * @private\n   * @type {ol.Size}\n   */\n  this.size_ = null;\n\n  /**\n   * @private\n   * @type {ol.Size}\n   */\n  this.imageSize_ = null;\n\n  /**\n   * @private\n   * @type {ol.Size}\n   */\n  this.hitDetectionImageSize_ = null;\n\n  /**\n   * @protected\n   * @type {ol.style.AtlasManager|undefined}\n   */\n  this.atlasManager_ = options.atlasManager;\n\n  this.render_(this.atlasManager_);\n\n  /**\n   * @type {boolean}\n   */\n  var snapToPixel = options.snapToPixel !== undefined ?\n      options.snapToPixel : true;\n\n  /**\n   * @type {boolean}\n   */\n  var rotateWithView = options.rotateWithView !== undefined ?\n      options.rotateWithView : false;\n\n  _ol_style_Image_.call(this, {\n    opacity: 1,\n    rotateWithView: rotateWithView,\n    rotation: options.rotation !== undefined ? options.rotation : 0,\n    scale: 1,\n    snapToPixel: snapToPixel\n  });\n};\n\n_ol_.inherits(_ol_style_RegularShape_, _ol_style_Image_);\n\n\n/**\n * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n * @return {ol.style.RegularShape} The cloned style.\n * @api\n */\n_ol_style_RegularShape_.prototype.clone = function() {\n  var style = new _ol_style_RegularShape_({\n    fill: this.getFill() ? this.getFill().clone() : undefined,\n    points: this.getRadius2() !== this.getRadius() ? this.getPoints() / 2 : this.getPoints(),\n    radius: this.getRadius(),\n    radius2: this.getRadius2(),\n    angle: this.getAngle(),\n    snapToPixel: this.getSnapToPixel(),\n    stroke: this.getStroke() ?  this.getStroke().clone() : undefined,\n    rotation: this.getRotation(),\n    rotateWithView: this.getRotateWithView(),\n    atlasManager: this.atlasManager_\n  });\n  style.setOpacity(this.getOpacity());\n  style.setScale(this.getScale());\n  return style;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_style_RegularShape_.prototype.getAnchor = function() {\n  return this.anchor_;\n};\n\n\n/**\n * Get the angle used in generating the shape.\n * @return {number} Shape's rotation in radians.\n * @api\n */\n_ol_style_RegularShape_.prototype.getAngle = function() {\n  return this.angle_;\n};\n\n\n/**\n * Get the fill style for the shape.\n * @return {ol.style.Fill} Fill style.\n * @api\n */\n_ol_style_RegularShape_.prototype.getFill = function() {\n  return this.fill_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.getHitDetectionImage = function(pixelRatio) {\n  return this.hitDetectionCanvas_;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_style_RegularShape_.prototype.getImage = function(pixelRatio) {\n  return this.canvas_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.getImageSize = function() {\n  return this.imageSize_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.getHitDetectionImageSize = function() {\n  return this.hitDetectionImageSize_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.getImageState = function() {\n  return _ol_ImageState_.LOADED;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_style_RegularShape_.prototype.getOrigin = function() {\n  return this.origin_;\n};\n\n\n/**\n * Get the number of points for generating the shape.\n * @return {number} Number of points for stars and regular polygons.\n * @api\n */\n_ol_style_RegularShape_.prototype.getPoints = function() {\n  return this.points_;\n};\n\n\n/**\n * Get the (primary) radius for the shape.\n * @return {number} Radius.\n * @api\n */\n_ol_style_RegularShape_.prototype.getRadius = function() {\n  return this.radius_;\n};\n\n\n/**\n * Get the secondary radius for the shape.\n * @return {number} Radius2.\n * @api\n */\n_ol_style_RegularShape_.prototype.getRadius2 = function() {\n  return this.radius2_;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_style_RegularShape_.prototype.getSize = function() {\n  return this.size_;\n};\n\n\n/**\n * Get the stroke style for the shape.\n * @return {ol.style.Stroke} Stroke style.\n * @api\n */\n_ol_style_RegularShape_.prototype.getStroke = function() {\n  return this.stroke_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.listenImageChange = function(listener, thisArg) {};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.load = function() {};\n\n\n/**\n * @inheritDoc\n */\n_ol_style_RegularShape_.prototype.unlistenImageChange = function(listener, thisArg) {};\n\n\n/**\n * @protected\n * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.\n */\n_ol_style_RegularShape_.prototype.render_ = function(atlasManager) {\n  var imageSize;\n  var lineCap = '';\n  var lineJoin = '';\n  var miterLimit = 0;\n  var lineDash = null;\n  var strokeStyle;\n  var strokeWidth = 0;\n\n  if (this.stroke_) {\n    strokeStyle = this.stroke_.getColor();\n    if (strokeStyle === null) {\n      strokeStyle = _ol_render_canvas_.defaultStrokeStyle;\n    }\n    strokeStyle = _ol_colorlike_.asColorLike(strokeStyle);\n    strokeWidth = this.stroke_.getWidth();\n    if (strokeWidth === undefined) {\n      strokeWidth = _ol_render_canvas_.defaultLineWidth;\n    }\n    lineDash = this.stroke_.getLineDash();\n    if (!_ol_has_.CANVAS_LINE_DASH) {\n      lineDash = null;\n    }\n    lineJoin = this.stroke_.getLineJoin();\n    if (lineJoin === undefined) {\n      lineJoin = _ol_render_canvas_.defaultLineJoin;\n    }\n    lineCap = this.stroke_.getLineCap();\n    if (lineCap === undefined) {\n      lineCap = _ol_render_canvas_.defaultLineCap;\n    }\n    miterLimit = this.stroke_.getMiterLimit();\n    if (miterLimit === undefined) {\n      miterLimit = _ol_render_canvas_.defaultMiterLimit;\n    }\n  }\n\n  var size = 2 * (this.radius_ + strokeWidth) + 1;\n\n  /** @type {ol.RegularShapeRenderOptions} */\n  var renderOptions = {\n    strokeStyle: strokeStyle,\n    strokeWidth: strokeWidth,\n    size: size,\n    lineCap: lineCap,\n    lineDash: lineDash,\n    lineJoin: lineJoin,\n    miterLimit: miterLimit\n  };\n\n  if (atlasManager === undefined) {\n    // no atlas manager is used, create a new canvas\n    var context = _ol_dom_.createCanvasContext2D(size, size);\n    this.canvas_ = context.canvas;\n\n    // canvas.width and height are rounded to the closest integer\n    size = this.canvas_.width;\n    imageSize = size;\n\n    this.draw_(renderOptions, context, 0, 0);\n\n    this.createHitDetectionCanvas_(renderOptions);\n  } else {\n    // an atlas manager is used, add the symbol to an atlas\n    size = Math.round(size);\n\n    var hasCustomHitDetectionImage = !this.fill_;\n    var renderHitDetectionCallback;\n    if (hasCustomHitDetectionImage) {\n      // render the hit-detection image into a separate atlas image\n      renderHitDetectionCallback =\n          this.drawHitDetectionCanvas_.bind(this, renderOptions);\n    }\n\n    var id = this.getChecksum();\n    var info = atlasManager.add(\n        id, size, size, this.draw_.bind(this, renderOptions),\n        renderHitDetectionCallback);\n\n    this.canvas_ = info.image;\n    this.origin_ = [info.offsetX, info.offsetY];\n    imageSize = info.image.width;\n\n    if (hasCustomHitDetectionImage) {\n      this.hitDetectionCanvas_ = info.hitImage;\n      this.hitDetectionImageSize_ =\n          [info.hitImage.width, info.hitImage.height];\n    } else {\n      this.hitDetectionCanvas_ = this.canvas_;\n      this.hitDetectionImageSize_ = [imageSize, imageSize];\n    }\n  }\n\n  this.anchor_ = [size / 2, size / 2];\n  this.size_ = [size, size];\n  this.imageSize_ = [imageSize, imageSize];\n};\n\n\n/**\n * @private\n * @param {ol.RegularShapeRenderOptions} renderOptions Render options.\n * @param {CanvasRenderingContext2D} context The rendering context.\n * @param {number} x The origin for the symbol (x).\n * @param {number} y The origin for the symbol (y).\n */\n_ol_style_RegularShape_.prototype.draw_ = function(renderOptions, context, x, y) {\n  var i, angle0, radiusC;\n  // reset transform\n  context.setTransform(1, 0, 0, 1, 0, 0);\n\n  // then move to (x, y)\n  context.translate(x, y);\n\n  context.beginPath();\n\n  if (this.points_ === Infinity) {\n    context.arc(\n        renderOptions.size / 2, renderOptions.size / 2,\n        this.radius_, 0, 2 * Math.PI, true);\n  } else {\n    if (this.radius2_ !== this.radius_) {\n      this.points_ = 2 * this.points_;\n    }\n    for (i = 0; i <= this.points_; i++) {\n      angle0 = i * 2 * Math.PI / this.points_ - Math.PI / 2 + this.angle_;\n      radiusC = i % 2 === 0 ? this.radius_ : this.radius2_;\n      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n                     renderOptions.size / 2 + radiusC * Math.sin(angle0));\n    }\n  }\n\n\n  if (this.fill_) {\n    var color = this.fill_.getColor();\n    if (color === null) {\n      color = _ol_render_canvas_.defaultFillStyle;\n    }\n    context.fillStyle = _ol_colorlike_.asColorLike(color);\n    context.fill();\n  }\n  if (this.stroke_) {\n    context.strokeStyle = renderOptions.strokeStyle;\n    context.lineWidth = renderOptions.strokeWidth;\n    if (renderOptions.lineDash) {\n      context.setLineDash(renderOptions.lineDash);\n    }\n    context.lineCap = renderOptions.lineCap;\n    context.lineJoin = renderOptions.lineJoin;\n    context.miterLimit = renderOptions.miterLimit;\n    context.stroke();\n  }\n  context.closePath();\n};\n\n\n/**\n * @private\n * @param {ol.RegularShapeRenderOptions} renderOptions Render options.\n */\n_ol_style_RegularShape_.prototype.createHitDetectionCanvas_ = function(renderOptions) {\n  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n  if (this.fill_) {\n    this.hitDetectionCanvas_ = this.canvas_;\n    return;\n  }\n\n  // if no fill style is set, create an extra hit-detection image with a\n  // default fill style\n  var context = _ol_dom_.createCanvasContext2D(renderOptions.size, renderOptions.size);\n  this.hitDetectionCanvas_ = context.canvas;\n\n  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n};\n\n\n/**\n * @private\n * @param {ol.RegularShapeRenderOptions} renderOptions Render options.\n * @param {CanvasRenderingContext2D} context The context.\n * @param {number} x The origin for the symbol (x).\n * @param {number} y The origin for the symbol (y).\n */\n_ol_style_RegularShape_.prototype.drawHitDetectionCanvas_ = function(renderOptions, context, x, y) {\n  // reset transform\n  context.setTransform(1, 0, 0, 1, 0, 0);\n\n  // then move to (x, y)\n  context.translate(x, y);\n\n  context.beginPath();\n\n  if (this.points_ === Infinity) {\n    context.arc(\n        renderOptions.size / 2, renderOptions.size / 2,\n        this.radius_, 0, 2 * Math.PI, true);\n  } else {\n    if (this.radius2_ !== this.radius_) {\n      this.points_ = 2 * this.points_;\n    }\n    var i, radiusC, angle0;\n    for (i = 0; i <= this.points_; i++) {\n      angle0 = i * 2 * Math.PI / this.points_ - Math.PI / 2 + this.angle_;\n      radiusC = i % 2 === 0 ? this.radius_ : this.radius2_;\n      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n                     renderOptions.size / 2 + radiusC * Math.sin(angle0));\n    }\n  }\n\n  context.fillStyle = _ol_render_canvas_.defaultFillStyle;\n  context.fill();\n  if (this.stroke_) {\n    context.strokeStyle = renderOptions.strokeStyle;\n    context.lineWidth = renderOptions.strokeWidth;\n    if (renderOptions.lineDash) {\n      context.setLineDash(renderOptions.lineDash);\n    }\n    context.stroke();\n  }\n  context.closePath();\n};\n\n\n/**\n * @return {string} The checksum.\n */\n_ol_style_RegularShape_.prototype.getChecksum = function() {\n  var strokeChecksum = this.stroke_ ?\n      this.stroke_.getChecksum() : '-';\n  var fillChecksum = this.fill_ ?\n      this.fill_.getChecksum() : '-';\n\n  var recalculate = !this.checksums_ ||\n      (strokeChecksum != this.checksums_[1] ||\n      fillChecksum != this.checksums_[2] ||\n      this.radius_ != this.checksums_[3] ||\n      this.radius2_ != this.checksums_[4] ||\n      this.angle_ != this.checksums_[5] ||\n      this.points_ != this.checksums_[6]);\n\n  if (recalculate) {\n    var checksum = 'r' + strokeChecksum + fillChecksum +\n        (this.radius_ !== undefined ? this.radius_.toString() : '-') +\n        (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +\n        (this.angle_ !== undefined ? this.angle_.toString() : '-') +\n        (this.points_ !== undefined ? this.points_.toString() : '-');\n    this.checksums_ = [checksum, strokeChecksum, fillChecksum,\n      this.radius_, this.radius2_, this.angle_, this.points_];\n  }\n\n  return this.checksums_[0];\n};\nexport default _ol_style_RegularShape_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/style/regularshape.js\n// module id = 91\n// module chunks = 0","import _ol_ from '../index';\n\n/**\n * @classdesc\n * Set stroke style for vector features.\n * Note that the defaults given are the Canvas defaults, which will be used if\n * option is not defined. The `get` functions return whatever was entered in\n * the options; they will not return the default.\n *\n * @constructor\n * @param {olx.style.StrokeOptions=} opt_options Options.\n * @api\n */\nvar _ol_style_Stroke_ = function(opt_options) {\n\n  var options = opt_options || {};\n\n  /**\n   * @private\n   * @type {ol.Color|ol.ColorLike}\n   */\n  this.color_ = options.color !== undefined ? options.color : null;\n\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n  this.lineCap_ = options.lineCap;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.lineDashOffset_ = options.lineDashOffset;\n\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n  this.lineJoin_ = options.lineJoin;\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.miterLimit_ = options.miterLimit;\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.width_ = options.width;\n\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Clones the style.\n * @return {ol.style.Stroke} The cloned style.\n * @api\n */\n_ol_style_Stroke_.prototype.clone = function() {\n  var color = this.getColor();\n  return new _ol_style_Stroke_({\n    color: (color && color.slice) ? color.slice() : color || undefined,\n    lineCap: this.getLineCap(),\n    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,\n    lineDashOffset: this.getLineDashOffset(),\n    lineJoin: this.getLineJoin(),\n    miterLimit: this.getMiterLimit(),\n    width: this.getWidth()\n  });\n};\n\n\n/**\n * Get the stroke color.\n * @return {ol.Color|ol.ColorLike} Color.\n * @api\n */\n_ol_style_Stroke_.prototype.getColor = function() {\n  return this.color_;\n};\n\n\n/**\n * Get the line cap type for the stroke.\n * @return {string|undefined} Line cap.\n * @api\n */\n_ol_style_Stroke_.prototype.getLineCap = function() {\n  return this.lineCap_;\n};\n\n\n/**\n * Get the line dash style for the stroke.\n * @return {Array.<number>} Line dash.\n * @api\n */\n_ol_style_Stroke_.prototype.getLineDash = function() {\n  return this.lineDash_;\n};\n\n\n/**\n * Get the line dash offset for the stroke.\n * @return {number|undefined} Line dash offset.\n * @api\n */\n_ol_style_Stroke_.prototype.getLineDashOffset = function() {\n  return this.lineDashOffset_;\n};\n\n\n/**\n * Get the line join type for the stroke.\n * @return {string|undefined} Line join.\n * @api\n */\n_ol_style_Stroke_.prototype.getLineJoin = function() {\n  return this.lineJoin_;\n};\n\n\n/**\n * Get the miter limit for the stroke.\n * @return {number|undefined} Miter limit.\n * @api\n */\n_ol_style_Stroke_.prototype.getMiterLimit = function() {\n  return this.miterLimit_;\n};\n\n\n/**\n * Get the stroke width.\n * @return {number|undefined} Width.\n * @api\n */\n_ol_style_Stroke_.prototype.getWidth = function() {\n  return this.width_;\n};\n\n\n/**\n * Set the color.\n *\n * @param {ol.Color|ol.ColorLike} color Color.\n * @api\n */\n_ol_style_Stroke_.prototype.setColor = function(color) {\n  this.color_ = color;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Set the line cap.\n *\n * @param {string|undefined} lineCap Line cap.\n * @api\n */\n_ol_style_Stroke_.prototype.setLineCap = function(lineCap) {\n  this.lineCap_ = lineCap;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Set the line dash.\n *\n * Please note that Internet Explorer 10 and lower [do not support][mdn] the\n * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this\n * property will have no visual effect in these browsers.\n *\n * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility\n *\n * @param {Array.<number>} lineDash Line dash.\n * @api\n */\n_ol_style_Stroke_.prototype.setLineDash = function(lineDash) {\n  this.lineDash_ = lineDash;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Set the line dash offset.\n *\n * @param {number|undefined} lineDashOffset Line dash offset.\n * @api\n */\n_ol_style_Stroke_.prototype.setLineDashOffset = function(lineDashOffset) {\n  this.lineDashOffset_ = lineDashOffset;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Set the line join.\n *\n * @param {string|undefined} lineJoin Line join.\n * @api\n */\n_ol_style_Stroke_.prototype.setLineJoin = function(lineJoin) {\n  this.lineJoin_ = lineJoin;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Set the miter limit.\n *\n * @param {number|undefined} miterLimit Miter limit.\n * @api\n */\n_ol_style_Stroke_.prototype.setMiterLimit = function(miterLimit) {\n  this.miterLimit_ = miterLimit;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * Set the width.\n *\n * @param {number|undefined} width Width.\n * @api\n */\n_ol_style_Stroke_.prototype.setWidth = function(width) {\n  this.width_ = width;\n  this.checksum_ = undefined;\n};\n\n\n/**\n * @return {string} The checksum.\n */\n_ol_style_Stroke_.prototype.getChecksum = function() {\n  if (this.checksum_ === undefined) {\n    this.checksum_ = 's';\n    if (this.color_) {\n      if (typeof this.color_ === 'string') {\n        this.checksum_ += this.color_;\n      } else {\n        this.checksum_ += _ol_.getUid(this.color_).toString();\n      }\n    } else {\n      this.checksum_ += '-';\n    }\n    this.checksum_ += ',' +\n        (this.lineCap_ !== undefined ?\n            this.lineCap_.toString() : '-') + ',' +\n        (this.lineDash_ ?\n            this.lineDash_.toString() : '-') + ',' +\n        (this.lineDashOffset_ !== undefined ?\n            this.lineDashOffset_ : '-') + ',' +\n        (this.lineJoin_ !== undefined ?\n            this.lineJoin_ : '-') + ',' +\n        (this.miterLimit_ !== undefined ?\n            this.miterLimit_.toString() : '-') + ',' +\n        (this.width_ !== undefined ?\n            this.width_.toString() : '-');\n  }\n\n  return this.checksum_;\n};\nexport default _ol_style_Stroke_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/style/stroke.js\n// module id = 92\n// module chunks = 0","import _ol_asserts_ from '../asserts';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype';\nimport _ol_style_Circle_ from '../style/circle';\nimport _ol_style_Fill_ from '../style/fill';\nimport _ol_style_Stroke_ from '../style/stroke';\n\n/**\n * @classdesc\n * Container for vector feature rendering styles. Any changes made to the style\n * or its children through `set*()` methods will not take effect until the\n * feature or layer that uses the style is re-rendered.\n *\n * @constructor\n * @struct\n * @param {olx.style.StyleOptions=} opt_options Style options.\n * @api\n */\nvar _ol_style_Style_ = function(opt_options) {\n\n  var options = opt_options || {};\n\n  /**\n   * @private\n   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}\n   */\n  this.geometry_ = null;\n\n  /**\n   * @private\n   * @type {!ol.StyleGeometryFunction}\n   */\n  this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;\n\n  if (options.geometry !== undefined) {\n    this.setGeometry(options.geometry);\n  }\n\n  /**\n   * @private\n   * @type {ol.style.Fill}\n   */\n  this.fill_ = options.fill !== undefined ? options.fill : null;\n\n  /**\n   * @private\n   * @type {ol.style.Image}\n   */\n  this.image_ = options.image !== undefined ? options.image : null;\n\n  /**\n   * @private\n   * @type {ol.style.Stroke}\n   */\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n  /**\n   * @private\n   * @type {ol.style.Text}\n   */\n  this.text_ = options.text !== undefined ? options.text : null;\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.zIndex_ = options.zIndex;\n\n};\n\n\n/**\n * Clones the style.\n * @return {ol.style.Style} The cloned style.\n * @api\n */\n_ol_style_Style_.prototype.clone = function() {\n  var geometry = this.getGeometry();\n  if (geometry && geometry.clone) {\n    geometry = geometry.clone();\n  }\n  return new _ol_style_Style_({\n    geometry: geometry,\n    fill: this.getFill() ? this.getFill().clone() : undefined,\n    image: this.getImage() ? this.getImage().clone() : undefined,\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n    text: this.getText() ? this.getText().clone() : undefined,\n    zIndex: this.getZIndex()\n  });\n};\n\n\n/**\n * Get the geometry to be rendered.\n * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}\n * Feature property or geometry or function that returns the geometry that will\n * be rendered with this style.\n * @api\n */\n_ol_style_Style_.prototype.getGeometry = function() {\n  return this.geometry_;\n};\n\n\n/**\n * Get the function used to generate a geometry for rendering.\n * @return {!ol.StyleGeometryFunction} Function that is called with a feature\n * and returns the geometry to render instead of the feature's geometry.\n * @api\n */\n_ol_style_Style_.prototype.getGeometryFunction = function() {\n  return this.geometryFunction_;\n};\n\n\n/**\n * Get the fill style.\n * @return {ol.style.Fill} Fill style.\n * @api\n */\n_ol_style_Style_.prototype.getFill = function() {\n  return this.fill_;\n};\n\n\n/**\n * Set the fill style.\n * @param {ol.style.Fill} fill Fill style.\n * @api\n */\n_ol_style_Style_.prototype.setFill = function(fill) {\n  this.fill_ = fill;\n};\n\n\n/**\n * Get the image style.\n * @return {ol.style.Image} Image style.\n * @api\n */\n_ol_style_Style_.prototype.getImage = function() {\n  return this.image_;\n};\n\n\n/**\n * Set the image style.\n * @param {ol.style.Image} image Image style.\n * @api\n */\n_ol_style_Style_.prototype.setImage = function(image) {\n  this.image_ = image;\n};\n\n\n/**\n * Get the stroke style.\n * @return {ol.style.Stroke} Stroke style.\n * @api\n */\n_ol_style_Style_.prototype.getStroke = function() {\n  return this.stroke_;\n};\n\n\n/**\n * Set the stroke style.\n * @param {ol.style.Stroke} stroke Stroke style.\n * @api\n */\n_ol_style_Style_.prototype.setStroke = function(stroke) {\n  this.stroke_ = stroke;\n};\n\n\n/**\n * Get the text style.\n * @return {ol.style.Text} Text style.\n * @api\n */\n_ol_style_Style_.prototype.getText = function() {\n  return this.text_;\n};\n\n\n/**\n * Set the text style.\n * @param {ol.style.Text} text Text style.\n * @api\n */\n_ol_style_Style_.prototype.setText = function(text) {\n  this.text_ = text;\n};\n\n\n/**\n * Get the z-index for the style.\n * @return {number|undefined} ZIndex.\n * @api\n */\n_ol_style_Style_.prototype.getZIndex = function() {\n  return this.zIndex_;\n};\n\n\n/**\n * Set a geometry that is rendered instead of the feature's geometry.\n *\n * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry\n *     Feature property or geometry or function returning a geometry to render\n *     for this style.\n * @api\n */\n_ol_style_Style_.prototype.setGeometry = function(geometry) {\n  if (typeof geometry === 'function') {\n    this.geometryFunction_ = geometry;\n  } else if (typeof geometry === 'string') {\n    this.geometryFunction_ = function(feature) {\n      return /** @type {ol.geom.Geometry} */ (feature.get(geometry));\n    };\n  } else if (!geometry) {\n    this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;\n  } else if (geometry !== undefined) {\n    this.geometryFunction_ = function() {\n      return /** @type {ol.geom.Geometry} */ (geometry);\n    };\n  }\n  this.geometry_ = geometry;\n};\n\n\n/**\n * Set the z-index.\n *\n * @param {number|undefined} zIndex ZIndex.\n * @api\n */\n_ol_style_Style_.prototype.setZIndex = function(zIndex) {\n  this.zIndex_ = zIndex;\n};\n\n\n/**\n * Convert the provided object into a style function.  Functions passed through\n * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a\n * new style function.\n * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj\n *     A style function, a single style, or an array of styles.\n * @return {ol.StyleFunction} A style function.\n */\n_ol_style_Style_.createFunction = function(obj) {\n  var styleFunction;\n\n  if (typeof obj === 'function') {\n    styleFunction = obj;\n  } else {\n    /**\n     * @type {Array.<ol.style.Style>}\n     */\n    var styles;\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      _ol_asserts_.assert(obj instanceof _ol_style_Style_,\n          41); // Expected an `ol.style.Style` or an array of `ol.style.Style`\n      styles = [obj];\n    }\n    styleFunction = function() {\n      return styles;\n    };\n  }\n  return styleFunction;\n};\n\n\n/**\n * @type {Array.<ol.style.Style>}\n * @private\n */\n_ol_style_Style_.default_ = null;\n\n\n/**\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n * @param {number} resolution Resolution.\n * @return {Array.<ol.style.Style>} Style.\n */\n_ol_style_Style_.defaultFunction = function(feature, resolution) {\n  // We don't use an immediately-invoked function\n  // and a closure so we don't get an error at script evaluation time in\n  // browsers that do not support Canvas. (ol.style.Circle does\n  // canvas.getContext('2d') at construction time, which will cause an.error\n  // in such browsers.)\n  if (!_ol_style_Style_.default_) {\n    var fill = new _ol_style_Fill_({\n      color: 'rgba(255,255,255,0.4)'\n    });\n    var stroke = new _ol_style_Stroke_({\n      color: '#3399CC',\n      width: 1.25\n    });\n    _ol_style_Style_.default_ = [\n      new _ol_style_Style_({\n        image: new _ol_style_Circle_({\n          fill: fill,\n          stroke: stroke,\n          radius: 5\n        }),\n        fill: fill,\n        stroke: stroke\n      })\n    ];\n  }\n  return _ol_style_Style_.default_;\n};\n\n\n/**\n * Default styles for editing features.\n * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles\n */\n_ol_style_Style_.createDefaultEditing = function() {\n  /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */\n  var styles = {};\n  var white = [255, 255, 255, 1];\n  var blue = [0, 153, 255, 1];\n  var width = 3;\n  styles[_ol_geom_GeometryType_.POLYGON] = [\n    new _ol_style_Style_({\n      fill: new _ol_style_Fill_({\n        color: [255, 255, 255, 0.5]\n      })\n    })\n  ];\n  styles[_ol_geom_GeometryType_.MULTI_POLYGON] =\n      styles[_ol_geom_GeometryType_.POLYGON];\n\n  styles[_ol_geom_GeometryType_.LINE_STRING] = [\n    new _ol_style_Style_({\n      stroke: new _ol_style_Stroke_({\n        color: white,\n        width: width + 2\n      })\n    }),\n    new _ol_style_Style_({\n      stroke: new _ol_style_Stroke_({\n        color: blue,\n        width: width\n      })\n    })\n  ];\n  styles[_ol_geom_GeometryType_.MULTI_LINE_STRING] =\n      styles[_ol_geom_GeometryType_.LINE_STRING];\n\n  styles[_ol_geom_GeometryType_.CIRCLE] =\n      styles[_ol_geom_GeometryType_.POLYGON].concat(\n          styles[_ol_geom_GeometryType_.LINE_STRING]\n      );\n\n\n  styles[_ol_geom_GeometryType_.POINT] = [\n    new _ol_style_Style_({\n      image: new _ol_style_Circle_({\n        radius: width * 2,\n        fill: new _ol_style_Fill_({\n          color: blue\n        }),\n        stroke: new _ol_style_Stroke_({\n          color: white,\n          width: width / 2\n        })\n      }),\n      zIndex: Infinity\n    })\n  ];\n  styles[_ol_geom_GeometryType_.MULTI_POINT] =\n      styles[_ol_geom_GeometryType_.POINT];\n\n  styles[_ol_geom_GeometryType_.GEOMETRY_COLLECTION] =\n      styles[_ol_geom_GeometryType_.POLYGON].concat(\n          styles[_ol_geom_GeometryType_.LINE_STRING],\n          styles[_ol_geom_GeometryType_.POINT]\n      );\n\n  return styles;\n};\n\n\n/**\n * Function that is called with a feature and returns its default geometry.\n * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry\n *     for.\n * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.\n */\n_ol_style_Style_.defaultGeometryFunction = function(feature) {\n  return feature.getGeometry();\n};\nexport default _ol_style_Style_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/style/style.js\n// module id = 93\n// module chunks = 0","import _ol_ from './index';\nvar _ol_webgl_ = {};\n\n\nif (false) {\n\n  /** Constants taken from goog.webgl\n   */\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.ONE = 1;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.SRC_ALPHA = 0x0302;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.COLOR_ATTACHMENT0 = 0x8CE0;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.COLOR_BUFFER_BIT = 0x00004000;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TRIANGLES = 0x0004;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TRIANGLE_STRIP = 0x0005;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.ONE_MINUS_SRC_ALPHA = 0x0303;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.ARRAY_BUFFER = 0x8892;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.ELEMENT_ARRAY_BUFFER = 0x8893;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.STREAM_DRAW = 0x88E0;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.STATIC_DRAW = 0x88E4;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.DYNAMIC_DRAW = 0x88E8;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.CULL_FACE = 0x0B44;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.BLEND = 0x0BE2;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.STENCIL_TEST = 0x0B90;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.DEPTH_TEST = 0x0B71;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.SCISSOR_TEST = 0x0C11;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.UNSIGNED_BYTE = 0x1401;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.UNSIGNED_SHORT = 0x1403;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.UNSIGNED_INT = 0x1405;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.FLOAT = 0x1406;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.RGBA = 0x1908;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.FRAGMENT_SHADER = 0x8B30;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.VERTEX_SHADER = 0x8B31;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.LINK_STATUS = 0x8B82;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.LINEAR = 0x2601;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TEXTURE_MAG_FILTER = 0x2800;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TEXTURE_MIN_FILTER = 0x2801;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TEXTURE_WRAP_S = 0x2802;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TEXTURE_WRAP_T = 0x2803;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TEXTURE_2D = 0x0DE1;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.TEXTURE0 = 0x84C0;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.CLAMP_TO_EDGE = 0x812F;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.COMPILE_STATUS = 0x8B81;\n\n\n  /**\n   * @const\n   * @type {number}\n   */\n  _ol_webgl_.FRAMEBUFFER = 0x8D40;\n\n\n  /** end of goog.webgl constants\n   */\n\n\n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  _ol_webgl_.CONTEXT_IDS_ = [\n    'experimental-webgl',\n    'webgl',\n    'webkit-3d',\n    'moz-webgl'\n  ];\n\n\n  /**\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Object=} opt_attributes Attributes.\n   * @return {WebGLRenderingContext} WebGL rendering context.\n   */\n  _ol_webgl_.getContext = function(canvas, opt_attributes) {\n    var context, i, ii = _ol_webgl_.CONTEXT_IDS_.length;\n    for (i = 0; i < ii; ++i) {\n      try {\n        context = canvas.getContext(_ol_webgl_.CONTEXT_IDS_[i], opt_attributes);\n        if (context) {\n          return /** @type {!WebGLRenderingContext} */ (context);\n        }\n      } catch (e) {\n        // pass\n      }\n    }\n    return null;\n  };\n\n}\nexport default _ol_webgl_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ol/webgl.js\n// module id = 94\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 95\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(require('should-type'));\n\nfunction format(msg) {\n  var args = arguments;\n  for (var i = 1, l = args.length; i < l; i++) {\n    msg = msg.replace(/%s/, args[i]);\n  }\n  return msg;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction EqualityFail(a, b, reason, path) {\n  this.a = a;\n  this.b = b;\n  this.reason = reason;\n  this.path = path;\n}\n\nfunction typeToString(tp) {\n  return tp.type + (tp.cls ? '(' + tp.cls + (tp.sub ? ' ' + tp.sub : '') + ')' : '');\n}\n\nvar  PLUS_0_AND_MINUS_0 = '+0 is not equal to -0';\nvar  DIFFERENT_TYPES = 'A has type %s and B has type %s';\nvar  EQUALITY = 'A is not equal to B';\nvar  EQUALITY_PROTOTYPE = 'A and B have different prototypes';\nvar  WRAPPED_VALUE = 'A wrapped value is not equal to B wrapped value';\nvar  FUNCTION_SOURCES = 'function A is not equal to B by source code value (via .toString call)';\nvar  MISSING_KEY = '%s has no key %s';\nvar  SET_MAP_MISSING_KEY = 'Set/Map missing key %s';\n\n\nvar DEFAULT_OPTIONS = {\n  checkProtoEql: true,\n  checkSubType: true,\n  plusZeroAndMinusZeroEqual: true,\n  collectAllFails: false\n};\n\nfunction setBooleanDefault(property, obj, opts, defaults) {\n  obj[property] = typeof opts[property] !== 'boolean' ? defaults[property] : opts[property];\n}\n\nvar METHOD_PREFIX = '_check_';\n\nfunction EQ(opts, a, b, path) {\n  opts = opts || {};\n\n  setBooleanDefault('checkProtoEql', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('plusZeroAndMinusZeroEqual', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('checkSubType', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('collectAllFails', this, opts, DEFAULT_OPTIONS);\n\n  this.a = a;\n  this.b = b;\n\n  this._meet = opts._meet || [];\n\n  this.fails = opts.fails || [];\n\n  this.path = path || [];\n}\n\nfunction ShortcutError(fail) {\n  this.name = 'ShortcutError';\n  this.message = 'fail fast';\n  this.fail = fail;\n}\n\nShortcutError.prototype = Object.create(Error.prototype);\n\nEQ.checkStrictEquality = function(a, b) {\n  this.collectFail(a !== b, EQUALITY);\n};\n\nEQ.add = function add(type, cls, sub, f) {\n  var args = Array.prototype.slice.call(arguments);\n  f = args.pop();\n  EQ.prototype[METHOD_PREFIX + args.join('_')] = f;\n};\n\nEQ.prototype = {\n  check: function() {\n    try {\n      this.check0();\n    } catch (e) {\n      if (e instanceof ShortcutError) {\n        return [e.fail];\n      }\n      throw e;\n    }\n    return this.fails;\n  },\n\n  check0: function() {\n    var a = this.a;\n    var b = this.b;\n\n    // equal a and b exit early\n    if (a === b) {\n      // check for +0 !== -0;\n      return this.collectFail(a === 0 && (1 / a !== 1 / b) && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);\n    }\n\n    var typeA = t(a);\n    var typeB = t(b);\n\n    // if objects has different types they are not equal\n    if (typeA.type !== typeB.type || typeA.cls !== typeB.cls || typeA.sub !== typeB.sub) {\n      return this.collectFail(true, format(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));\n    }\n\n    // as types the same checks type specific things\n    var name1 = typeA.type, name2 = typeA.type;\n    if (typeA.cls) {\n      name1 += '_' + typeA.cls;\n      name2 += '_' + typeA.cls;\n    }\n    if (typeA.sub) {\n      name2 += '_' + typeA.sub;\n    }\n\n    var f = this[METHOD_PREFIX + name2] || this[METHOD_PREFIX + name1] || this[METHOD_PREFIX + typeA.type] || this.defaultCheck;\n\n    f.call(this, this.a, this.b);\n  },\n\n  collectFail: function(comparison, reason, showReason) {\n    if (comparison) {\n      var res = new EqualityFail(this.a, this.b, reason, this.path);\n      res.showReason = !!showReason;\n\n      this.fails.push(res);\n\n      if (!this.collectAllFails) {\n        throw new ShortcutError(res);\n      }\n    }\n  },\n\n  checkPlainObjectsEquality: function(a, b) {\n    // compare deep objects and arrays\n    // stacks contain references only\n    //\n    var meet = this._meet;\n    var m = this._meet.length;\n    while (m--) {\n      var st = meet[m];\n      if (st[0] === a && st[1] === b) {\n        return;\n      }\n    }\n\n    // add `a` and `b` to the stack of traversed objects\n    meet.push([a, b]);\n\n    // TODO maybe something else like getOwnPropertyNames\n    var key;\n    for (key in b) {\n      if (hasOwnProperty.call(b, key)) {\n        if (hasOwnProperty.call(a, key)) {\n          this.checkPropertyEquality(key);\n        } else {\n          this.collectFail(true, format(MISSING_KEY, 'A', key));\n        }\n      }\n    }\n\n    // ensure both objects have the same number of properties\n    for (key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        this.collectFail(!hasOwnProperty.call(b, key), format(MISSING_KEY, 'B', key));\n      }\n    }\n\n    meet.pop();\n\n    if (this.checkProtoEql) {\n      //TODO should i check prototypes for === or use eq?\n      this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);\n    }\n\n  },\n\n  checkPropertyEquality: function(propertyName) {\n    var _eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));\n    _eq.check0();\n  },\n\n  defaultCheck: EQ.checkStrictEquality\n};\n\n\nEQ.add(t.NUMBER, function(a, b) {\n  this.collectFail((a !== a && b === b) || (b !== b && a === a) || (a !== b && a === a && b === b), EQUALITY);\n});\n\n[t.SYMBOL, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(tp, EQ.checkStrictEquality);\n});\n\nEQ.add(t.FUNCTION, function(a, b) {\n  // functions are compared by their source code\n  this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.REGEXP, function(a, b) {\n  // check regexp flags\n  var flags = ['source', 'global', 'multiline', 'lastIndex', 'ignoreCase', 'sticky', 'unicode'];\n  while (flags.length) {\n    this.checkPropertyEquality(flags.shift());\n  }\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.DATE, function(a, b) {\n  //check by timestamp only (using .valueOf)\n  this.collectFail(+a !== +b, EQUALITY);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.NUMBER, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    //primitive type wrappers\n    this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);\n    // check user properties\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, function(a, b) {\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.ARRAY, t.ARGUMENTS, t.TYPED_ARRAY].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this.checkPropertyEquality('length');\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, t.ARRAY_BUFFER, function(a, b) {\n  this.checkPropertyEquality('byteLength');\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.ERROR, function(a, b) {\n  this.checkPropertyEquality('name');\n  this.checkPropertyEquality('message');\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.BUFFER, function(a) {\n  this.checkPropertyEquality('length');\n\n  var l = a.length;\n  while (l--) {\n    this.checkPropertyEquality(l);\n  }\n\n  //we do not check for user properties because\n  //node Buffer have some strange hidden properties\n});\n\n[t.MAP, t.SET, t.WEAK_MAP, t.WEAK_SET].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this._meet.push([a, b]);\n\n    var iteratorA = a.entries();\n    for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {\n\n      var iteratorB = b.entries();\n      var keyFound = false;\n      for (var nextB = iteratorB.next(); !nextB.done; nextB = iteratorB.next()) {\n        // try to check keys first\n        var r = eq(nextA.value[0], nextB.value[0], { collectAllFails: false, _meet: this._meet });\n\n        if (r.length === 0) {\n          keyFound = true;\n\n          // check values also\n          eq(nextA.value[1], nextB.value[1], this);\n        }\n      }\n\n      if (!keyFound) {\n        // no such key at all\n        this.collectFail(true, format(SET_MAP_MISSING_KEY, nextA.value[0]));\n      }\n    }\n\n    this._meet.pop();\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\n\nfunction eq(a, b, opts) {\n  return new EQ(opts, a, b).check();\n}\n\neq.EQ = EQ;\n\nmodule.exports = eq;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should-equal/cjs/should-equal.js\n// module id = 96\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(require('should-type'));\nvar shouldTypeAdaptors = require('should-type-adaptors');\n\nfunction looksLikeANumber(n) {\n  return !!n.match(/\\d+/);\n}\n\nfunction keyCompare(a, b) {\n  var aNum = looksLikeANumber(a);\n  var bNum = looksLikeANumber(b);\n  if (aNum && bNum) {\n    return 1*a - 1*b;\n  } else if (aNum && !bNum) {\n    return -1;\n  } else if (!aNum && bNum) {\n    return 1;\n  } else {\n    return a.localeCompare(b);\n  }\n}\n\nfunction genKeysFunc(f) {\n  return function(value) {\n    var k = f(value);\n    k.sort(keyCompare);\n    return k;\n  };\n}\n\nfunction Formatter(opts) {\n  opts = opts || {};\n\n  this.seen = [];\n\n  var keysFunc;\n  if (typeof opts.keysFunc === 'function') {\n    keysFunc = opts.keysFunc;\n  } else if (opts.keys === false) {\n    keysFunc = Object.getOwnPropertyNames;\n  } else {\n    keysFunc = Object.keys;\n  }\n\n  this.getKeys = genKeysFunc(keysFunc);\n\n  this.maxLineLength = typeof opts.maxLineLength === 'number' ? opts.maxLineLength : 60;\n  this.propSep = opts.propSep || ',';\n\n  this.isUTCdate = !!opts.isUTCdate;\n}\n\n\n\nFormatter.prototype = {\n  constructor: Formatter,\n\n  format: function(value) {\n    var tp = t(value);\n\n    if (this.alreadySeen(value)) {\n      return '[Circular]';\n    }\n\n    var tries = tp.toTryTypes();\n    var f = this.defaultFormat;\n    while (tries.length) {\n      var toTry = tries.shift();\n      var name = Formatter.formatterFunctionName(toTry);\n      if (this[name]) {\n        f = this[name];\n        break;\n      }\n    }\n    return f.call(this, value).trim();\n  },\n\n  defaultFormat: function(obj) {\n    return String(obj);\n  },\n\n  alreadySeen: function(value) {\n    return this.seen.indexOf(value) >= 0;\n  }\n\n};\n\nFormatter.addType = function addType(tp, f) {\n  Formatter.prototype[Formatter.formatterFunctionName(tp)] = f;\n};\n\nFormatter.formatterFunctionName = function formatterFunctionName(tp) {\n  return '_format_' + tp.toString('_');\n};\n\nvar EOL = '\\n';\n\nfunction indent(v, indentation) {\n  return v\n    .split(EOL)\n    .map(function(vv) {\n      return indentation + vv;\n    })\n    .join(EOL);\n}\n\nfunction pad(str, value, filler) {\n  str = String(str);\n  var isRight = false;\n\n  if (value < 0) {\n    isRight = true;\n    value = -value;\n  }\n\n  if (str.length < value) {\n    var padding = new Array(value - str.length + 1).join(filler);\n    return isRight ? str + padding : padding + str;\n  } else {\n    return str;\n  }\n}\n\nfunction pad0(str, value) {\n  return pad(str, value, '0');\n}\n\nvar functionNameRE = /^\\s*function\\s*(\\S*)\\s*\\(/;\n\nfunction functionName(f) {\n  if (f.name) {\n    return f.name;\n  }\n  var matches = f.toString().match(functionNameRE);\n  if (matches === null) {\n    // `functionNameRE` doesn't match arrow functions.\n    return '';\n  }\n  var name = matches[1];\n  return name;\n}\n\nfunction constructorName(obj) {\n  while (obj) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&  typeof descriptor.value === 'function') {\n      var name = functionName(descriptor.value);\n      if (name !== '') {\n        return name;\n      }\n    }\n\n    obj = Object.getPrototypeOf(obj);\n  }\n}\n\nvar INDENT = '  ';\n\nfunction addSpaces(str) {\n  return indent(str, INDENT);\n}\n\nfunction typeAdaptorForEachFormat(obj, opts) {\n  opts = opts || {};\n  var filterKey = opts.filterKey || function() { return true; };\n\n  var formatKey = opts.formatKey || this.format;\n  var formatValue = opts.formatValue || this.format;\n\n  var keyValueSep = typeof opts.keyValueSep !== 'undefined' ? opts.keyValueSep : ': ';\n\n  this.seen.push(obj);\n\n  var formatLength = 0;\n  var pairs = [];\n\n  shouldTypeAdaptors.forEach(obj, function(value, key) {\n    if (!filterKey(key)) {\n      return;\n    }\n\n    var formattedKey = formatKey.call(this, key);\n    var formattedValue = formatValue.call(this, value, key);\n\n    var pair = formattedKey ? (formattedKey + keyValueSep + formattedValue) : formattedValue;\n\n    formatLength += pair.length;\n    pairs.push(pair);\n  }, this);\n\n  this.seen.pop();\n\n  (opts.additionalKeys || []).forEach(function(keyValue) {\n    var pair = keyValue[0] + keyValueSep + this.format(keyValue[1]);\n    formatLength += pair.length;\n    pairs.push(pair);\n  }, this);\n\n  var prefix = opts.prefix || constructorName(obj) || '';\n  if (prefix.length > 0) {\n    prefix += ' ';\n  }\n\n  var lbracket, rbracket;\n  if (Array.isArray(opts.brackets)) {\n    lbracket = opts.brackets[0];\n    rbracket = opts.brackets[1];\n  } else {\n    lbracket = '{';\n    rbracket = '}';\n  }\n\n  var rootValue = opts.value || '';\n\n  if (pairs.length === 0) {\n    return rootValue || (prefix + lbracket + rbracket);\n  }\n\n  if (formatLength <= this.maxLineLength) {\n    return prefix + lbracket + ' ' + (rootValue ? rootValue + ' ' : '') + pairs.join(this.propSep + ' ') + ' ' + rbracket;\n  } else {\n    return prefix + lbracket + '\\n' + (rootValue ? '  ' + rootValue + '\\n' : '') + pairs.map(addSpaces).join(this.propSep + '\\n') + '\\n' + rbracket;\n  }\n}\n\nfunction formatPlainObjectKey(key) {\n  return typeof key === 'string' && key.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? key : this.format(key);\n}\n\nfunction getPropertyDescriptor(obj, key) {\n  var desc;\n  try {\n    desc = Object.getOwnPropertyDescriptor(obj, key) || { value: obj[key] };\n  } catch (e) {\n    desc = { value: e };\n  }\n  return desc;\n}\n\nfunction formatPlainObjectValue(obj, key) {\n  var desc = getPropertyDescriptor(obj, key);\n  if (desc.get && desc.set) {\n    return '[Getter/Setter]';\n  }\n  if (desc.get) {\n    return '[Getter]';\n  }\n  if (desc.set) {\n    return '[Setter]';\n  }\n\n  return this.format(desc.value);\n}\n\nfunction formatPlainObject(obj, opts) {\n  opts = opts || {};\n  opts.keyValueSep = ': ';\n  opts.formatKey = opts.formatKey || formatPlainObjectKey;\n  opts.formatValue = opts.formatValue || function(value, key) {\n    return formatPlainObjectValue.call(this, obj, key);\n  };\n  return typeAdaptorForEachFormat.call(this, obj, opts);\n}\n\nfunction formatWrapper1(value) {\n  return formatPlainObject.call(this, value, {\n    additionalKeys: [['[[PrimitiveValue]]', value.valueOf()]]\n  });\n}\n\n\nfunction formatWrapper2(value) {\n  var realValue = value.valueOf();\n\n  return formatPlainObject.call(this, value, {\n    filterKey: function(key) {\n      //skip useless indexed properties\n      return !(key.match(/\\d+/) && parseInt(key, 10) < realValue.length);\n    },\n    additionalKeys: [['[[PrimitiveValue]]', realValue]]\n  });\n}\n\nfunction formatRegExp(value) {\n  return formatPlainObject.call(this, value, {\n    value: String(value)\n  });\n}\n\nfunction formatFunction(value) {\n  return formatPlainObject.call(this, value, {\n    prefix: 'Function',\n    additionalKeys: [['name', functionName(value)]]\n  });\n}\n\nfunction formatArray(value) {\n  return formatPlainObject.call(this, value, {\n    formatKey: function(key) {\n      if (!key.match(/\\d+/)) {\n        return formatPlainObjectKey.call(this, key);\n      }\n    },\n    brackets: ['[', ']']\n  });\n}\n\nfunction formatArguments(value) {\n  return formatPlainObject.call(this, value, {\n    formatKey: function(key) {\n      if (!key.match(/\\d+/)) {\n        return formatPlainObjectKey.call(this, key);\n      }\n    },\n    brackets: ['[', ']'],\n    prefix: 'Arguments'\n  });\n}\n\nfunction _formatDate(value, isUTC) {\n  var prefix = isUTC ? 'UTC' : '';\n\n  var date = value['get' + prefix + 'FullYear']() +\n    '-' +\n    pad0(value['get' + prefix + 'Month']() + 1, 2) +\n    '-' +\n    pad0(value['get' + prefix + 'Date'](), 2);\n\n  var time = pad0(value['get' + prefix + 'Hours'](), 2) +\n    ':' +\n    pad0(value['get' + prefix + 'Minutes'](), 2) +\n    ':' +\n    pad0(value['get' + prefix + 'Seconds'](), 2) +\n    '.' +\n    pad0(value['get' + prefix + 'Milliseconds'](), 3);\n\n  var to = value.getTimezoneOffset();\n  var absTo = Math.abs(to);\n  var hours = Math.floor(absTo / 60);\n  var minutes = absTo - hours * 60;\n  var tzFormat = (to < 0 ? '+' : '-') + pad0(hours, 2) + pad0(minutes, 2);\n\n  return date + ' ' + time + (isUTC ? '' : ' ' + tzFormat);\n}\n\nfunction formatDate(value) {\n  return formatPlainObject.call(this, value, { value: _formatDate(value, this.isUTCdate) });\n}\n\nfunction formatError(value) {\n  return formatPlainObject.call(this, value, {\n    prefix: value.name,\n    additionalKeys: [['message', value.message]]\n  });\n}\n\nfunction generateFormatForNumberArray(lengthProp, name, padding) {\n  return function(value) {\n    var max = this.byteArrayMaxLength || 50;\n    var length = value[lengthProp];\n    var formattedValues = [];\n    var len = 0;\n    for (var i = 0; i < max && i < length; i++) {\n      var b = value[i] || 0;\n      var v = pad0(b.toString(16), padding);\n      len += v.length;\n      formattedValues.push(v);\n    }\n    var prefix = value.constructor.name || name || '';\n    if (prefix) {\n      prefix += ' ';\n    }\n\n    if (formattedValues.length === 0) {\n      return prefix + '[]';\n    }\n\n    if (len <= this.maxLineLength) {\n      return prefix + '[ ' + formattedValues.join(this.propSep + ' ') + ' ' + ']';\n    } else {\n      return prefix + '[\\n' + formattedValues.map(addSpaces).join(this.propSep + '\\n') + '\\n' + ']';\n    }\n  };\n}\n\nfunction formatMap(obj) {\n  return typeAdaptorForEachFormat.call(this, obj, {\n    keyValueSep: ' => '\n  });\n}\n\nfunction formatSet(obj) {\n  return typeAdaptorForEachFormat.call(this, obj, {\n    keyValueSep: '',\n    formatKey: function() { return ''; }\n  });\n}\n\nfunction genSimdVectorFormat(constructorName, length) {\n  return function(value) {\n    var Constructor = value.constructor;\n    var extractLane = Constructor.extractLane;\n\n    var len = 0;\n    var props = [];\n\n    for (var i = 0; i < length; i ++) {\n      var key = this.format(extractLane(value, i));\n      len += key.length;\n      props.push(key);\n    }\n\n    if (len <= this.maxLineLength) {\n      return constructorName + ' [ ' + props.join(this.propSep + ' ') + ' ]';\n    } else {\n      return constructorName + ' [\\n' + props.map(addSpaces).join(this.propSep + '\\n') + '\\n' + ']';\n    }\n  };\n}\n\nfunction defaultFormat(value, opts) {\n  return new Formatter(opts).format(value);\n}\n\ndefaultFormat.Formatter = Formatter;\ndefaultFormat.addSpaces = addSpaces;\ndefaultFormat.pad0 = pad0;\ndefaultFormat.functionName = functionName;\ndefaultFormat.constructorName = constructorName;\ndefaultFormat.formatPlainObjectKey = formatPlainObjectKey;\ndefaultFormat.formatPlainObject = formatPlainObject;\ndefaultFormat.typeAdaptorForEachFormat = typeAdaptorForEachFormat;\n// adding primitive types\nFormatter.addType(new t.Type(t.UNDEFINED), function() {\n  return 'undefined';\n});\nFormatter.addType(new t.Type(t.NULL), function() {\n  return 'null';\n});\nFormatter.addType(new t.Type(t.BOOLEAN), function(value) {\n  return value ? 'true': 'false';\n});\nFormatter.addType(new t.Type(t.SYMBOL), function(value) {\n  return value.toString();\n});\nFormatter.addType(new t.Type(t.NUMBER), function(value) {\n  if (value === 0 && 1 / value < 0) {\n    return '-0';\n  }\n  return String(value);\n});\n\nFormatter.addType(new t.Type(t.STRING), function(value) {\n  return '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n      .replace(/'/g, \"\\\\'\")\n      .replace(/\\\\\"/g, '\"') + '\\'';\n});\n\nFormatter.addType(new t.Type(t.FUNCTION), formatFunction);\n\n// plain object\nFormatter.addType(new t.Type(t.OBJECT), formatPlainObject);\n\n// type wrappers\nFormatter.addType(new t.Type(t.OBJECT, t.NUMBER), formatWrapper1);\nFormatter.addType(new t.Type(t.OBJECT, t.BOOLEAN), formatWrapper1);\nFormatter.addType(new t.Type(t.OBJECT, t.STRING), formatWrapper2);\n\nFormatter.addType(new t.Type(t.OBJECT, t.REGEXP), formatRegExp);\nFormatter.addType(new t.Type(t.OBJECT, t.ARRAY), formatArray);\nFormatter.addType(new t.Type(t.OBJECT, t.ARGUMENTS), formatArguments);\nFormatter.addType(new t.Type(t.OBJECT, t.DATE), formatDate);\nFormatter.addType(new t.Type(t.OBJECT, t.ERROR), formatError);\nFormatter.addType(new t.Type(t.OBJECT, t.SET), formatSet);\nFormatter.addType(new t.Type(t.OBJECT, t.MAP), formatMap);\nFormatter.addType(new t.Type(t.OBJECT, t.WEAK_MAP), formatMap);\nFormatter.addType(new t.Type(t.OBJECT, t.WEAK_SET), formatSet);\n\nFormatter.addType(new t.Type(t.OBJECT, t.BUFFER), generateFormatForNumberArray('length', 'Buffer', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.ARRAY_BUFFER), generateFormatForNumberArray('byteLength', 'ArrayBuffer', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int8'), generateFormatForNumberArray('length', 'Int8Array', 2));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8'), generateFormatForNumberArray('length', 'Uint8Array', 2));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8clamped'), generateFormatForNumberArray('length', 'Uint8ClampedArray', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int16'), generateFormatForNumberArray('length', 'Int16Array', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint16'), generateFormatForNumberArray('length', 'Uint16Array', 4));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int32'), generateFormatForNumberArray('length', 'Int32Array', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint32'), generateFormatForNumberArray('length', 'Uint32Array', 8));\n\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool16x8'), genSimdVectorFormat('Bool16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool32x4'), genSimdVectorFormat('Bool32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool8x16'), genSimdVectorFormat('Bool8x16', 16));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'float32x4'), genSimdVectorFormat('Float32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int16x8'), genSimdVectorFormat('Int16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int32x4'), genSimdVectorFormat('Int32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int8x16'), genSimdVectorFormat('Int8x16', 16));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint16x8'), genSimdVectorFormat('Uint16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint32x4'), genSimdVectorFormat('Uint32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint8x16'), genSimdVectorFormat('Uint8x16', 16));\n\n\nFormatter.addType(new t.Type(t.OBJECT, t.PROMISE), function() {\n  return '[Promise]';//TODO it could be nice to inspect its state and value\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.XHR), function() {\n  return '[XMLHttpRequest]';//TODO it could be nice to inspect its state\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT), function(value) {\n  return value.outerHTML;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#text'), function(value) {\n  return value.nodeValue;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#document'), function(value) {\n  return value.documentElement.outerHTML;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HOST), function() {\n  return '[Host]';\n});\n\nmodule.exports = defaultFormat;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should-format/cjs/should-format.js\n// module id = 97\n// module chunks = 0","var should = require('./cjs/should');\n\nvar defaultProto = Object.prototype;\nvar defaultProperty = 'should';\n\n//Expose api via `Object#should`.\ntry {\n  var prevShould = should.extend(defaultProperty, defaultProto);\n  should._prevShould = prevShould;\n} catch(e) {\n  //ignore errors\n}\n\nmodule.exports = should;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/should/index.js\n// module id = 98\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/~/inherits/inherits_browser.js\n// module id = 99\n// module chunks = 0","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/support/isBufferBrowser.js\n// module id = 100\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/util.js\n// module id = 101\n// module chunks = 0","import should from 'should/as-function';\nimport 'should-approximately-deep';\nimport Feature from 'ol/feature';\nimport LineString from 'ol/geom/linestring';\nimport pointsAlongLine from '../pointsalongline';\n\ndescribe('pointsAlongLine', function() {\n  it('adds correct points along a line', function() {\n    var line = new Feature(new LineString([[0, 0], [0.1, 0.1]]));\n    var points = pointsAlongLine(line, 1);\n    should(points).have.length(15);\n    var firstCoordinate = points[0].getGeometry().getCoordinates();\n    should(firstCoordinate).be.approximatelyDeep([0.0063, 0.0063], 1e-4);\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./test/test.js\n// module id = 102\n// module chunks = 0"],"sourceRoot":""}